"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/axios";
exports.ids = ["vendor-chunks/axios"];
exports.modules = {

/***/ "(rsc)/./node_modules/axios/dist/node/axios.cjs":
/*!************************************************!*\
  !*** ./node_modules/axios/dist/node/axios.cjs ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*! Axios v1.13.4 Copyright (c) 2026 Matt Zabriskie and contributors */ \nconst FormData$1 = __webpack_require__(/*! form-data */ \"(rsc)/./node_modules/form-data/lib/form_data.js\");\nconst crypto = __webpack_require__(/*! crypto */ \"crypto\");\nconst url = __webpack_require__(/*! url */ \"url\");\nconst proxyFromEnv = __webpack_require__(/*! proxy-from-env */ \"(rsc)/./node_modules/proxy-from-env/index.js\");\nconst http = __webpack_require__(/*! http */ \"http\");\nconst https = __webpack_require__(/*! https */ \"https\");\nconst http2 = __webpack_require__(/*! http2 */ \"http2\");\nconst util = __webpack_require__(/*! util */ \"util\");\nconst followRedirects = __webpack_require__(/*! follow-redirects */ \"(rsc)/./node_modules/follow-redirects/index.js\");\nconst zlib = __webpack_require__(/*! zlib */ \"zlib\");\nconst stream = __webpack_require__(/*! stream */ \"stream\");\nconst events = __webpack_require__(/*! events */ \"events\");\nfunction _interopDefaultLegacy(e) {\n    return e && typeof e === \"object\" && \"default\" in e ? e : {\n        \"default\": e\n    };\n}\nconst FormData__default = /*#__PURE__*/ _interopDefaultLegacy(FormData$1);\nconst crypto__default = /*#__PURE__*/ _interopDefaultLegacy(crypto);\nconst url__default = /*#__PURE__*/ _interopDefaultLegacy(url);\nconst proxyFromEnv__default = /*#__PURE__*/ _interopDefaultLegacy(proxyFromEnv);\nconst http__default = /*#__PURE__*/ _interopDefaultLegacy(http);\nconst https__default = /*#__PURE__*/ _interopDefaultLegacy(https);\nconst http2__default = /*#__PURE__*/ _interopDefaultLegacy(http2);\nconst util__default = /*#__PURE__*/ _interopDefaultLegacy(util);\nconst followRedirects__default = /*#__PURE__*/ _interopDefaultLegacy(followRedirects);\nconst zlib__default = /*#__PURE__*/ _interopDefaultLegacy(zlib);\nconst stream__default = /*#__PURE__*/ _interopDefaultLegacy(stream);\n/**\n * Create a bound version of a function with a specified `this` context\n *\n * @param {Function} fn - The function to bind\n * @param {*} thisArg - The value to be passed as the `this` parameter\n * @returns {Function} A new function that will call the original function with the specified `this` context\n */ function bind(fn, thisArg) {\n    return function wrap() {\n        return fn.apply(thisArg, arguments);\n    };\n}\n// utils is a library of generic helper functions non-specific to axios\nconst { toString } = Object.prototype;\nconst { getPrototypeOf } = Object;\nconst { iterator, toStringTag } = Symbol;\nconst kindOf = ((cache)=>(thing)=>{\n        const str = toString.call(thing);\n        return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());\n    })(Object.create(null));\nconst kindOfTest = (type)=>{\n    type = type.toLowerCase();\n    return (thing)=>kindOf(thing) === type;\n};\nconst typeOfTest = (type)=>(thing)=>typeof thing === type;\n/**\n * Determine if a value is an Array\n *\n * @param {Object} val The value to test\n *\n * @returns {boolean} True if value is an Array, otherwise false\n */ const { isArray } = Array;\n/**\n * Determine if a value is undefined\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if the value is undefined, otherwise false\n */ const isUndefined = typeOfTest(\"undefined\");\n/**\n * Determine if a value is a Buffer\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a Buffer, otherwise false\n */ function isBuffer(val) {\n    return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction$1(val.constructor.isBuffer) && val.constructor.isBuffer(val);\n}\n/**\n * Determine if a value is an ArrayBuffer\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is an ArrayBuffer, otherwise false\n */ const isArrayBuffer = kindOfTest(\"ArrayBuffer\");\n/**\n * Determine if a value is a view on an ArrayBuffer\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false\n */ function isArrayBufferView(val) {\n    let result;\n    if (typeof ArrayBuffer !== \"undefined\" && ArrayBuffer.isView) {\n        result = ArrayBuffer.isView(val);\n    } else {\n        result = val && val.buffer && isArrayBuffer(val.buffer);\n    }\n    return result;\n}\n/**\n * Determine if a value is a String\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a String, otherwise false\n */ const isString = typeOfTest(\"string\");\n/**\n * Determine if a value is a Function\n *\n * @param {*} val The value to test\n * @returns {boolean} True if value is a Function, otherwise false\n */ const isFunction$1 = typeOfTest(\"function\");\n/**\n * Determine if a value is a Number\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a Number, otherwise false\n */ const isNumber = typeOfTest(\"number\");\n/**\n * Determine if a value is an Object\n *\n * @param {*} thing The value to test\n *\n * @returns {boolean} True if value is an Object, otherwise false\n */ const isObject = (thing)=>thing !== null && typeof thing === \"object\";\n/**\n * Determine if a value is a Boolean\n *\n * @param {*} thing The value to test\n * @returns {boolean} True if value is a Boolean, otherwise false\n */ const isBoolean = (thing)=>thing === true || thing === false;\n/**\n * Determine if a value is a plain Object\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a plain Object, otherwise false\n */ const isPlainObject = (val)=>{\n    if (kindOf(val) !== \"object\") {\n        return false;\n    }\n    const prototype = getPrototypeOf(val);\n    return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(toStringTag in val) && !(iterator in val);\n};\n/**\n * Determine if a value is an empty object (safely handles Buffers)\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is an empty object, otherwise false\n */ const isEmptyObject = (val)=>{\n    // Early return for non-objects or Buffers to prevent RangeError\n    if (!isObject(val) || isBuffer(val)) {\n        return false;\n    }\n    try {\n        return Object.keys(val).length === 0 && Object.getPrototypeOf(val) === Object.prototype;\n    } catch (e) {\n        // Fallback for any other objects that might cause RangeError with Object.keys()\n        return false;\n    }\n};\n/**\n * Determine if a value is a Date\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a Date, otherwise false\n */ const isDate = kindOfTest(\"Date\");\n/**\n * Determine if a value is a File\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a File, otherwise false\n */ const isFile = kindOfTest(\"File\");\n/**\n * Determine if a value is a Blob\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a Blob, otherwise false\n */ const isBlob = kindOfTest(\"Blob\");\n/**\n * Determine if a value is a FileList\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a File, otherwise false\n */ const isFileList = kindOfTest(\"FileList\");\n/**\n * Determine if a value is a Stream\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a Stream, otherwise false\n */ const isStream = (val)=>isObject(val) && isFunction$1(val.pipe);\n/**\n * Determine if a value is a FormData\n *\n * @param {*} thing The value to test\n *\n * @returns {boolean} True if value is an FormData, otherwise false\n */ const isFormData = (thing)=>{\n    let kind;\n    return thing && (typeof FormData === \"function\" && thing instanceof FormData || isFunction$1(thing.append) && ((kind = kindOf(thing)) === \"formdata\" || // detect form-data instance\n    kind === \"object\" && isFunction$1(thing.toString) && thing.toString() === \"[object FormData]\"));\n};\n/**\n * Determine if a value is a URLSearchParams object\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a URLSearchParams object, otherwise false\n */ const isURLSearchParams = kindOfTest(\"URLSearchParams\");\nconst [isReadableStream, isRequest, isResponse, isHeaders] = [\n    \"ReadableStream\",\n    \"Request\",\n    \"Response\",\n    \"Headers\"\n].map(kindOfTest);\n/**\n * Trim excess whitespace off the beginning and end of a string\n *\n * @param {String} str The String to trim\n *\n * @returns {String} The String freed of excess whitespace\n */ const trim = (str)=>str.trim ? str.trim() : str.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, \"\");\n/**\n * Iterate over an Array or an Object invoking a function for each item.\n *\n * If `obj` is an Array callback will be called passing\n * the value, index, and complete array for each item.\n *\n * If 'obj' is an Object callback will be called passing\n * the value, key, and complete object for each property.\n *\n * @param {Object|Array<unknown>} obj The object to iterate\n * @param {Function} fn The callback to invoke for each item\n *\n * @param {Object} [options]\n * @param {Boolean} [options.allOwnKeys = false]\n * @returns {any}\n */ function forEach(obj, fn, { allOwnKeys = false } = {}) {\n    // Don't bother if no value provided\n    if (obj === null || typeof obj === \"undefined\") {\n        return;\n    }\n    let i;\n    let l;\n    // Force an array if not already something iterable\n    if (typeof obj !== \"object\") {\n        /*eslint no-param-reassign:0*/ obj = [\n            obj\n        ];\n    }\n    if (isArray(obj)) {\n        // Iterate over array values\n        for(i = 0, l = obj.length; i < l; i++){\n            fn.call(null, obj[i], i, obj);\n        }\n    } else {\n        // Buffer check\n        if (isBuffer(obj)) {\n            return;\n        }\n        // Iterate over object keys\n        const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);\n        const len = keys.length;\n        let key;\n        for(i = 0; i < len; i++){\n            key = keys[i];\n            fn.call(null, obj[key], key, obj);\n        }\n    }\n}\nfunction findKey(obj, key) {\n    if (isBuffer(obj)) {\n        return null;\n    }\n    key = key.toLowerCase();\n    const keys = Object.keys(obj);\n    let i = keys.length;\n    let _key;\n    while(i-- > 0){\n        _key = keys[i];\n        if (key === _key.toLowerCase()) {\n            return _key;\n        }\n    }\n    return null;\n}\nconst _global = (()=>{\n    /*eslint no-undef:0*/ if (typeof globalThis !== \"undefined\") return globalThis;\n    return typeof self !== \"undefined\" ? self :  false ? 0 : global;\n})();\nconst isContextDefined = (context)=>!isUndefined(context) && context !== _global;\n/**\n * Accepts varargs expecting each argument to be an object, then\n * immutably merges the properties of each object and returns result.\n *\n * When multiple objects contain the same key the later object in\n * the arguments list will take precedence.\n *\n * Example:\n *\n * ```js\n * const result = merge({foo: 123}, {foo: 456});\n * console.log(result.foo); // outputs 456\n * ```\n *\n * @param {Object} obj1 Object to merge\n *\n * @returns {Object} Result of all merge properties\n */ function merge() {\n    const { caseless, skipUndefined } = isContextDefined(this) && this || {};\n    const result = {};\n    const assignValue = (val, key)=>{\n        const targetKey = caseless && findKey(result, key) || key;\n        if (isPlainObject(result[targetKey]) && isPlainObject(val)) {\n            result[targetKey] = merge(result[targetKey], val);\n        } else if (isPlainObject(val)) {\n            result[targetKey] = merge({}, val);\n        } else if (isArray(val)) {\n            result[targetKey] = val.slice();\n        } else if (!skipUndefined || !isUndefined(val)) {\n            result[targetKey] = val;\n        }\n    };\n    for(let i = 0, l = arguments.length; i < l; i++){\n        arguments[i] && forEach(arguments[i], assignValue);\n    }\n    return result;\n}\n/**\n * Extends object a by mutably adding to it the properties of object b.\n *\n * @param {Object} a The object to be extended\n * @param {Object} b The object to copy properties from\n * @param {Object} thisArg The object to bind function to\n *\n * @param {Object} [options]\n * @param {Boolean} [options.allOwnKeys]\n * @returns {Object} The resulting value of object a\n */ const extend = (a, b, thisArg, { allOwnKeys } = {})=>{\n    forEach(b, (val, key)=>{\n        if (thisArg && isFunction$1(val)) {\n            Object.defineProperty(a, key, {\n                value: bind(val, thisArg),\n                writable: true,\n                enumerable: true,\n                configurable: true\n            });\n        } else {\n            Object.defineProperty(a, key, {\n                value: val,\n                writable: true,\n                enumerable: true,\n                configurable: true\n            });\n        }\n    }, {\n        allOwnKeys\n    });\n    return a;\n};\n/**\n * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)\n *\n * @param {string} content with BOM\n *\n * @returns {string} content value without BOM\n */ const stripBOM = (content)=>{\n    if (content.charCodeAt(0) === 0xFEFF) {\n        content = content.slice(1);\n    }\n    return content;\n};\n/**\n * Inherit the prototype methods from one constructor into another\n * @param {function} constructor\n * @param {function} superConstructor\n * @param {object} [props]\n * @param {object} [descriptors]\n *\n * @returns {void}\n */ const inherits = (constructor, superConstructor, props, descriptors)=>{\n    constructor.prototype = Object.create(superConstructor.prototype, descriptors);\n    Object.defineProperty(constructor.prototype, \"constructor\", {\n        value: constructor,\n        writable: true,\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(constructor, \"super\", {\n        value: superConstructor.prototype\n    });\n    props && Object.assign(constructor.prototype, props);\n};\n/**\n * Resolve object with deep prototype chain to a flat object\n * @param {Object} sourceObj source object\n * @param {Object} [destObj]\n * @param {Function|Boolean} [filter]\n * @param {Function} [propFilter]\n *\n * @returns {Object}\n */ const toFlatObject = (sourceObj, destObj, filter, propFilter)=>{\n    let props;\n    let i;\n    let prop;\n    const merged = {};\n    destObj = destObj || {};\n    // eslint-disable-next-line no-eq-null,eqeqeq\n    if (sourceObj == null) return destObj;\n    do {\n        props = Object.getOwnPropertyNames(sourceObj);\n        i = props.length;\n        while(i-- > 0){\n            prop = props[i];\n            if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {\n                destObj[prop] = sourceObj[prop];\n                merged[prop] = true;\n            }\n        }\n        sourceObj = filter !== false && getPrototypeOf(sourceObj);\n    }while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);\n    return destObj;\n};\n/**\n * Determines whether a string ends with the characters of a specified string\n *\n * @param {String} str\n * @param {String} searchString\n * @param {Number} [position= 0]\n *\n * @returns {boolean}\n */ const endsWith = (str, searchString, position)=>{\n    str = String(str);\n    if (position === undefined || position > str.length) {\n        position = str.length;\n    }\n    position -= searchString.length;\n    const lastIndex = str.indexOf(searchString, position);\n    return lastIndex !== -1 && lastIndex === position;\n};\n/**\n * Returns new array from array like object or null if failed\n *\n * @param {*} [thing]\n *\n * @returns {?Array}\n */ const toArray = (thing)=>{\n    if (!thing) return null;\n    if (isArray(thing)) return thing;\n    let i = thing.length;\n    if (!isNumber(i)) return null;\n    const arr = new Array(i);\n    while(i-- > 0){\n        arr[i] = thing[i];\n    }\n    return arr;\n};\n/**\n * Checking if the Uint8Array exists and if it does, it returns a function that checks if the\n * thing passed in is an instance of Uint8Array\n *\n * @param {TypedArray}\n *\n * @returns {Array}\n */ // eslint-disable-next-line func-names\nconst isTypedArray = ((TypedArray)=>{\n    // eslint-disable-next-line func-names\n    return (thing)=>{\n        return TypedArray && thing instanceof TypedArray;\n    };\n})(typeof Uint8Array !== \"undefined\" && getPrototypeOf(Uint8Array));\n/**\n * For each entry in the object, call the function with the key and value.\n *\n * @param {Object<any, any>} obj - The object to iterate over.\n * @param {Function} fn - The function to call for each entry.\n *\n * @returns {void}\n */ const forEachEntry = (obj, fn)=>{\n    const generator = obj && obj[iterator];\n    const _iterator = generator.call(obj);\n    let result;\n    while((result = _iterator.next()) && !result.done){\n        const pair = result.value;\n        fn.call(obj, pair[0], pair[1]);\n    }\n};\n/**\n * It takes a regular expression and a string, and returns an array of all the matches\n *\n * @param {string} regExp - The regular expression to match against.\n * @param {string} str - The string to search.\n *\n * @returns {Array<boolean>}\n */ const matchAll = (regExp, str)=>{\n    let matches;\n    const arr = [];\n    while((matches = regExp.exec(str)) !== null){\n        arr.push(matches);\n    }\n    return arr;\n};\n/* Checking if the kindOfTest function returns true when passed an HTMLFormElement. */ const isHTMLForm = kindOfTest(\"HTMLFormElement\");\nconst toCamelCase = (str)=>{\n    return str.toLowerCase().replace(/[-_\\s]([a-z\\d])(\\w*)/g, function replacer(m, p1, p2) {\n        return p1.toUpperCase() + p2;\n    });\n};\n/* Creating a function that will check if an object has a property. */ const hasOwnProperty = (({ hasOwnProperty })=>(obj, prop)=>hasOwnProperty.call(obj, prop))(Object.prototype);\n/**\n * Determine if a value is a RegExp object\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a RegExp object, otherwise false\n */ const isRegExp = kindOfTest(\"RegExp\");\nconst reduceDescriptors = (obj, reducer)=>{\n    const descriptors = Object.getOwnPropertyDescriptors(obj);\n    const reducedDescriptors = {};\n    forEach(descriptors, (descriptor, name)=>{\n        let ret;\n        if ((ret = reducer(descriptor, name, obj)) !== false) {\n            reducedDescriptors[name] = ret || descriptor;\n        }\n    });\n    Object.defineProperties(obj, reducedDescriptors);\n};\n/**\n * Makes all methods read-only\n * @param {Object} obj\n */ const freezeMethods = (obj)=>{\n    reduceDescriptors(obj, (descriptor, name)=>{\n        // skip restricted props in strict mode\n        if (isFunction$1(obj) && [\n            \"arguments\",\n            \"caller\",\n            \"callee\"\n        ].indexOf(name) !== -1) {\n            return false;\n        }\n        const value = obj[name];\n        if (!isFunction$1(value)) return;\n        descriptor.enumerable = false;\n        if (\"writable\" in descriptor) {\n            descriptor.writable = false;\n            return;\n        }\n        if (!descriptor.set) {\n            descriptor.set = ()=>{\n                throw Error(\"Can not rewrite read-only method '\" + name + \"'\");\n            };\n        }\n    });\n};\nconst toObjectSet = (arrayOrString, delimiter)=>{\n    const obj = {};\n    const define = (arr)=>{\n        arr.forEach((value)=>{\n            obj[value] = true;\n        });\n    };\n    isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));\n    return obj;\n};\nconst noop = ()=>{};\nconst toFiniteNumber = (value, defaultValue)=>{\n    return value != null && Number.isFinite(value = +value) ? value : defaultValue;\n};\n/**\n * If the thing is a FormData object, return true, otherwise return false.\n *\n * @param {unknown} thing - The thing to check.\n *\n * @returns {boolean}\n */ function isSpecCompliantForm(thing) {\n    return !!(thing && isFunction$1(thing.append) && thing[toStringTag] === \"FormData\" && thing[iterator]);\n}\nconst toJSONObject = (obj)=>{\n    const stack = new Array(10);\n    const visit = (source, i)=>{\n        if (isObject(source)) {\n            if (stack.indexOf(source) >= 0) {\n                return;\n            }\n            //Buffer check\n            if (isBuffer(source)) {\n                return source;\n            }\n            if (!(\"toJSON\" in source)) {\n                stack[i] = source;\n                const target = isArray(source) ? [] : {};\n                forEach(source, (value, key)=>{\n                    const reducedValue = visit(value, i + 1);\n                    !isUndefined(reducedValue) && (target[key] = reducedValue);\n                });\n                stack[i] = undefined;\n                return target;\n            }\n        }\n        return source;\n    };\n    return visit(obj, 0);\n};\nconst isAsyncFn = kindOfTest(\"AsyncFunction\");\nconst isThenable = (thing)=>thing && (isObject(thing) || isFunction$1(thing)) && isFunction$1(thing.then) && isFunction$1(thing.catch);\n// original code\n// https://github.com/DigitalBrainJS/AxiosPromise/blob/16deab13710ec09779922131f3fa5954320f83ab/lib/utils.js#L11-L34\nconst _setImmediate = ((setImmediateSupported, postMessageSupported)=>{\n    if (setImmediateSupported) {\n        return setImmediate;\n    }\n    return postMessageSupported ? ((token, callbacks)=>{\n        _global.addEventListener(\"message\", ({ source, data })=>{\n            if (source === _global && data === token) {\n                callbacks.length && callbacks.shift()();\n            }\n        }, false);\n        return (cb)=>{\n            callbacks.push(cb);\n            _global.postMessage(token, \"*\");\n        };\n    })(`axios@${Math.random()}`, []) : (cb)=>setTimeout(cb);\n})(typeof setImmediate === \"function\", isFunction$1(_global.postMessage));\nconst asap = typeof queueMicrotask !== \"undefined\" ? queueMicrotask.bind(_global) : typeof process !== \"undefined\" && process.nextTick || _setImmediate;\n// *********************\nconst isIterable = (thing)=>thing != null && isFunction$1(thing[iterator]);\nconst utils$1 = {\n    isArray,\n    isArrayBuffer,\n    isBuffer,\n    isFormData,\n    isArrayBufferView,\n    isString,\n    isNumber,\n    isBoolean,\n    isObject,\n    isPlainObject,\n    isEmptyObject,\n    isReadableStream,\n    isRequest,\n    isResponse,\n    isHeaders,\n    isUndefined,\n    isDate,\n    isFile,\n    isBlob,\n    isRegExp,\n    isFunction: isFunction$1,\n    isStream,\n    isURLSearchParams,\n    isTypedArray,\n    isFileList,\n    forEach,\n    merge,\n    extend,\n    trim,\n    stripBOM,\n    inherits,\n    toFlatObject,\n    kindOf,\n    kindOfTest,\n    endsWith,\n    toArray,\n    forEachEntry,\n    matchAll,\n    isHTMLForm,\n    hasOwnProperty,\n    hasOwnProp: hasOwnProperty,\n    reduceDescriptors,\n    freezeMethods,\n    toObjectSet,\n    toCamelCase,\n    noop,\n    toFiniteNumber,\n    findKey,\n    global: _global,\n    isContextDefined,\n    isSpecCompliantForm,\n    toJSONObject,\n    isAsyncFn,\n    isThenable,\n    setImmediate: _setImmediate,\n    asap,\n    isIterable\n};\nclass AxiosError extends Error {\n    static from(error, code, config, request, response, customProps) {\n        const axiosError = new AxiosError(error.message, code || error.code, config, request, response);\n        axiosError.cause = error;\n        axiosError.name = error.name;\n        customProps && Object.assign(axiosError, customProps);\n        return axiosError;\n    }\n    /**\n     * Create an Error with the specified message, config, error code, request and response.\n     *\n     * @param {string} message The error message.\n     * @param {string} [code] The error code (for example, 'ECONNABORTED').\n     * @param {Object} [config] The config.\n     * @param {Object} [request] The request.\n     * @param {Object} [response] The response.\n     *\n     * @returns {Error} The created error.\n     */ constructor(message, code, config, request, response){\n        super(message);\n        this.name = \"AxiosError\";\n        this.isAxiosError = true;\n        code && (this.code = code);\n        config && (this.config = config);\n        request && (this.request = request);\n        if (response) {\n            this.response = response;\n            this.status = response.status;\n        }\n    }\n    toJSON() {\n        return {\n            // Standard\n            message: this.message,\n            name: this.name,\n            // Microsoft\n            description: this.description,\n            number: this.number,\n            // Mozilla\n            fileName: this.fileName,\n            lineNumber: this.lineNumber,\n            columnNumber: this.columnNumber,\n            stack: this.stack,\n            // Axios\n            config: utils$1.toJSONObject(this.config),\n            code: this.code,\n            status: this.status\n        };\n    }\n}\n// This can be changed to static properties as soon as the parser options in .eslint.cjs are updated.\nAxiosError.ERR_BAD_OPTION_VALUE = \"ERR_BAD_OPTION_VALUE\";\nAxiosError.ERR_BAD_OPTION = \"ERR_BAD_OPTION\";\nAxiosError.ECONNABORTED = \"ECONNABORTED\";\nAxiosError.ETIMEDOUT = \"ETIMEDOUT\";\nAxiosError.ERR_NETWORK = \"ERR_NETWORK\";\nAxiosError.ERR_FR_TOO_MANY_REDIRECTS = \"ERR_FR_TOO_MANY_REDIRECTS\";\nAxiosError.ERR_DEPRECATED = \"ERR_DEPRECATED\";\nAxiosError.ERR_BAD_RESPONSE = \"ERR_BAD_RESPONSE\";\nAxiosError.ERR_BAD_REQUEST = \"ERR_BAD_REQUEST\";\nAxiosError.ERR_CANCELED = \"ERR_CANCELED\";\nAxiosError.ERR_NOT_SUPPORT = \"ERR_NOT_SUPPORT\";\nAxiosError.ERR_INVALID_URL = \"ERR_INVALID_URL\";\nconst AxiosError$1 = AxiosError;\n/**\n * Determines if the given thing is a array or js object.\n *\n * @param {string} thing - The object or array to be visited.\n *\n * @returns {boolean}\n */ function isVisitable(thing) {\n    return utils$1.isPlainObject(thing) || utils$1.isArray(thing);\n}\n/**\n * It removes the brackets from the end of a string\n *\n * @param {string} key - The key of the parameter.\n *\n * @returns {string} the key without the brackets.\n */ function removeBrackets(key) {\n    return utils$1.endsWith(key, \"[]\") ? key.slice(0, -2) : key;\n}\n/**\n * It takes a path, a key, and a boolean, and returns a string\n *\n * @param {string} path - The path to the current key.\n * @param {string} key - The key of the current object being iterated over.\n * @param {string} dots - If true, the key will be rendered with dots instead of brackets.\n *\n * @returns {string} The path to the current key.\n */ function renderKey(path, key, dots) {\n    if (!path) return key;\n    return path.concat(key).map(function each(token, i) {\n        // eslint-disable-next-line no-param-reassign\n        token = removeBrackets(token);\n        return !dots && i ? \"[\" + token + \"]\" : token;\n    }).join(dots ? \".\" : \"\");\n}\n/**\n * If the array is an array and none of its elements are visitable, then it's a flat array.\n *\n * @param {Array<any>} arr - The array to check\n *\n * @returns {boolean}\n */ function isFlatArray(arr) {\n    return utils$1.isArray(arr) && !arr.some(isVisitable);\n}\nconst predicates = utils$1.toFlatObject(utils$1, {}, null, function filter(prop) {\n    return /^is[A-Z]/.test(prop);\n});\n/**\n * Convert a data object to FormData\n *\n * @param {Object} obj\n * @param {?Object} [formData]\n * @param {?Object} [options]\n * @param {Function} [options.visitor]\n * @param {Boolean} [options.metaTokens = true]\n * @param {Boolean} [options.dots = false]\n * @param {?Boolean} [options.indexes = false]\n *\n * @returns {Object}\n **/ /**\n * It converts an object into a FormData object\n *\n * @param {Object<any, any>} obj - The object to convert to form data.\n * @param {string} formData - The FormData object to append to.\n * @param {Object<string, any>} options\n *\n * @returns\n */ function toFormData(obj, formData, options) {\n    if (!utils$1.isObject(obj)) {\n        throw new TypeError(\"target must be an object\");\n    }\n    // eslint-disable-next-line no-param-reassign\n    formData = formData || new (FormData__default[\"default\"] || FormData)();\n    // eslint-disable-next-line no-param-reassign\n    options = utils$1.toFlatObject(options, {\n        metaTokens: true,\n        dots: false,\n        indexes: false\n    }, false, function defined(option, source) {\n        // eslint-disable-next-line no-eq-null,eqeqeq\n        return !utils$1.isUndefined(source[option]);\n    });\n    const metaTokens = options.metaTokens;\n    // eslint-disable-next-line no-use-before-define\n    const visitor = options.visitor || defaultVisitor;\n    const dots = options.dots;\n    const indexes = options.indexes;\n    const _Blob = options.Blob || typeof Blob !== \"undefined\" && Blob;\n    const useBlob = _Blob && utils$1.isSpecCompliantForm(formData);\n    if (!utils$1.isFunction(visitor)) {\n        throw new TypeError(\"visitor must be a function\");\n    }\n    function convertValue(value) {\n        if (value === null) return \"\";\n        if (utils$1.isDate(value)) {\n            return value.toISOString();\n        }\n        if (utils$1.isBoolean(value)) {\n            return value.toString();\n        }\n        if (!useBlob && utils$1.isBlob(value)) {\n            throw new AxiosError$1(\"Blob is not supported. Use a Buffer instead.\");\n        }\n        if (utils$1.isArrayBuffer(value) || utils$1.isTypedArray(value)) {\n            return useBlob && typeof Blob === \"function\" ? new Blob([\n                value\n            ]) : Buffer.from(value);\n        }\n        return value;\n    }\n    /**\n   * Default visitor.\n   *\n   * @param {*} value\n   * @param {String|Number} key\n   * @param {Array<String|Number>} path\n   * @this {FormData}\n   *\n   * @returns {boolean} return true to visit the each prop of the value recursively\n   */ function defaultVisitor(value, key, path) {\n        let arr = value;\n        if (value && !path && typeof value === \"object\") {\n            if (utils$1.endsWith(key, \"{}\")) {\n                // eslint-disable-next-line no-param-reassign\n                key = metaTokens ? key : key.slice(0, -2);\n                // eslint-disable-next-line no-param-reassign\n                value = JSON.stringify(value);\n            } else if (utils$1.isArray(value) && isFlatArray(value) || (utils$1.isFileList(value) || utils$1.endsWith(key, \"[]\")) && (arr = utils$1.toArray(value))) {\n                // eslint-disable-next-line no-param-reassign\n                key = removeBrackets(key);\n                arr.forEach(function each(el, index) {\n                    !(utils$1.isUndefined(el) || el === null) && formData.append(// eslint-disable-next-line no-nested-ternary\n                    indexes === true ? renderKey([\n                        key\n                    ], index, dots) : indexes === null ? key : key + \"[]\", convertValue(el));\n                });\n                return false;\n            }\n        }\n        if (isVisitable(value)) {\n            return true;\n        }\n        formData.append(renderKey(path, key, dots), convertValue(value));\n        return false;\n    }\n    const stack = [];\n    const exposedHelpers = Object.assign(predicates, {\n        defaultVisitor,\n        convertValue,\n        isVisitable\n    });\n    function build(value, path) {\n        if (utils$1.isUndefined(value)) return;\n        if (stack.indexOf(value) !== -1) {\n            throw Error(\"Circular reference detected in \" + path.join(\".\"));\n        }\n        stack.push(value);\n        utils$1.forEach(value, function each(el, key) {\n            const result = !(utils$1.isUndefined(el) || el === null) && visitor.call(formData, el, utils$1.isString(key) ? key.trim() : key, path, exposedHelpers);\n            if (result === true) {\n                build(el, path ? path.concat(key) : [\n                    key\n                ]);\n            }\n        });\n        stack.pop();\n    }\n    if (!utils$1.isObject(obj)) {\n        throw new TypeError(\"data must be an object\");\n    }\n    build(obj);\n    return formData;\n}\n/**\n * It encodes a string by replacing all characters that are not in the unreserved set with\n * their percent-encoded equivalents\n *\n * @param {string} str - The string to encode.\n *\n * @returns {string} The encoded string.\n */ function encode$1(str) {\n    const charMap = {\n        \"!\": \"%21\",\n        \"'\": \"%27\",\n        \"(\": \"%28\",\n        \")\": \"%29\",\n        \"~\": \"%7E\",\n        \"%20\": \"+\",\n        \"%00\": \"\\x00\"\n    };\n    return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {\n        return charMap[match];\n    });\n}\n/**\n * It takes a params object and converts it to a FormData object\n *\n * @param {Object<string, any>} params - The parameters to be converted to a FormData object.\n * @param {Object<string, any>} options - The options object passed to the Axios constructor.\n *\n * @returns {void}\n */ function AxiosURLSearchParams(params, options) {\n    this._pairs = [];\n    params && toFormData(params, this, options);\n}\nconst prototype = AxiosURLSearchParams.prototype;\nprototype.append = function append(name, value) {\n    this._pairs.push([\n        name,\n        value\n    ]);\n};\nprototype.toString = function toString(encoder) {\n    const _encode = encoder ? function(value) {\n        return encoder.call(this, value, encode$1);\n    } : encode$1;\n    return this._pairs.map(function each(pair) {\n        return _encode(pair[0]) + \"=\" + _encode(pair[1]);\n    }, \"\").join(\"&\");\n};\n/**\n * It replaces all instances of the characters `:`, `$`, `,`, `+`, `[`, and `]` with their\n * URI encoded counterparts\n *\n * @param {string} val The value to be encoded.\n *\n * @returns {string} The encoded value.\n */ function encode(val) {\n    return encodeURIComponent(val).replace(/%3A/gi, \":\").replace(/%24/g, \"$\").replace(/%2C/gi, \",\").replace(/%20/g, \"+\");\n}\n/**\n * Build a URL by appending params to the end\n *\n * @param {string} url The base of the url (e.g., http://www.google.com)\n * @param {object} [params] The params to be appended\n * @param {?(object|Function)} options\n *\n * @returns {string} The formatted url\n */ function buildURL(url, params, options) {\n    if (!params) {\n        return url;\n    }\n    const _encode = options && options.encode || encode;\n    const _options = utils$1.isFunction(options) ? {\n        serialize: options\n    } : options;\n    const serializeFn = _options && _options.serialize;\n    let serializedParams;\n    if (serializeFn) {\n        serializedParams = serializeFn(params, _options);\n    } else {\n        serializedParams = utils$1.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams(params, _options).toString(_encode);\n    }\n    if (serializedParams) {\n        const hashmarkIndex = url.indexOf(\"#\");\n        if (hashmarkIndex !== -1) {\n            url = url.slice(0, hashmarkIndex);\n        }\n        url += (url.indexOf(\"?\") === -1 ? \"?\" : \"&\") + serializedParams;\n    }\n    return url;\n}\nclass InterceptorManager {\n    constructor(){\n        this.handlers = [];\n    }\n    /**\n   * Add a new interceptor to the stack\n   *\n   * @param {Function} fulfilled The function to handle `then` for a `Promise`\n   * @param {Function} rejected The function to handle `reject` for a `Promise`\n   * @param {Object} options The options for the interceptor, synchronous and runWhen\n   *\n   * @return {Number} An ID used to remove interceptor later\n   */ use(fulfilled, rejected, options) {\n        this.handlers.push({\n            fulfilled,\n            rejected,\n            synchronous: options ? options.synchronous : false,\n            runWhen: options ? options.runWhen : null\n        });\n        return this.handlers.length - 1;\n    }\n    /**\n   * Remove an interceptor from the stack\n   *\n   * @param {Number} id The ID that was returned by `use`\n   *\n   * @returns {void}\n   */ eject(id) {\n        if (this.handlers[id]) {\n            this.handlers[id] = null;\n        }\n    }\n    /**\n   * Clear all interceptors from the stack\n   *\n   * @returns {void}\n   */ clear() {\n        if (this.handlers) {\n            this.handlers = [];\n        }\n    }\n    /**\n   * Iterate over all the registered interceptors\n   *\n   * This method is particularly useful for skipping over any\n   * interceptors that may have become `null` calling `eject`.\n   *\n   * @param {Function} fn The function to call for each interceptor\n   *\n   * @returns {void}\n   */ forEach(fn) {\n        utils$1.forEach(this.handlers, function forEachHandler(h) {\n            if (h !== null) {\n                fn(h);\n            }\n        });\n    }\n}\nconst InterceptorManager$1 = InterceptorManager;\nconst transitionalDefaults = {\n    silentJSONParsing: true,\n    forcedJSONParsing: true,\n    clarifyTimeoutError: false\n};\nconst URLSearchParams = url__default[\"default\"].URLSearchParams;\nconst ALPHA = \"abcdefghijklmnopqrstuvwxyz\";\nconst DIGIT = \"0123456789\";\nconst ALPHABET = {\n    DIGIT,\n    ALPHA,\n    ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT\n};\nconst generateString = (size = 16, alphabet = ALPHABET.ALPHA_DIGIT)=>{\n    let str = \"\";\n    const { length } = alphabet;\n    const randomValues = new Uint32Array(size);\n    crypto__default[\"default\"].randomFillSync(randomValues);\n    for(let i = 0; i < size; i++){\n        str += alphabet[randomValues[i] % length];\n    }\n    return str;\n};\nconst platform$1 = {\n    isNode: true,\n    classes: {\n        URLSearchParams,\n        FormData: FormData__default[\"default\"],\n        Blob: typeof Blob !== \"undefined\" && Blob || null\n    },\n    ALPHABET,\n    generateString,\n    protocols: [\n        \"http\",\n        \"https\",\n        \"file\",\n        \"data\"\n    ]\n};\nconst hasBrowserEnv =  false && 0;\nconst _navigator = typeof navigator === \"object\" && navigator || undefined;\n/**\n * Determine if we're running in a standard browser environment\n *\n * This allows axios to run in a web worker, and react-native.\n * Both environments support XMLHttpRequest, but not fully standard globals.\n *\n * web workers:\n *  typeof window -> undefined\n *  typeof document -> undefined\n *\n * react-native:\n *  navigator.product -> 'ReactNative'\n * nativescript\n *  navigator.product -> 'NativeScript' or 'NS'\n *\n * @returns {boolean}\n */ const hasStandardBrowserEnv = hasBrowserEnv && (!_navigator || [\n    \"ReactNative\",\n    \"NativeScript\",\n    \"NS\"\n].indexOf(_navigator.product) < 0);\n/**\n * Determine if we're running in a standard browser webWorker environment\n *\n * Although the `isStandardBrowserEnv` method indicates that\n * `allows axios to run in a web worker`, the WebWorker will still be\n * filtered out due to its judgment standard\n * `typeof window !== 'undefined' && typeof document !== 'undefined'`.\n * This leads to a problem when axios post `FormData` in webWorker\n */ const hasStandardBrowserWebWorkerEnv = (()=>{\n    return typeof WorkerGlobalScope !== \"undefined\" && // eslint-disable-next-line no-undef\n    self instanceof WorkerGlobalScope && typeof self.importScripts === \"function\";\n})();\nconst origin = hasBrowserEnv && window.location.href || \"http://localhost\";\nconst utils = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    hasBrowserEnv: hasBrowserEnv,\n    hasStandardBrowserWebWorkerEnv: hasStandardBrowserWebWorkerEnv,\n    hasStandardBrowserEnv: hasStandardBrowserEnv,\n    navigator: _navigator,\n    origin: origin\n});\nconst platform = {\n    ...utils,\n    ...platform$1\n};\nfunction toURLEncodedForm(data, options) {\n    return toFormData(data, new platform.classes.URLSearchParams(), {\n        visitor: function(value, key, path, helpers) {\n            if (platform.isNode && utils$1.isBuffer(value)) {\n                this.append(key, value.toString(\"base64\"));\n                return false;\n            }\n            return helpers.defaultVisitor.apply(this, arguments);\n        },\n        ...options\n    });\n}\n/**\n * It takes a string like `foo[x][y][z]` and returns an array like `['foo', 'x', 'y', 'z']\n *\n * @param {string} name - The name of the property to get.\n *\n * @returns An array of strings.\n */ function parsePropPath(name) {\n    // foo[x][y][z]\n    // foo.x.y.z\n    // foo-x-y-z\n    // foo x y z\n    return utils$1.matchAll(/\\w+|\\[(\\w*)]/g, name).map((match)=>{\n        return match[0] === \"[]\" ? \"\" : match[1] || match[0];\n    });\n}\n/**\n * Convert an array to an object.\n *\n * @param {Array<any>} arr - The array to convert to an object.\n *\n * @returns An object with the same keys and values as the array.\n */ function arrayToObject(arr) {\n    const obj = {};\n    const keys = Object.keys(arr);\n    let i;\n    const len = keys.length;\n    let key;\n    for(i = 0; i < len; i++){\n        key = keys[i];\n        obj[key] = arr[key];\n    }\n    return obj;\n}\n/**\n * It takes a FormData object and returns a JavaScript object\n *\n * @param {string} formData The FormData object to convert to JSON.\n *\n * @returns {Object<string, any> | null} The converted object.\n */ function formDataToJSON(formData) {\n    function buildPath(path, value, target, index) {\n        let name = path[index++];\n        if (name === \"__proto__\") return true;\n        const isNumericKey = Number.isFinite(+name);\n        const isLast = index >= path.length;\n        name = !name && utils$1.isArray(target) ? target.length : name;\n        if (isLast) {\n            if (utils$1.hasOwnProp(target, name)) {\n                target[name] = [\n                    target[name],\n                    value\n                ];\n            } else {\n                target[name] = value;\n            }\n            return !isNumericKey;\n        }\n        if (!target[name] || !utils$1.isObject(target[name])) {\n            target[name] = [];\n        }\n        const result = buildPath(path, value, target[name], index);\n        if (result && utils$1.isArray(target[name])) {\n            target[name] = arrayToObject(target[name]);\n        }\n        return !isNumericKey;\n    }\n    if (utils$1.isFormData(formData) && utils$1.isFunction(formData.entries)) {\n        const obj = {};\n        utils$1.forEachEntry(formData, (name, value)=>{\n            buildPath(parsePropPath(name), value, obj, 0);\n        });\n        return obj;\n    }\n    return null;\n}\n/**\n * It takes a string, tries to parse it, and if it fails, it returns the stringified version\n * of the input\n *\n * @param {any} rawValue - The value to be stringified.\n * @param {Function} parser - A function that parses a string into a JavaScript object.\n * @param {Function} encoder - A function that takes a value and returns a string.\n *\n * @returns {string} A stringified version of the rawValue.\n */ function stringifySafely(rawValue, parser, encoder) {\n    if (utils$1.isString(rawValue)) {\n        try {\n            (parser || JSON.parse)(rawValue);\n            return utils$1.trim(rawValue);\n        } catch (e) {\n            if (e.name !== \"SyntaxError\") {\n                throw e;\n            }\n        }\n    }\n    return (encoder || JSON.stringify)(rawValue);\n}\nconst defaults = {\n    transitional: transitionalDefaults,\n    adapter: [\n        \"xhr\",\n        \"http\",\n        \"fetch\"\n    ],\n    transformRequest: [\n        function transformRequest(data, headers) {\n            const contentType = headers.getContentType() || \"\";\n            const hasJSONContentType = contentType.indexOf(\"application/json\") > -1;\n            const isObjectPayload = utils$1.isObject(data);\n            if (isObjectPayload && utils$1.isHTMLForm(data)) {\n                data = new FormData(data);\n            }\n            const isFormData = utils$1.isFormData(data);\n            if (isFormData) {\n                return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;\n            }\n            if (utils$1.isArrayBuffer(data) || utils$1.isBuffer(data) || utils$1.isStream(data) || utils$1.isFile(data) || utils$1.isBlob(data) || utils$1.isReadableStream(data)) {\n                return data;\n            }\n            if (utils$1.isArrayBufferView(data)) {\n                return data.buffer;\n            }\n            if (utils$1.isURLSearchParams(data)) {\n                headers.setContentType(\"application/x-www-form-urlencoded;charset=utf-8\", false);\n                return data.toString();\n            }\n            let isFileList;\n            if (isObjectPayload) {\n                if (contentType.indexOf(\"application/x-www-form-urlencoded\") > -1) {\n                    return toURLEncodedForm(data, this.formSerializer).toString();\n                }\n                if ((isFileList = utils$1.isFileList(data)) || contentType.indexOf(\"multipart/form-data\") > -1) {\n                    const _FormData = this.env && this.env.FormData;\n                    return toFormData(isFileList ? {\n                        \"files[]\": data\n                    } : data, _FormData && new _FormData(), this.formSerializer);\n                }\n            }\n            if (isObjectPayload || hasJSONContentType) {\n                headers.setContentType(\"application/json\", false);\n                return stringifySafely(data);\n            }\n            return data;\n        }\n    ],\n    transformResponse: [\n        function transformResponse(data) {\n            const transitional = this.transitional || defaults.transitional;\n            const forcedJSONParsing = transitional && transitional.forcedJSONParsing;\n            const JSONRequested = this.responseType === \"json\";\n            if (utils$1.isResponse(data) || utils$1.isReadableStream(data)) {\n                return data;\n            }\n            if (data && utils$1.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {\n                const silentJSONParsing = transitional && transitional.silentJSONParsing;\n                const strictJSONParsing = !silentJSONParsing && JSONRequested;\n                try {\n                    return JSON.parse(data, this.parseReviver);\n                } catch (e) {\n                    if (strictJSONParsing) {\n                        if (e.name === \"SyntaxError\") {\n                            throw AxiosError$1.from(e, AxiosError$1.ERR_BAD_RESPONSE, this, null, this.response);\n                        }\n                        throw e;\n                    }\n                }\n            }\n            return data;\n        }\n    ],\n    /**\n   * A timeout in milliseconds to abort a request. If set to 0 (default) a\n   * timeout is not created.\n   */ timeout: 0,\n    xsrfCookieName: \"XSRF-TOKEN\",\n    xsrfHeaderName: \"X-XSRF-TOKEN\",\n    maxContentLength: -1,\n    maxBodyLength: -1,\n    env: {\n        FormData: platform.classes.FormData,\n        Blob: platform.classes.Blob\n    },\n    validateStatus: function validateStatus(status) {\n        return status >= 200 && status < 300;\n    },\n    headers: {\n        common: {\n            \"Accept\": \"application/json, text/plain, */*\",\n            \"Content-Type\": undefined\n        }\n    }\n};\nutils$1.forEach([\n    \"delete\",\n    \"get\",\n    \"head\",\n    \"post\",\n    \"put\",\n    \"patch\"\n], (method)=>{\n    defaults.headers[method] = {};\n});\nconst defaults$1 = defaults;\n// RawAxiosHeaders whose duplicates are ignored by node\n// c.f. https://nodejs.org/api/http.html#http_message_headers\nconst ignoreDuplicateOf = utils$1.toObjectSet([\n    \"age\",\n    \"authorization\",\n    \"content-length\",\n    \"content-type\",\n    \"etag\",\n    \"expires\",\n    \"from\",\n    \"host\",\n    \"if-modified-since\",\n    \"if-unmodified-since\",\n    \"last-modified\",\n    \"location\",\n    \"max-forwards\",\n    \"proxy-authorization\",\n    \"referer\",\n    \"retry-after\",\n    \"user-agent\"\n]);\n/**\n * Parse headers into an object\n *\n * ```\n * Date: Wed, 27 Aug 2014 08:58:49 GMT\n * Content-Type: application/json\n * Connection: keep-alive\n * Transfer-Encoding: chunked\n * ```\n *\n * @param {String} rawHeaders Headers needing to be parsed\n *\n * @returns {Object} Headers parsed into an object\n */ const parseHeaders = (rawHeaders)=>{\n    const parsed = {};\n    let key;\n    let val;\n    let i;\n    rawHeaders && rawHeaders.split(\"\\n\").forEach(function parser(line) {\n        i = line.indexOf(\":\");\n        key = line.substring(0, i).trim().toLowerCase();\n        val = line.substring(i + 1).trim();\n        if (!key || parsed[key] && ignoreDuplicateOf[key]) {\n            return;\n        }\n        if (key === \"set-cookie\") {\n            if (parsed[key]) {\n                parsed[key].push(val);\n            } else {\n                parsed[key] = [\n                    val\n                ];\n            }\n        } else {\n            parsed[key] = parsed[key] ? parsed[key] + \", \" + val : val;\n        }\n    });\n    return parsed;\n};\nconst $internals = Symbol(\"internals\");\nfunction normalizeHeader(header) {\n    return header && String(header).trim().toLowerCase();\n}\nfunction normalizeValue(value) {\n    if (value === false || value == null) {\n        return value;\n    }\n    return utils$1.isArray(value) ? value.map(normalizeValue) : String(value);\n}\nfunction parseTokens(str) {\n    const tokens = Object.create(null);\n    const tokensRE = /([^\\s,;=]+)\\s*(?:=\\s*([^,;]+))?/g;\n    let match;\n    while(match = tokensRE.exec(str)){\n        tokens[match[1]] = match[2];\n    }\n    return tokens;\n}\nconst isValidHeaderName = (str)=>/^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());\nfunction matchHeaderValue(context, value, header, filter, isHeaderNameFilter) {\n    if (utils$1.isFunction(filter)) {\n        return filter.call(this, value, header);\n    }\n    if (isHeaderNameFilter) {\n        value = header;\n    }\n    if (!utils$1.isString(value)) return;\n    if (utils$1.isString(filter)) {\n        return value.indexOf(filter) !== -1;\n    }\n    if (utils$1.isRegExp(filter)) {\n        return filter.test(value);\n    }\n}\nfunction formatHeader(header) {\n    return header.trim().toLowerCase().replace(/([a-z\\d])(\\w*)/g, (w, char, str)=>{\n        return char.toUpperCase() + str;\n    });\n}\nfunction buildAccessors(obj, header) {\n    const accessorName = utils$1.toCamelCase(\" \" + header);\n    [\n        \"get\",\n        \"set\",\n        \"has\"\n    ].forEach((methodName)=>{\n        Object.defineProperty(obj, methodName + accessorName, {\n            value: function(arg1, arg2, arg3) {\n                return this[methodName].call(this, header, arg1, arg2, arg3);\n            },\n            configurable: true\n        });\n    });\n}\nclass AxiosHeaders {\n    constructor(headers){\n        headers && this.set(headers);\n    }\n    set(header, valueOrRewrite, rewrite) {\n        const self1 = this;\n        function setHeader(_value, _header, _rewrite) {\n            const lHeader = normalizeHeader(_header);\n            if (!lHeader) {\n                throw new Error(\"header name must be a non-empty string\");\n            }\n            const key = utils$1.findKey(self1, lHeader);\n            if (!key || self1[key] === undefined || _rewrite === true || _rewrite === undefined && self1[key] !== false) {\n                self1[key || _header] = normalizeValue(_value);\n            }\n        }\n        const setHeaders = (headers, _rewrite)=>utils$1.forEach(headers, (_value, _header)=>setHeader(_value, _header, _rewrite));\n        if (utils$1.isPlainObject(header) || header instanceof this.constructor) {\n            setHeaders(header, valueOrRewrite);\n        } else if (utils$1.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {\n            setHeaders(parseHeaders(header), valueOrRewrite);\n        } else if (utils$1.isObject(header) && utils$1.isIterable(header)) {\n            let obj = {}, dest, key;\n            for (const entry of header){\n                if (!utils$1.isArray(entry)) {\n                    throw TypeError(\"Object iterator must return a key-value pair\");\n                }\n                obj[key = entry[0]] = (dest = obj[key]) ? utils$1.isArray(dest) ? [\n                    ...dest,\n                    entry[1]\n                ] : [\n                    dest,\n                    entry[1]\n                ] : entry[1];\n            }\n            setHeaders(obj, valueOrRewrite);\n        } else {\n            header != null && setHeader(valueOrRewrite, header, rewrite);\n        }\n        return this;\n    }\n    get(header, parser) {\n        header = normalizeHeader(header);\n        if (header) {\n            const key = utils$1.findKey(this, header);\n            if (key) {\n                const value = this[key];\n                if (!parser) {\n                    return value;\n                }\n                if (parser === true) {\n                    return parseTokens(value);\n                }\n                if (utils$1.isFunction(parser)) {\n                    return parser.call(this, value, key);\n                }\n                if (utils$1.isRegExp(parser)) {\n                    return parser.exec(value);\n                }\n                throw new TypeError(\"parser must be boolean|regexp|function\");\n            }\n        }\n    }\n    has(header, matcher) {\n        header = normalizeHeader(header);\n        if (header) {\n            const key = utils$1.findKey(this, header);\n            return !!(key && this[key] !== undefined && (!matcher || matchHeaderValue(this, this[key], key, matcher)));\n        }\n        return false;\n    }\n    delete(header, matcher) {\n        const self1 = this;\n        let deleted = false;\n        function deleteHeader(_header) {\n            _header = normalizeHeader(_header);\n            if (_header) {\n                const key = utils$1.findKey(self1, _header);\n                if (key && (!matcher || matchHeaderValue(self1, self1[key], key, matcher))) {\n                    delete self1[key];\n                    deleted = true;\n                }\n            }\n        }\n        if (utils$1.isArray(header)) {\n            header.forEach(deleteHeader);\n        } else {\n            deleteHeader(header);\n        }\n        return deleted;\n    }\n    clear(matcher) {\n        const keys = Object.keys(this);\n        let i = keys.length;\n        let deleted = false;\n        while(i--){\n            const key = keys[i];\n            if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {\n                delete this[key];\n                deleted = true;\n            }\n        }\n        return deleted;\n    }\n    normalize(format) {\n        const self1 = this;\n        const headers = {};\n        utils$1.forEach(this, (value, header)=>{\n            const key = utils$1.findKey(headers, header);\n            if (key) {\n                self1[key] = normalizeValue(value);\n                delete self1[header];\n                return;\n            }\n            const normalized = format ? formatHeader(header) : String(header).trim();\n            if (normalized !== header) {\n                delete self1[header];\n            }\n            self1[normalized] = normalizeValue(value);\n            headers[normalized] = true;\n        });\n        return this;\n    }\n    concat(...targets) {\n        return this.constructor.concat(this, ...targets);\n    }\n    toJSON(asStrings) {\n        const obj = Object.create(null);\n        utils$1.forEach(this, (value, header)=>{\n            value != null && value !== false && (obj[header] = asStrings && utils$1.isArray(value) ? value.join(\", \") : value);\n        });\n        return obj;\n    }\n    [Symbol.iterator]() {\n        return Object.entries(this.toJSON())[Symbol.iterator]();\n    }\n    toString() {\n        return Object.entries(this.toJSON()).map(([header, value])=>header + \": \" + value).join(\"\\n\");\n    }\n    getSetCookie() {\n        return this.get(\"set-cookie\") || [];\n    }\n    get [Symbol.toStringTag]() {\n        return \"AxiosHeaders\";\n    }\n    static from(thing) {\n        return thing instanceof this ? thing : new this(thing);\n    }\n    static concat(first, ...targets) {\n        const computed = new this(first);\n        targets.forEach((target)=>computed.set(target));\n        return computed;\n    }\n    static accessor(header) {\n        const internals = this[$internals] = this[$internals] = {\n            accessors: {}\n        };\n        const accessors = internals.accessors;\n        const prototype = this.prototype;\n        function defineAccessor(_header) {\n            const lHeader = normalizeHeader(_header);\n            if (!accessors[lHeader]) {\n                buildAccessors(prototype, _header);\n                accessors[lHeader] = true;\n            }\n        }\n        utils$1.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);\n        return this;\n    }\n}\nAxiosHeaders.accessor([\n    \"Content-Type\",\n    \"Content-Length\",\n    \"Accept\",\n    \"Accept-Encoding\",\n    \"User-Agent\",\n    \"Authorization\"\n]);\n// reserved names hotfix\nutils$1.reduceDescriptors(AxiosHeaders.prototype, ({ value }, key)=>{\n    let mapped = key[0].toUpperCase() + key.slice(1); // map `set` => `Set`\n    return {\n        get: ()=>value,\n        set (headerValue) {\n            this[mapped] = headerValue;\n        }\n    };\n});\nutils$1.freezeMethods(AxiosHeaders);\nconst AxiosHeaders$1 = AxiosHeaders;\n/**\n * Transform the data for a request or a response\n *\n * @param {Array|Function} fns A single function or Array of functions\n * @param {?Object} response The response object\n *\n * @returns {*} The resulting transformed data\n */ function transformData(fns, response) {\n    const config = this || defaults$1;\n    const context = response || config;\n    const headers = AxiosHeaders$1.from(context.headers);\n    let data = context.data;\n    utils$1.forEach(fns, function transform(fn) {\n        data = fn.call(config, data, headers.normalize(), response ? response.status : undefined);\n    });\n    headers.normalize();\n    return data;\n}\nfunction isCancel(value) {\n    return !!(value && value.__CANCEL__);\n}\nclass CanceledError extends AxiosError$1 {\n    /**\n   * A `CanceledError` is an object that is thrown when an operation is canceled.\n   *\n   * @param {string=} message The message.\n   * @param {Object=} config The config.\n   * @param {Object=} request The request.\n   *\n   * @returns {CanceledError} The created error.\n   */ constructor(message, config, request){\n        super(message == null ? \"canceled\" : message, AxiosError$1.ERR_CANCELED, config, request);\n        this.name = \"CanceledError\";\n        this.__CANCEL__ = true;\n    }\n}\nconst CanceledError$1 = CanceledError;\n/**\n * Resolve or reject a Promise based on response status.\n *\n * @param {Function} resolve A function that resolves the promise.\n * @param {Function} reject A function that rejects the promise.\n * @param {object} response The response.\n *\n * @returns {object} The response.\n */ function settle(resolve, reject, response) {\n    const validateStatus = response.config.validateStatus;\n    if (!response.status || !validateStatus || validateStatus(response.status)) {\n        resolve(response);\n    } else {\n        reject(new AxiosError$1(\"Request failed with status code \" + response.status, [\n            AxiosError$1.ERR_BAD_REQUEST,\n            AxiosError$1.ERR_BAD_RESPONSE\n        ][Math.floor(response.status / 100) - 4], response.config, response.request, response));\n    }\n}\n/**\n * Determines whether the specified URL is absolute\n *\n * @param {string} url The URL to test\n *\n * @returns {boolean} True if the specified URL is absolute, otherwise false\n */ function isAbsoluteURL(url) {\n    // A URL is considered absolute if it begins with \"<scheme>://\" or \"//\" (protocol-relative URL).\n    // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed\n    // by any combination of letters, digits, plus, period, or hyphen.\n    return /^([a-z][a-z\\d+\\-.]*:)?\\/\\//i.test(url);\n}\n/**\n * Creates a new URL by combining the specified URLs\n *\n * @param {string} baseURL The base URL\n * @param {string} relativeURL The relative URL\n *\n * @returns {string} The combined URL\n */ function combineURLs(baseURL, relativeURL) {\n    return relativeURL ? baseURL.replace(/\\/?\\/$/, \"\") + \"/\" + relativeURL.replace(/^\\/+/, \"\") : baseURL;\n}\n/**\n * Creates a new URL by combining the baseURL with the requestedURL,\n * only when the requestedURL is not already an absolute URL.\n * If the requestURL is absolute, this function returns the requestedURL untouched.\n *\n * @param {string} baseURL The base URL\n * @param {string} requestedURL Absolute or relative URL to combine\n *\n * @returns {string} The combined full path\n */ function buildFullPath(baseURL, requestedURL, allowAbsoluteUrls) {\n    let isRelativeUrl = !isAbsoluteURL(requestedURL);\n    if (baseURL && (isRelativeUrl || allowAbsoluteUrls == false)) {\n        return combineURLs(baseURL, requestedURL);\n    }\n    return requestedURL;\n}\nconst VERSION = \"1.13.4\";\nfunction parseProtocol(url) {\n    const match = /^([-+\\w]{1,25})(:?\\/\\/|:)/.exec(url);\n    return match && match[1] || \"\";\n}\nconst DATA_URL_PATTERN = /^(?:([^;]+);)?(?:[^;]+;)?(base64|),([\\s\\S]*)$/;\n/**\n * Parse data uri to a Buffer or Blob\n *\n * @param {String} uri\n * @param {?Boolean} asBlob\n * @param {?Object} options\n * @param {?Function} options.Blob\n *\n * @returns {Buffer|Blob}\n */ function fromDataURI(uri, asBlob, options) {\n    const _Blob = options && options.Blob || platform.classes.Blob;\n    const protocol = parseProtocol(uri);\n    if (asBlob === undefined && _Blob) {\n        asBlob = true;\n    }\n    if (protocol === \"data\") {\n        uri = protocol.length ? uri.slice(protocol.length + 1) : uri;\n        const match = DATA_URL_PATTERN.exec(uri);\n        if (!match) {\n            throw new AxiosError$1(\"Invalid URL\", AxiosError$1.ERR_INVALID_URL);\n        }\n        const mime = match[1];\n        const isBase64 = match[2];\n        const body = match[3];\n        const buffer = Buffer.from(decodeURIComponent(body), isBase64 ? \"base64\" : \"utf8\");\n        if (asBlob) {\n            if (!_Blob) {\n                throw new AxiosError$1(\"Blob is not supported\", AxiosError$1.ERR_NOT_SUPPORT);\n            }\n            return new _Blob([\n                buffer\n            ], {\n                type: mime\n            });\n        }\n        return buffer;\n    }\n    throw new AxiosError$1(\"Unsupported protocol \" + protocol, AxiosError$1.ERR_NOT_SUPPORT);\n}\nconst kInternals = Symbol(\"internals\");\nclass AxiosTransformStream extends stream__default[\"default\"].Transform {\n    constructor(options){\n        options = utils$1.toFlatObject(options, {\n            maxRate: 0,\n            chunkSize: 64 * 1024,\n            minChunkSize: 100,\n            timeWindow: 500,\n            ticksRate: 2,\n            samplesCount: 15\n        }, null, (prop, source)=>{\n            return !utils$1.isUndefined(source[prop]);\n        });\n        super({\n            readableHighWaterMark: options.chunkSize\n        });\n        const internals = this[kInternals] = {\n            timeWindow: options.timeWindow,\n            chunkSize: options.chunkSize,\n            maxRate: options.maxRate,\n            minChunkSize: options.minChunkSize,\n            bytesSeen: 0,\n            isCaptured: false,\n            notifiedBytesLoaded: 0,\n            ts: Date.now(),\n            bytes: 0,\n            onReadCallback: null\n        };\n        this.on(\"newListener\", (event)=>{\n            if (event === \"progress\") {\n                if (!internals.isCaptured) {\n                    internals.isCaptured = true;\n                }\n            }\n        });\n    }\n    _read(size) {\n        const internals = this[kInternals];\n        if (internals.onReadCallback) {\n            internals.onReadCallback();\n        }\n        return super._read(size);\n    }\n    _transform(chunk, encoding, callback) {\n        const internals = this[kInternals];\n        const maxRate = internals.maxRate;\n        const readableHighWaterMark = this.readableHighWaterMark;\n        const timeWindow = internals.timeWindow;\n        const divider = 1000 / timeWindow;\n        const bytesThreshold = maxRate / divider;\n        const minChunkSize = internals.minChunkSize !== false ? Math.max(internals.minChunkSize, bytesThreshold * 0.01) : 0;\n        const pushChunk = (_chunk, _callback)=>{\n            const bytes = Buffer.byteLength(_chunk);\n            internals.bytesSeen += bytes;\n            internals.bytes += bytes;\n            internals.isCaptured && this.emit(\"progress\", internals.bytesSeen);\n            if (this.push(_chunk)) {\n                process.nextTick(_callback);\n            } else {\n                internals.onReadCallback = ()=>{\n                    internals.onReadCallback = null;\n                    process.nextTick(_callback);\n                };\n            }\n        };\n        const transformChunk = (_chunk, _callback)=>{\n            const chunkSize = Buffer.byteLength(_chunk);\n            let chunkRemainder = null;\n            let maxChunkSize = readableHighWaterMark;\n            let bytesLeft;\n            let passed = 0;\n            if (maxRate) {\n                const now = Date.now();\n                if (!internals.ts || (passed = now - internals.ts) >= timeWindow) {\n                    internals.ts = now;\n                    bytesLeft = bytesThreshold - internals.bytes;\n                    internals.bytes = bytesLeft < 0 ? -bytesLeft : 0;\n                    passed = 0;\n                }\n                bytesLeft = bytesThreshold - internals.bytes;\n            }\n            if (maxRate) {\n                if (bytesLeft <= 0) {\n                    // next time window\n                    return setTimeout(()=>{\n                        _callback(null, _chunk);\n                    }, timeWindow - passed);\n                }\n                if (bytesLeft < maxChunkSize) {\n                    maxChunkSize = bytesLeft;\n                }\n            }\n            if (maxChunkSize && chunkSize > maxChunkSize && chunkSize - maxChunkSize > minChunkSize) {\n                chunkRemainder = _chunk.subarray(maxChunkSize);\n                _chunk = _chunk.subarray(0, maxChunkSize);\n            }\n            pushChunk(_chunk, chunkRemainder ? ()=>{\n                process.nextTick(_callback, null, chunkRemainder);\n            } : _callback);\n        };\n        transformChunk(chunk, function transformNextChunk(err, _chunk) {\n            if (err) {\n                return callback(err);\n            }\n            if (_chunk) {\n                transformChunk(_chunk, transformNextChunk);\n            } else {\n                callback(null);\n            }\n        });\n    }\n}\nconst AxiosTransformStream$1 = AxiosTransformStream;\nconst { asyncIterator } = Symbol;\nconst readBlob = async function*(blob) {\n    if (blob.stream) {\n        yield* blob.stream();\n    } else if (blob.arrayBuffer) {\n        yield await blob.arrayBuffer();\n    } else if (blob[asyncIterator]) {\n        yield* blob[asyncIterator]();\n    } else {\n        yield blob;\n    }\n};\nconst readBlob$1 = readBlob;\nconst BOUNDARY_ALPHABET = platform.ALPHABET.ALPHA_DIGIT + \"-_\";\nconst textEncoder = typeof TextEncoder === \"function\" ? new TextEncoder() : new util__default[\"default\"].TextEncoder();\nconst CRLF = \"\\r\\n\";\nconst CRLF_BYTES = textEncoder.encode(CRLF);\nconst CRLF_BYTES_COUNT = 2;\nclass FormDataPart {\n    constructor(name, value){\n        const { escapeName } = this.constructor;\n        const isStringValue = utils$1.isString(value);\n        let headers = `Content-Disposition: form-data; name=\"${escapeName(name)}\"${!isStringValue && value.name ? `; filename=\"${escapeName(value.name)}\"` : \"\"}${CRLF}`;\n        if (isStringValue) {\n            value = textEncoder.encode(String(value).replace(/\\r?\\n|\\r\\n?/g, CRLF));\n        } else {\n            headers += `Content-Type: ${value.type || \"application/octet-stream\"}${CRLF}`;\n        }\n        this.headers = textEncoder.encode(headers + CRLF);\n        this.contentLength = isStringValue ? value.byteLength : value.size;\n        this.size = this.headers.byteLength + this.contentLength + CRLF_BYTES_COUNT;\n        this.name = name;\n        this.value = value;\n    }\n    async *encode() {\n        yield this.headers;\n        const { value } = this;\n        if (utils$1.isTypedArray(value)) {\n            yield value;\n        } else {\n            yield* readBlob$1(value);\n        }\n        yield CRLF_BYTES;\n    }\n    static escapeName(name) {\n        return String(name).replace(/[\\r\\n\"]/g, (match)=>({\n                \"\\r\": \"%0D\",\n                \"\\n\": \"%0A\",\n                '\"': \"%22\"\n            })[match]);\n    }\n}\nconst formDataToStream = (form, headersHandler, options)=>{\n    const { tag = \"form-data-boundary\", size = 25, boundary = tag + \"-\" + platform.generateString(size, BOUNDARY_ALPHABET) } = options || {};\n    if (!utils$1.isFormData(form)) {\n        throw TypeError(\"FormData instance required\");\n    }\n    if (boundary.length < 1 || boundary.length > 70) {\n        throw Error(\"boundary must be 10-70 characters long\");\n    }\n    const boundaryBytes = textEncoder.encode(\"--\" + boundary + CRLF);\n    const footerBytes = textEncoder.encode(\"--\" + boundary + \"--\" + CRLF);\n    let contentLength = footerBytes.byteLength;\n    const parts = Array.from(form.entries()).map(([name, value])=>{\n        const part = new FormDataPart(name, value);\n        contentLength += part.size;\n        return part;\n    });\n    contentLength += boundaryBytes.byteLength * parts.length;\n    contentLength = utils$1.toFiniteNumber(contentLength);\n    const computedHeaders = {\n        \"Content-Type\": `multipart/form-data; boundary=${boundary}`\n    };\n    if (Number.isFinite(contentLength)) {\n        computedHeaders[\"Content-Length\"] = contentLength;\n    }\n    headersHandler && headersHandler(computedHeaders);\n    return stream.Readable.from(async function*() {\n        for (const part of parts){\n            yield boundaryBytes;\n            yield* part.encode();\n        }\n        yield footerBytes;\n    }());\n};\nconst formDataToStream$1 = formDataToStream;\nclass ZlibHeaderTransformStream extends stream__default[\"default\"].Transform {\n    __transform(chunk, encoding, callback) {\n        this.push(chunk);\n        callback();\n    }\n    _transform(chunk, encoding, callback) {\n        if (chunk.length !== 0) {\n            this._transform = this.__transform;\n            // Add Default Compression headers if no zlib headers are present\n            if (chunk[0] !== 120) {\n                const header = Buffer.alloc(2);\n                header[0] = 120; // Hex: 78\n                header[1] = 156; // Hex: 9C \n                this.push(header, encoding);\n            }\n        }\n        this.__transform(chunk, encoding, callback);\n    }\n}\nconst ZlibHeaderTransformStream$1 = ZlibHeaderTransformStream;\nconst callbackify = (fn, reducer)=>{\n    return utils$1.isAsyncFn(fn) ? function(...args) {\n        const cb = args.pop();\n        fn.apply(this, args).then((value)=>{\n            try {\n                reducer ? cb(null, ...reducer(value)) : cb(null, value);\n            } catch (err) {\n                cb(err);\n            }\n        }, cb);\n    } : fn;\n};\nconst callbackify$1 = callbackify;\n/**\n * Calculate data maxRate\n * @param {Number} [samplesCount= 10]\n * @param {Number} [min= 1000]\n * @returns {Function}\n */ function speedometer(samplesCount, min) {\n    samplesCount = samplesCount || 10;\n    const bytes = new Array(samplesCount);\n    const timestamps = new Array(samplesCount);\n    let head = 0;\n    let tail = 0;\n    let firstSampleTS;\n    min = min !== undefined ? min : 1000;\n    return function push(chunkLength) {\n        const now = Date.now();\n        const startedAt = timestamps[tail];\n        if (!firstSampleTS) {\n            firstSampleTS = now;\n        }\n        bytes[head] = chunkLength;\n        timestamps[head] = now;\n        let i = tail;\n        let bytesCount = 0;\n        while(i !== head){\n            bytesCount += bytes[i++];\n            i = i % samplesCount;\n        }\n        head = (head + 1) % samplesCount;\n        if (head === tail) {\n            tail = (tail + 1) % samplesCount;\n        }\n        if (now - firstSampleTS < min) {\n            return;\n        }\n        const passed = startedAt && now - startedAt;\n        return passed ? Math.round(bytesCount * 1000 / passed) : undefined;\n    };\n}\n/**\n * Throttle decorator\n * @param {Function} fn\n * @param {Number} freq\n * @return {Function}\n */ function throttle(fn, freq) {\n    let timestamp = 0;\n    let threshold = 1000 / freq;\n    let lastArgs;\n    let timer;\n    const invoke = (args, now = Date.now())=>{\n        timestamp = now;\n        lastArgs = null;\n        if (timer) {\n            clearTimeout(timer);\n            timer = null;\n        }\n        fn(...args);\n    };\n    const throttled = (...args)=>{\n        const now = Date.now();\n        const passed = now - timestamp;\n        if (passed >= threshold) {\n            invoke(args, now);\n        } else {\n            lastArgs = args;\n            if (!timer) {\n                timer = setTimeout(()=>{\n                    timer = null;\n                    invoke(lastArgs);\n                }, threshold - passed);\n            }\n        }\n    };\n    const flush = ()=>lastArgs && invoke(lastArgs);\n    return [\n        throttled,\n        flush\n    ];\n}\nconst progressEventReducer = (listener, isDownloadStream, freq = 3)=>{\n    let bytesNotified = 0;\n    const _speedometer = speedometer(50, 250);\n    return throttle((e)=>{\n        const loaded = e.loaded;\n        const total = e.lengthComputable ? e.total : undefined;\n        const progressBytes = loaded - bytesNotified;\n        const rate = _speedometer(progressBytes);\n        const inRange = loaded <= total;\n        bytesNotified = loaded;\n        const data = {\n            loaded,\n            total,\n            progress: total ? loaded / total : undefined,\n            bytes: progressBytes,\n            rate: rate ? rate : undefined,\n            estimated: rate && total && inRange ? (total - loaded) / rate : undefined,\n            event: e,\n            lengthComputable: total != null,\n            [isDownloadStream ? \"download\" : \"upload\"]: true\n        };\n        listener(data);\n    }, freq);\n};\nconst progressEventDecorator = (total, throttled)=>{\n    const lengthComputable = total != null;\n    return [\n        (loaded)=>throttled[0]({\n                lengthComputable,\n                total,\n                loaded\n            }),\n        throttled[1]\n    ];\n};\nconst asyncDecorator = (fn)=>(...args)=>utils$1.asap(()=>fn(...args));\n/**\n * Estimate decoded byte length of a data:// URL *without* allocating large buffers.\n * - For base64: compute exact decoded size using length and padding;\n *               handle %XX at the character-count level (no string allocation).\n * - For non-base64: use UTF-8 byteLength of the encoded body as a safe upper bound.\n *\n * @param {string} url\n * @returns {number}\n */ function estimateDataURLDecodedBytes(url) {\n    if (!url || typeof url !== \"string\") return 0;\n    if (!url.startsWith(\"data:\")) return 0;\n    const comma = url.indexOf(\",\");\n    if (comma < 0) return 0;\n    const meta = url.slice(5, comma);\n    const body = url.slice(comma + 1);\n    const isBase64 = /;base64/i.test(meta);\n    if (isBase64) {\n        let effectiveLen = body.length;\n        const len = body.length; // cache length\n        for(let i = 0; i < len; i++){\n            if (body.charCodeAt(i) === 37 /* '%' */  && i + 2 < len) {\n                const a = body.charCodeAt(i + 1);\n                const b = body.charCodeAt(i + 2);\n                const isHex = (a >= 48 && a <= 57 || a >= 65 && a <= 70 || a >= 97 && a <= 102) && (b >= 48 && b <= 57 || b >= 65 && b <= 70 || b >= 97 && b <= 102);\n                if (isHex) {\n                    effectiveLen -= 2;\n                    i += 2;\n                }\n            }\n        }\n        let pad = 0;\n        let idx = len - 1;\n        const tailIsPct3D = (j)=>j >= 2 && body.charCodeAt(j - 2) === 37 && // '%'\n            body.charCodeAt(j - 1) === 51 && // '3'\n            (body.charCodeAt(j) === 68 || body.charCodeAt(j) === 100); // 'D' or 'd'\n        if (idx >= 0) {\n            if (body.charCodeAt(idx) === 61 /* '=' */ ) {\n                pad++;\n                idx--;\n            } else if (tailIsPct3D(idx)) {\n                pad++;\n                idx -= 3;\n            }\n        }\n        if (pad === 1 && idx >= 0) {\n            if (body.charCodeAt(idx) === 61 /* '=' */ ) {\n                pad++;\n            } else if (tailIsPct3D(idx)) {\n                pad++;\n            }\n        }\n        const groups = Math.floor(effectiveLen / 4);\n        const bytes = groups * 3 - (pad || 0);\n        return bytes > 0 ? bytes : 0;\n    }\n    return Buffer.byteLength(body, \"utf8\");\n}\nconst zlibOptions = {\n    flush: zlib__default[\"default\"].constants.Z_SYNC_FLUSH,\n    finishFlush: zlib__default[\"default\"].constants.Z_SYNC_FLUSH\n};\nconst brotliOptions = {\n    flush: zlib__default[\"default\"].constants.BROTLI_OPERATION_FLUSH,\n    finishFlush: zlib__default[\"default\"].constants.BROTLI_OPERATION_FLUSH\n};\nconst isBrotliSupported = utils$1.isFunction(zlib__default[\"default\"].createBrotliDecompress);\nconst { http: httpFollow, https: httpsFollow } = followRedirects__default[\"default\"];\nconst isHttps = /https:?/;\nconst supportedProtocols = platform.protocols.map((protocol)=>{\n    return protocol + \":\";\n});\nconst flushOnFinish = (stream, [throttled, flush])=>{\n    stream.on(\"end\", flush).on(\"error\", flush);\n    return throttled;\n};\nclass Http2Sessions {\n    constructor(){\n        this.sessions = Object.create(null);\n    }\n    getSession(authority, options) {\n        options = Object.assign({\n            sessionTimeout: 1000\n        }, options);\n        let authoritySessions = this.sessions[authority];\n        if (authoritySessions) {\n            let len = authoritySessions.length;\n            for(let i = 0; i < len; i++){\n                const [sessionHandle, sessionOptions] = authoritySessions[i];\n                if (!sessionHandle.destroyed && !sessionHandle.closed && util__default[\"default\"].isDeepStrictEqual(sessionOptions, options)) {\n                    return sessionHandle;\n                }\n            }\n        }\n        const session = http2__default[\"default\"].connect(authority, options);\n        let removed;\n        const removeSession = ()=>{\n            if (removed) {\n                return;\n            }\n            removed = true;\n            let entries = authoritySessions, len = entries.length, i = len;\n            while(i--){\n                if (entries[i][0] === session) {\n                    if (len === 1) {\n                        delete this.sessions[authority];\n                    } else {\n                        entries.splice(i, 1);\n                    }\n                    return;\n                }\n            }\n        };\n        const originalRequestFn = session.request;\n        const { sessionTimeout } = options;\n        if (sessionTimeout != null) {\n            let timer;\n            let streamsCount = 0;\n            session.request = function() {\n                const stream = originalRequestFn.apply(this, arguments);\n                streamsCount++;\n                if (timer) {\n                    clearTimeout(timer);\n                    timer = null;\n                }\n                stream.once(\"close\", ()=>{\n                    if (!--streamsCount) {\n                        timer = setTimeout(()=>{\n                            timer = null;\n                            removeSession();\n                        }, sessionTimeout);\n                    }\n                });\n                return stream;\n            };\n        }\n        session.once(\"close\", removeSession);\n        let entry = [\n            session,\n            options\n        ];\n        authoritySessions ? authoritySessions.push(entry) : authoritySessions = this.sessions[authority] = [\n            entry\n        ];\n        return session;\n    }\n}\nconst http2Sessions = new Http2Sessions();\n/**\n * If the proxy or config beforeRedirects functions are defined, call them with the options\n * object.\n *\n * @param {Object<string, any>} options - The options object that was passed to the request.\n *\n * @returns {Object<string, any>}\n */ function dispatchBeforeRedirect(options, responseDetails) {\n    if (options.beforeRedirects.proxy) {\n        options.beforeRedirects.proxy(options);\n    }\n    if (options.beforeRedirects.config) {\n        options.beforeRedirects.config(options, responseDetails);\n    }\n}\n/**\n * If the proxy or config afterRedirects functions are defined, call them with the options\n *\n * @param {http.ClientRequestArgs} options\n * @param {AxiosProxyConfig} configProxy configuration from Axios options object\n * @param {string} location\n *\n * @returns {http.ClientRequestArgs}\n */ function setProxy(options, configProxy, location) {\n    let proxy = configProxy;\n    if (!proxy && proxy !== false) {\n        const proxyUrl = proxyFromEnv__default[\"default\"].getProxyForUrl(location);\n        if (proxyUrl) {\n            proxy = new URL(proxyUrl);\n        }\n    }\n    if (proxy) {\n        // Basic proxy authorization\n        if (proxy.username) {\n            proxy.auth = (proxy.username || \"\") + \":\" + (proxy.password || \"\");\n        }\n        if (proxy.auth) {\n            // Support proxy auth object form\n            const validProxyAuth = Boolean(proxy.auth.username || proxy.auth.password);\n            if (validProxyAuth) {\n                proxy.auth = (proxy.auth.username || \"\") + \":\" + (proxy.auth.password || \"\");\n            } else if (typeof proxy.auth === \"object\") {\n                throw new AxiosError$1(\"Invalid proxy authorization\", AxiosError$1.ERR_BAD_OPTION, {\n                    proxy\n                });\n            }\n            const base64 = Buffer.from(proxy.auth, \"utf8\").toString(\"base64\");\n            options.headers[\"Proxy-Authorization\"] = \"Basic \" + base64;\n        }\n        options.headers.host = options.hostname + (options.port ? \":\" + options.port : \"\");\n        const proxyHost = proxy.hostname || proxy.host;\n        options.hostname = proxyHost;\n        // Replace 'host' since options is not a URL object\n        options.host = proxyHost;\n        options.port = proxy.port;\n        options.path = location;\n        if (proxy.protocol) {\n            options.protocol = proxy.protocol.includes(\":\") ? proxy.protocol : `${proxy.protocol}:`;\n        }\n    }\n    options.beforeRedirects.proxy = function beforeRedirect(redirectOptions) {\n        // Configure proxy for redirected request, passing the original config proxy to apply\n        // the exact same logic as if the redirected request was performed by axios directly.\n        setProxy(redirectOptions, configProxy, redirectOptions.href);\n    };\n}\nconst isHttpAdapterSupported = typeof process !== \"undefined\" && utils$1.kindOf(process) === \"process\";\n// temporary hotfix\nconst wrapAsync = (asyncExecutor)=>{\n    return new Promise((resolve, reject)=>{\n        let onDone;\n        let isDone;\n        const done = (value, isRejected)=>{\n            if (isDone) return;\n            isDone = true;\n            onDone && onDone(value, isRejected);\n        };\n        const _resolve = (value)=>{\n            done(value);\n            resolve(value);\n        };\n        const _reject = (reason)=>{\n            done(reason, true);\n            reject(reason);\n        };\n        asyncExecutor(_resolve, _reject, (onDoneHandler)=>onDone = onDoneHandler).catch(_reject);\n    });\n};\nconst resolveFamily = ({ address, family })=>{\n    if (!utils$1.isString(address)) {\n        throw TypeError(\"address must be a string\");\n    }\n    return {\n        address,\n        family: family || (address.indexOf(\".\") < 0 ? 6 : 4)\n    };\n};\nconst buildAddressEntry = (address, family)=>resolveFamily(utils$1.isObject(address) ? address : {\n        address,\n        family\n    });\nconst http2Transport = {\n    request (options, cb) {\n        const authority = options.protocol + \"//\" + options.hostname + \":\" + (options.port || (options.protocol === \"https:\" ? 443 : 80));\n        const { http2Options, headers } = options;\n        const session = http2Sessions.getSession(authority, http2Options);\n        const { HTTP2_HEADER_SCHEME, HTTP2_HEADER_METHOD, HTTP2_HEADER_PATH, HTTP2_HEADER_STATUS } = http2__default[\"default\"].constants;\n        const http2Headers = {\n            [HTTP2_HEADER_SCHEME]: options.protocol.replace(\":\", \"\"),\n            [HTTP2_HEADER_METHOD]: options.method,\n            [HTTP2_HEADER_PATH]: options.path\n        };\n        utils$1.forEach(headers, (header, name)=>{\n            name.charAt(0) !== \":\" && (http2Headers[name] = header);\n        });\n        const req = session.request(http2Headers);\n        req.once(\"response\", (responseHeaders)=>{\n            const response = req; //duplex\n            responseHeaders = Object.assign({}, responseHeaders);\n            const status = responseHeaders[HTTP2_HEADER_STATUS];\n            delete responseHeaders[HTTP2_HEADER_STATUS];\n            response.headers = responseHeaders;\n            response.statusCode = +status;\n            cb(response);\n        });\n        return req;\n    }\n};\n/*eslint consistent-return:0*/ const httpAdapter = isHttpAdapterSupported && function httpAdapter(config) {\n    return wrapAsync(async function dispatchHttpRequest(resolve, reject, onDone) {\n        let { data, lookup, family, httpVersion = 1, http2Options } = config;\n        const { responseType, responseEncoding } = config;\n        const method = config.method.toUpperCase();\n        let isDone;\n        let rejected = false;\n        let req;\n        httpVersion = +httpVersion;\n        if (Number.isNaN(httpVersion)) {\n            throw TypeError(`Invalid protocol version: '${config.httpVersion}' is not a number`);\n        }\n        if (httpVersion !== 1 && httpVersion !== 2) {\n            throw TypeError(`Unsupported protocol version '${httpVersion}'`);\n        }\n        const isHttp2 = httpVersion === 2;\n        if (lookup) {\n            const _lookup = callbackify$1(lookup, (value)=>utils$1.isArray(value) ? value : [\n                    value\n                ]);\n            // hotfix to support opt.all option which is required for node 20.x\n            lookup = (hostname, opt, cb)=>{\n                _lookup(hostname, opt, (err, arg0, arg1)=>{\n                    if (err) {\n                        return cb(err);\n                    }\n                    const addresses = utils$1.isArray(arg0) ? arg0.map((addr)=>buildAddressEntry(addr)) : [\n                        buildAddressEntry(arg0, arg1)\n                    ];\n                    opt.all ? cb(err, addresses) : cb(err, addresses[0].address, addresses[0].family);\n                });\n            };\n        }\n        const abortEmitter = new events.EventEmitter();\n        function abort(reason) {\n            try {\n                abortEmitter.emit(\"abort\", !reason || reason.type ? new CanceledError$1(null, config, req) : reason);\n            } catch (err) {\n                console.warn(\"emit error\", err);\n            }\n        }\n        abortEmitter.once(\"abort\", reject);\n        const onFinished = ()=>{\n            if (config.cancelToken) {\n                config.cancelToken.unsubscribe(abort);\n            }\n            if (config.signal) {\n                config.signal.removeEventListener(\"abort\", abort);\n            }\n            abortEmitter.removeAllListeners();\n        };\n        if (config.cancelToken || config.signal) {\n            config.cancelToken && config.cancelToken.subscribe(abort);\n            if (config.signal) {\n                config.signal.aborted ? abort() : config.signal.addEventListener(\"abort\", abort);\n            }\n        }\n        onDone((response, isRejected)=>{\n            isDone = true;\n            if (isRejected) {\n                rejected = true;\n                onFinished();\n                return;\n            }\n            const { data } = response;\n            if (data instanceof stream__default[\"default\"].Readable || data instanceof stream__default[\"default\"].Duplex) {\n                const offListeners = stream__default[\"default\"].finished(data, ()=>{\n                    offListeners();\n                    onFinished();\n                });\n            } else {\n                onFinished();\n            }\n        });\n        // Parse url\n        const fullPath = buildFullPath(config.baseURL, config.url, config.allowAbsoluteUrls);\n        const parsed = new URL(fullPath, platform.hasBrowserEnv ? platform.origin : undefined);\n        const protocol = parsed.protocol || supportedProtocols[0];\n        if (protocol === \"data:\") {\n            // Apply the same semantics as HTTP: only enforce if a finite, non-negative cap is set.\n            if (config.maxContentLength > -1) {\n                // Use the exact string passed to fromDataURI (config.url); fall back to fullPath if needed.\n                const dataUrl = String(config.url || fullPath || \"\");\n                const estimated = estimateDataURLDecodedBytes(dataUrl);\n                if (estimated > config.maxContentLength) {\n                    return reject(new AxiosError$1(\"maxContentLength size of \" + config.maxContentLength + \" exceeded\", AxiosError$1.ERR_BAD_RESPONSE, config));\n                }\n            }\n            let convertedData;\n            if (method !== \"GET\") {\n                return settle(resolve, reject, {\n                    status: 405,\n                    statusText: \"method not allowed\",\n                    headers: {},\n                    config\n                });\n            }\n            try {\n                convertedData = fromDataURI(config.url, responseType === \"blob\", {\n                    Blob: config.env && config.env.Blob\n                });\n            } catch (err) {\n                throw AxiosError$1.from(err, AxiosError$1.ERR_BAD_REQUEST, config);\n            }\n            if (responseType === \"text\") {\n                convertedData = convertedData.toString(responseEncoding);\n                if (!responseEncoding || responseEncoding === \"utf8\") {\n                    convertedData = utils$1.stripBOM(convertedData);\n                }\n            } else if (responseType === \"stream\") {\n                convertedData = stream__default[\"default\"].Readable.from(convertedData);\n            }\n            return settle(resolve, reject, {\n                data: convertedData,\n                status: 200,\n                statusText: \"OK\",\n                headers: new AxiosHeaders$1(),\n                config\n            });\n        }\n        if (supportedProtocols.indexOf(protocol) === -1) {\n            return reject(new AxiosError$1(\"Unsupported protocol \" + protocol, AxiosError$1.ERR_BAD_REQUEST, config));\n        }\n        const headers = AxiosHeaders$1.from(config.headers).normalize();\n        // Set User-Agent (required by some servers)\n        // See https://github.com/axios/axios/issues/69\n        // User-Agent is specified; handle case where no UA header is desired\n        // Only set header if it hasn't been set in config\n        headers.set(\"User-Agent\", \"axios/\" + VERSION, false);\n        const { onUploadProgress, onDownloadProgress } = config;\n        const maxRate = config.maxRate;\n        let maxUploadRate = undefined;\n        let maxDownloadRate = undefined;\n        // support for spec compliant FormData objects\n        if (utils$1.isSpecCompliantForm(data)) {\n            const userBoundary = headers.getContentType(/boundary=([-_\\w\\d]{10,70})/i);\n            data = formDataToStream$1(data, (formHeaders)=>{\n                headers.set(formHeaders);\n            }, {\n                tag: `axios-${VERSION}-boundary`,\n                boundary: userBoundary && userBoundary[1] || undefined\n            });\n        // support for https://www.npmjs.com/package/form-data api\n        } else if (utils$1.isFormData(data) && utils$1.isFunction(data.getHeaders)) {\n            headers.set(data.getHeaders());\n            if (!headers.hasContentLength()) {\n                try {\n                    const knownLength = await util__default[\"default\"].promisify(data.getLength).call(data);\n                    Number.isFinite(knownLength) && knownLength >= 0 && headers.setContentLength(knownLength);\n                /*eslint no-empty:0*/ } catch (e) {}\n            }\n        } else if (utils$1.isBlob(data) || utils$1.isFile(data)) {\n            data.size && headers.setContentType(data.type || \"application/octet-stream\");\n            headers.setContentLength(data.size || 0);\n            data = stream__default[\"default\"].Readable.from(readBlob$1(data));\n        } else if (data && !utils$1.isStream(data)) {\n            if (Buffer.isBuffer(data)) ;\n            else if (utils$1.isArrayBuffer(data)) {\n                data = Buffer.from(new Uint8Array(data));\n            } else if (utils$1.isString(data)) {\n                data = Buffer.from(data, \"utf-8\");\n            } else {\n                return reject(new AxiosError$1(\"Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream\", AxiosError$1.ERR_BAD_REQUEST, config));\n            }\n            // Add Content-Length header if data exists\n            headers.setContentLength(data.length, false);\n            if (config.maxBodyLength > -1 && data.length > config.maxBodyLength) {\n                return reject(new AxiosError$1(\"Request body larger than maxBodyLength limit\", AxiosError$1.ERR_BAD_REQUEST, config));\n            }\n        }\n        const contentLength = utils$1.toFiniteNumber(headers.getContentLength());\n        if (utils$1.isArray(maxRate)) {\n            maxUploadRate = maxRate[0];\n            maxDownloadRate = maxRate[1];\n        } else {\n            maxUploadRate = maxDownloadRate = maxRate;\n        }\n        if (data && (onUploadProgress || maxUploadRate)) {\n            if (!utils$1.isStream(data)) {\n                data = stream__default[\"default\"].Readable.from(data, {\n                    objectMode: false\n                });\n            }\n            data = stream__default[\"default\"].pipeline([\n                data,\n                new AxiosTransformStream$1({\n                    maxRate: utils$1.toFiniteNumber(maxUploadRate)\n                })\n            ], utils$1.noop);\n            onUploadProgress && data.on(\"progress\", flushOnFinish(data, progressEventDecorator(contentLength, progressEventReducer(asyncDecorator(onUploadProgress), false, 3))));\n        }\n        // HTTP basic authentication\n        let auth = undefined;\n        if (config.auth) {\n            const username = config.auth.username || \"\";\n            const password = config.auth.password || \"\";\n            auth = username + \":\" + password;\n        }\n        if (!auth && parsed.username) {\n            const urlUsername = parsed.username;\n            const urlPassword = parsed.password;\n            auth = urlUsername + \":\" + urlPassword;\n        }\n        auth && headers.delete(\"authorization\");\n        let path;\n        try {\n            path = buildURL(parsed.pathname + parsed.search, config.params, config.paramsSerializer).replace(/^\\?/, \"\");\n        } catch (err) {\n            const customErr = new Error(err.message);\n            customErr.config = config;\n            customErr.url = config.url;\n            customErr.exists = true;\n            return reject(customErr);\n        }\n        headers.set(\"Accept-Encoding\", \"gzip, compress, deflate\" + (isBrotliSupported ? \", br\" : \"\"), false);\n        const options = {\n            path,\n            method: method,\n            headers: headers.toJSON(),\n            agents: {\n                http: config.httpAgent,\n                https: config.httpsAgent\n            },\n            auth,\n            protocol,\n            family,\n            beforeRedirect: dispatchBeforeRedirect,\n            beforeRedirects: {},\n            http2Options\n        };\n        // cacheable-lookup integration hotfix\n        !utils$1.isUndefined(lookup) && (options.lookup = lookup);\n        if (config.socketPath) {\n            options.socketPath = config.socketPath;\n        } else {\n            options.hostname = parsed.hostname.startsWith(\"[\") ? parsed.hostname.slice(1, -1) : parsed.hostname;\n            options.port = parsed.port;\n            setProxy(options, config.proxy, protocol + \"//\" + parsed.hostname + (parsed.port ? \":\" + parsed.port : \"\") + options.path);\n        }\n        let transport;\n        const isHttpsRequest = isHttps.test(options.protocol);\n        options.agent = isHttpsRequest ? config.httpsAgent : config.httpAgent;\n        if (isHttp2) {\n            transport = http2Transport;\n        } else {\n            if (config.transport) {\n                transport = config.transport;\n            } else if (config.maxRedirects === 0) {\n                transport = isHttpsRequest ? https__default[\"default\"] : http__default[\"default\"];\n            } else {\n                if (config.maxRedirects) {\n                    options.maxRedirects = config.maxRedirects;\n                }\n                if (config.beforeRedirect) {\n                    options.beforeRedirects.config = config.beforeRedirect;\n                }\n                transport = isHttpsRequest ? httpsFollow : httpFollow;\n            }\n        }\n        if (config.maxBodyLength > -1) {\n            options.maxBodyLength = config.maxBodyLength;\n        } else {\n            // follow-redirects does not skip comparison, so it should always succeed for axios -1 unlimited\n            options.maxBodyLength = Infinity;\n        }\n        if (config.insecureHTTPParser) {\n            options.insecureHTTPParser = config.insecureHTTPParser;\n        }\n        // Create the request\n        req = transport.request(options, function handleResponse(res) {\n            if (req.destroyed) return;\n            const streams = [\n                res\n            ];\n            const responseLength = utils$1.toFiniteNumber(res.headers[\"content-length\"]);\n            if (onDownloadProgress || maxDownloadRate) {\n                const transformStream = new AxiosTransformStream$1({\n                    maxRate: utils$1.toFiniteNumber(maxDownloadRate)\n                });\n                onDownloadProgress && transformStream.on(\"progress\", flushOnFinish(transformStream, progressEventDecorator(responseLength, progressEventReducer(asyncDecorator(onDownloadProgress), true, 3))));\n                streams.push(transformStream);\n            }\n            // decompress the response body transparently if required\n            let responseStream = res;\n            // return the last request in case of redirects\n            const lastRequest = res.req || req;\n            // if decompress disabled we should not decompress\n            if (config.decompress !== false && res.headers[\"content-encoding\"]) {\n                // if no content, but headers still say that it is encoded,\n                // remove the header not confuse downstream operations\n                if (method === \"HEAD\" || res.statusCode === 204) {\n                    delete res.headers[\"content-encoding\"];\n                }\n                switch((res.headers[\"content-encoding\"] || \"\").toLowerCase()){\n                    /*eslint default-case:0*/ case \"gzip\":\n                    case \"x-gzip\":\n                    case \"compress\":\n                    case \"x-compress\":\n                        // add the unzipper to the body stream processing pipeline\n                        streams.push(zlib__default[\"default\"].createUnzip(zlibOptions));\n                        // remove the content-encoding in order to not confuse downstream operations\n                        delete res.headers[\"content-encoding\"];\n                        break;\n                    case \"deflate\":\n                        streams.push(new ZlibHeaderTransformStream$1());\n                        // add the unzipper to the body stream processing pipeline\n                        streams.push(zlib__default[\"default\"].createUnzip(zlibOptions));\n                        // remove the content-encoding in order to not confuse downstream operations\n                        delete res.headers[\"content-encoding\"];\n                        break;\n                    case \"br\":\n                        if (isBrotliSupported) {\n                            streams.push(zlib__default[\"default\"].createBrotliDecompress(brotliOptions));\n                            delete res.headers[\"content-encoding\"];\n                        }\n                }\n            }\n            responseStream = streams.length > 1 ? stream__default[\"default\"].pipeline(streams, utils$1.noop) : streams[0];\n            const response = {\n                status: res.statusCode,\n                statusText: res.statusMessage,\n                headers: new AxiosHeaders$1(res.headers),\n                config,\n                request: lastRequest\n            };\n            if (responseType === \"stream\") {\n                response.data = responseStream;\n                settle(resolve, reject, response);\n            } else {\n                const responseBuffer = [];\n                let totalResponseBytes = 0;\n                responseStream.on(\"data\", function handleStreamData(chunk) {\n                    responseBuffer.push(chunk);\n                    totalResponseBytes += chunk.length;\n                    // make sure the content length is not over the maxContentLength if specified\n                    if (config.maxContentLength > -1 && totalResponseBytes > config.maxContentLength) {\n                        // stream.destroy() emit aborted event before calling reject() on Node.js v16\n                        rejected = true;\n                        responseStream.destroy();\n                        abort(new AxiosError$1(\"maxContentLength size of \" + config.maxContentLength + \" exceeded\", AxiosError$1.ERR_BAD_RESPONSE, config, lastRequest));\n                    }\n                });\n                responseStream.on(\"aborted\", function handlerStreamAborted() {\n                    if (rejected) {\n                        return;\n                    }\n                    const err = new AxiosError$1(\"stream has been aborted\", AxiosError$1.ERR_BAD_RESPONSE, config, lastRequest);\n                    responseStream.destroy(err);\n                    reject(err);\n                });\n                responseStream.on(\"error\", function handleStreamError(err) {\n                    if (req.destroyed) return;\n                    reject(AxiosError$1.from(err, null, config, lastRequest));\n                });\n                responseStream.on(\"end\", function handleStreamEnd() {\n                    try {\n                        let responseData = responseBuffer.length === 1 ? responseBuffer[0] : Buffer.concat(responseBuffer);\n                        if (responseType !== \"arraybuffer\") {\n                            responseData = responseData.toString(responseEncoding);\n                            if (!responseEncoding || responseEncoding === \"utf8\") {\n                                responseData = utils$1.stripBOM(responseData);\n                            }\n                        }\n                        response.data = responseData;\n                    } catch (err) {\n                        return reject(AxiosError$1.from(err, null, config, response.request, response));\n                    }\n                    settle(resolve, reject, response);\n                });\n            }\n            abortEmitter.once(\"abort\", (err)=>{\n                if (!responseStream.destroyed) {\n                    responseStream.emit(\"error\", err);\n                    responseStream.destroy();\n                }\n            });\n        });\n        abortEmitter.once(\"abort\", (err)=>{\n            if (req.close) {\n                req.close();\n            } else {\n                req.destroy(err);\n            }\n        });\n        // Handle errors\n        req.on(\"error\", function handleRequestError(err) {\n            reject(AxiosError$1.from(err, null, config, req));\n        });\n        // set tcp keep alive to prevent drop connection by peer\n        req.on(\"socket\", function handleRequestSocket(socket) {\n            // default interval of sending ack packet is 1 minute\n            socket.setKeepAlive(true, 1000 * 60);\n        });\n        // Handle request timeout\n        if (config.timeout) {\n            // This is forcing a int timeout to avoid problems if the `req` interface doesn't handle other types.\n            const timeout = parseInt(config.timeout, 10);\n            if (Number.isNaN(timeout)) {\n                abort(new AxiosError$1(\"error trying to parse `config.timeout` to int\", AxiosError$1.ERR_BAD_OPTION_VALUE, config, req));\n                return;\n            }\n            // Sometime, the response will be very slow, and does not respond, the connect event will be block by event loop system.\n            // And timer callback will be fired, and abort() will be invoked before connection, then get \"socket hang up\" and code ECONNRESET.\n            // At this time, if we have a large number of request, nodejs will hang up some socket on background. and the number will up and up.\n            // And then these socket which be hang up will devouring CPU little by little.\n            // ClientRequest.setTimeout will be fired on the specify milliseconds, and can make sure that abort() will be fired after connect.\n            req.setTimeout(timeout, function handleRequestTimeout() {\n                if (isDone) return;\n                let timeoutErrorMessage = config.timeout ? \"timeout of \" + config.timeout + \"ms exceeded\" : \"timeout exceeded\";\n                const transitional = config.transitional || transitionalDefaults;\n                if (config.timeoutErrorMessage) {\n                    timeoutErrorMessage = config.timeoutErrorMessage;\n                }\n                abort(new AxiosError$1(timeoutErrorMessage, transitional.clarifyTimeoutError ? AxiosError$1.ETIMEDOUT : AxiosError$1.ECONNABORTED, config, req));\n            });\n        } else {\n            // explicitly reset the socket timeout value for a possible `keep-alive` request\n            req.setTimeout(0);\n        }\n        // Send the request\n        if (utils$1.isStream(data)) {\n            let ended = false;\n            let errored = false;\n            data.on(\"end\", ()=>{\n                ended = true;\n            });\n            data.once(\"error\", (err)=>{\n                errored = true;\n                req.destroy(err);\n            });\n            data.on(\"close\", ()=>{\n                if (!ended && !errored) {\n                    abort(new CanceledError$1(\"Request stream has been aborted\", config, req));\n                }\n            });\n            data.pipe(req);\n        } else {\n            data && req.write(data);\n            req.end();\n        }\n    });\n};\nconst isURLSameOrigin = platform.hasStandardBrowserEnv ? ((origin, isMSIE)=>(url)=>{\n        url = new URL(url, platform.origin);\n        return origin.protocol === url.protocol && origin.host === url.host && (isMSIE || origin.port === url.port);\n    })(new URL(platform.origin), platform.navigator && /(msie|trident)/i.test(platform.navigator.userAgent)) : ()=>true;\nconst cookies = platform.hasStandardBrowserEnv ? // Standard browser envs support document.cookie\n{\n    write (name, value, expires, path, domain, secure, sameSite) {\n        if (typeof document === \"undefined\") return;\n        const cookie = [\n            `${name}=${encodeURIComponent(value)}`\n        ];\n        if (utils$1.isNumber(expires)) {\n            cookie.push(`expires=${new Date(expires).toUTCString()}`);\n        }\n        if (utils$1.isString(path)) {\n            cookie.push(`path=${path}`);\n        }\n        if (utils$1.isString(domain)) {\n            cookie.push(`domain=${domain}`);\n        }\n        if (secure === true) {\n            cookie.push(\"secure\");\n        }\n        if (utils$1.isString(sameSite)) {\n            cookie.push(`SameSite=${sameSite}`);\n        }\n        document.cookie = cookie.join(\"; \");\n    },\n    read (name) {\n        if (typeof document === \"undefined\") return null;\n        const match = document.cookie.match(new RegExp(\"(?:^|; )\" + name + \"=([^;]*)\"));\n        return match ? decodeURIComponent(match[1]) : null;\n    },\n    remove (name) {\n        this.write(name, \"\", Date.now() - 86400000, \"/\");\n    }\n} : // Non-standard browser env (web workers, react-native) lack needed support.\n{\n    write () {},\n    read () {\n        return null;\n    },\n    remove () {}\n};\nconst headersToObject = (thing)=>thing instanceof AxiosHeaders$1 ? {\n        ...thing\n    } : thing;\n/**\n * Config-specific merge-function which creates a new config-object\n * by merging two configuration objects together.\n *\n * @param {Object} config1\n * @param {Object} config2\n *\n * @returns {Object} New object resulting from merging config2 to config1\n */ function mergeConfig(config1, config2) {\n    // eslint-disable-next-line no-param-reassign\n    config2 = config2 || {};\n    const config = {};\n    function getMergedValue(target, source, prop, caseless) {\n        if (utils$1.isPlainObject(target) && utils$1.isPlainObject(source)) {\n            return utils$1.merge.call({\n                caseless\n            }, target, source);\n        } else if (utils$1.isPlainObject(source)) {\n            return utils$1.merge({}, source);\n        } else if (utils$1.isArray(source)) {\n            return source.slice();\n        }\n        return source;\n    }\n    function mergeDeepProperties(a, b, prop, caseless) {\n        if (!utils$1.isUndefined(b)) {\n            return getMergedValue(a, b, prop, caseless);\n        } else if (!utils$1.isUndefined(a)) {\n            return getMergedValue(undefined, a, prop, caseless);\n        }\n    }\n    // eslint-disable-next-line consistent-return\n    function valueFromConfig2(a, b) {\n        if (!utils$1.isUndefined(b)) {\n            return getMergedValue(undefined, b);\n        }\n    }\n    // eslint-disable-next-line consistent-return\n    function defaultToConfig2(a, b) {\n        if (!utils$1.isUndefined(b)) {\n            return getMergedValue(undefined, b);\n        } else if (!utils$1.isUndefined(a)) {\n            return getMergedValue(undefined, a);\n        }\n    }\n    // eslint-disable-next-line consistent-return\n    function mergeDirectKeys(a, b, prop) {\n        if (prop in config2) {\n            return getMergedValue(a, b);\n        } else if (prop in config1) {\n            return getMergedValue(undefined, a);\n        }\n    }\n    const mergeMap = {\n        url: valueFromConfig2,\n        method: valueFromConfig2,\n        data: valueFromConfig2,\n        baseURL: defaultToConfig2,\n        transformRequest: defaultToConfig2,\n        transformResponse: defaultToConfig2,\n        paramsSerializer: defaultToConfig2,\n        timeout: defaultToConfig2,\n        timeoutMessage: defaultToConfig2,\n        withCredentials: defaultToConfig2,\n        withXSRFToken: defaultToConfig2,\n        adapter: defaultToConfig2,\n        responseType: defaultToConfig2,\n        xsrfCookieName: defaultToConfig2,\n        xsrfHeaderName: defaultToConfig2,\n        onUploadProgress: defaultToConfig2,\n        onDownloadProgress: defaultToConfig2,\n        decompress: defaultToConfig2,\n        maxContentLength: defaultToConfig2,\n        maxBodyLength: defaultToConfig2,\n        beforeRedirect: defaultToConfig2,\n        transport: defaultToConfig2,\n        httpAgent: defaultToConfig2,\n        httpsAgent: defaultToConfig2,\n        cancelToken: defaultToConfig2,\n        socketPath: defaultToConfig2,\n        responseEncoding: defaultToConfig2,\n        validateStatus: mergeDirectKeys,\n        headers: (a, b, prop)=>mergeDeepProperties(headersToObject(a), headersToObject(b), prop, true)\n    };\n    utils$1.forEach(Object.keys({\n        ...config1,\n        ...config2\n    }), function computeConfigValue(prop) {\n        const merge = mergeMap[prop] || mergeDeepProperties;\n        const configValue = merge(config1[prop], config2[prop], prop);\n        utils$1.isUndefined(configValue) && merge !== mergeDirectKeys || (config[prop] = configValue);\n    });\n    return config;\n}\nconst resolveConfig = (config)=>{\n    const newConfig = mergeConfig({}, config);\n    let { data, withXSRFToken, xsrfHeaderName, xsrfCookieName, headers, auth } = newConfig;\n    newConfig.headers = headers = AxiosHeaders$1.from(headers);\n    newConfig.url = buildURL(buildFullPath(newConfig.baseURL, newConfig.url, newConfig.allowAbsoluteUrls), config.params, config.paramsSerializer);\n    // HTTP basic authentication\n    if (auth) {\n        headers.set(\"Authorization\", \"Basic \" + btoa((auth.username || \"\") + \":\" + (auth.password ? unescape(encodeURIComponent(auth.password)) : \"\")));\n    }\n    if (utils$1.isFormData(data)) {\n        if (platform.hasStandardBrowserEnv || platform.hasStandardBrowserWebWorkerEnv) {\n            headers.setContentType(undefined); // browser handles it\n        } else if (utils$1.isFunction(data.getHeaders)) {\n            // Node.js FormData (like form-data package)\n            const formHeaders = data.getHeaders();\n            // Only set safe headers to avoid overwriting security headers\n            const allowedHeaders = [\n                \"content-type\",\n                \"content-length\"\n            ];\n            Object.entries(formHeaders).forEach(([key, val])=>{\n                if (allowedHeaders.includes(key.toLowerCase())) {\n                    headers.set(key, val);\n                }\n            });\n        }\n    }\n    // Add xsrf header\n    // This is only done if running in a standard browser environment.\n    // Specifically not if we're in a web worker, or react-native.\n    if (platform.hasStandardBrowserEnv) {\n        withXSRFToken && utils$1.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));\n        if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin(newConfig.url)) {\n            // Add xsrf header\n            const xsrfValue = xsrfHeaderName && xsrfCookieName && cookies.read(xsrfCookieName);\n            if (xsrfValue) {\n                headers.set(xsrfHeaderName, xsrfValue);\n            }\n        }\n    }\n    return newConfig;\n};\nconst isXHRAdapterSupported = typeof XMLHttpRequest !== \"undefined\";\nconst xhrAdapter = isXHRAdapterSupported && function(config) {\n    return new Promise(function dispatchXhrRequest(resolve, reject) {\n        const _config = resolveConfig(config);\n        let requestData = _config.data;\n        const requestHeaders = AxiosHeaders$1.from(_config.headers).normalize();\n        let { responseType, onUploadProgress, onDownloadProgress } = _config;\n        let onCanceled;\n        let uploadThrottled, downloadThrottled;\n        let flushUpload, flushDownload;\n        function done() {\n            flushUpload && flushUpload(); // flush events\n            flushDownload && flushDownload(); // flush events\n            _config.cancelToken && _config.cancelToken.unsubscribe(onCanceled);\n            _config.signal && _config.signal.removeEventListener(\"abort\", onCanceled);\n        }\n        let request = new XMLHttpRequest();\n        request.open(_config.method.toUpperCase(), _config.url, true);\n        // Set the request timeout in MS\n        request.timeout = _config.timeout;\n        function onloadend() {\n            if (!request) {\n                return;\n            }\n            // Prepare the response\n            const responseHeaders = AxiosHeaders$1.from(\"getAllResponseHeaders\" in request && request.getAllResponseHeaders());\n            const responseData = !responseType || responseType === \"text\" || responseType === \"json\" ? request.responseText : request.response;\n            const response = {\n                data: responseData,\n                status: request.status,\n                statusText: request.statusText,\n                headers: responseHeaders,\n                config,\n                request\n            };\n            settle(function _resolve(value) {\n                resolve(value);\n                done();\n            }, function _reject(err) {\n                reject(err);\n                done();\n            }, response);\n            // Clean up request\n            request = null;\n        }\n        if (\"onloadend\" in request) {\n            // Use onloadend if available\n            request.onloadend = onloadend;\n        } else {\n            // Listen for ready state to emulate onloadend\n            request.onreadystatechange = function handleLoad() {\n                if (!request || request.readyState !== 4) {\n                    return;\n                }\n                // The request errored out and we didn't get a response, this will be\n                // handled by onerror instead\n                // With one exception: request that using file: protocol, most browsers\n                // will return status as 0 even though it's a successful request\n                if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf(\"file:\") === 0)) {\n                    return;\n                }\n                // readystate handler is calling before onerror or ontimeout handlers,\n                // so we should call onloadend on the next 'tick'\n                setTimeout(onloadend);\n            };\n        }\n        // Handle browser request cancellation (as opposed to a manual cancellation)\n        request.onabort = function handleAbort() {\n            if (!request) {\n                return;\n            }\n            reject(new AxiosError$1(\"Request aborted\", AxiosError$1.ECONNABORTED, config, request));\n            // Clean up request\n            request = null;\n        };\n        // Handle low level network errors\n        request.onerror = function handleError(event) {\n            // Browsers deliver a ProgressEvent in XHR onerror\n            // (message may be empty; when present, surface it)\n            // See https://developer.mozilla.org/docs/Web/API/XMLHttpRequest/error_event\n            const msg = event && event.message ? event.message : \"Network Error\";\n            const err = new AxiosError$1(msg, AxiosError$1.ERR_NETWORK, config, request);\n            // attach the underlying event for consumers who want details\n            err.event = event || null;\n            reject(err);\n            request = null;\n        };\n        // Handle timeout\n        request.ontimeout = function handleTimeout() {\n            let timeoutErrorMessage = _config.timeout ? \"timeout of \" + _config.timeout + \"ms exceeded\" : \"timeout exceeded\";\n            const transitional = _config.transitional || transitionalDefaults;\n            if (_config.timeoutErrorMessage) {\n                timeoutErrorMessage = _config.timeoutErrorMessage;\n            }\n            reject(new AxiosError$1(timeoutErrorMessage, transitional.clarifyTimeoutError ? AxiosError$1.ETIMEDOUT : AxiosError$1.ECONNABORTED, config, request));\n            // Clean up request\n            request = null;\n        };\n        // Remove Content-Type if data is undefined\n        requestData === undefined && requestHeaders.setContentType(null);\n        // Add headers to the request\n        if (\"setRequestHeader\" in request) {\n            utils$1.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {\n                request.setRequestHeader(key, val);\n            });\n        }\n        // Add withCredentials to request if needed\n        if (!utils$1.isUndefined(_config.withCredentials)) {\n            request.withCredentials = !!_config.withCredentials;\n        }\n        // Add responseType to request if needed\n        if (responseType && responseType !== \"json\") {\n            request.responseType = _config.responseType;\n        }\n        // Handle progress if needed\n        if (onDownloadProgress) {\n            [downloadThrottled, flushDownload] = progressEventReducer(onDownloadProgress, true);\n            request.addEventListener(\"progress\", downloadThrottled);\n        }\n        // Not all browsers support upload events\n        if (onUploadProgress && request.upload) {\n            [uploadThrottled, flushUpload] = progressEventReducer(onUploadProgress);\n            request.upload.addEventListener(\"progress\", uploadThrottled);\n            request.upload.addEventListener(\"loadend\", flushUpload);\n        }\n        if (_config.cancelToken || _config.signal) {\n            // Handle cancellation\n            // eslint-disable-next-line func-names\n            onCanceled = (cancel)=>{\n                if (!request) {\n                    return;\n                }\n                reject(!cancel || cancel.type ? new CanceledError$1(null, config, request) : cancel);\n                request.abort();\n                request = null;\n            };\n            _config.cancelToken && _config.cancelToken.subscribe(onCanceled);\n            if (_config.signal) {\n                _config.signal.aborted ? onCanceled() : _config.signal.addEventListener(\"abort\", onCanceled);\n            }\n        }\n        const protocol = parseProtocol(_config.url);\n        if (protocol && platform.protocols.indexOf(protocol) === -1) {\n            reject(new AxiosError$1(\"Unsupported protocol \" + protocol + \":\", AxiosError$1.ERR_BAD_REQUEST, config));\n            return;\n        }\n        // Send the request\n        request.send(requestData || null);\n    });\n};\nconst composeSignals = (signals, timeout)=>{\n    const { length } = signals = signals ? signals.filter(Boolean) : [];\n    if (timeout || length) {\n        let controller = new AbortController();\n        let aborted;\n        const onabort = function(reason) {\n            if (!aborted) {\n                aborted = true;\n                unsubscribe();\n                const err = reason instanceof Error ? reason : this.reason;\n                controller.abort(err instanceof AxiosError$1 ? err : new CanceledError$1(err instanceof Error ? err.message : err));\n            }\n        };\n        let timer = timeout && setTimeout(()=>{\n            timer = null;\n            onabort(new AxiosError$1(`timeout of ${timeout}ms exceeded`, AxiosError$1.ETIMEDOUT));\n        }, timeout);\n        const unsubscribe = ()=>{\n            if (signals) {\n                timer && clearTimeout(timer);\n                timer = null;\n                signals.forEach((signal)=>{\n                    signal.unsubscribe ? signal.unsubscribe(onabort) : signal.removeEventListener(\"abort\", onabort);\n                });\n                signals = null;\n            }\n        };\n        signals.forEach((signal)=>signal.addEventListener(\"abort\", onabort));\n        const { signal } = controller;\n        signal.unsubscribe = ()=>utils$1.asap(unsubscribe);\n        return signal;\n    }\n};\nconst composeSignals$1 = composeSignals;\nconst streamChunk = function*(chunk, chunkSize) {\n    let len = chunk.byteLength;\n    if (!chunkSize || len < chunkSize) {\n        yield chunk;\n        return;\n    }\n    let pos = 0;\n    let end;\n    while(pos < len){\n        end = pos + chunkSize;\n        yield chunk.slice(pos, end);\n        pos = end;\n    }\n};\nconst readBytes = async function*(iterable, chunkSize) {\n    for await (const chunk of readStream(iterable)){\n        yield* streamChunk(chunk, chunkSize);\n    }\n};\nconst readStream = async function*(stream) {\n    if (stream[Symbol.asyncIterator]) {\n        yield* stream;\n        return;\n    }\n    const reader = stream.getReader();\n    try {\n        for(;;){\n            const { done, value } = await reader.read();\n            if (done) {\n                break;\n            }\n            yield value;\n        }\n    } finally{\n        await reader.cancel();\n    }\n};\nconst trackStream = (stream, chunkSize, onProgress, onFinish)=>{\n    const iterator = readBytes(stream, chunkSize);\n    let bytes = 0;\n    let done;\n    let _onFinish = (e)=>{\n        if (!done) {\n            done = true;\n            onFinish && onFinish(e);\n        }\n    };\n    return new ReadableStream({\n        async pull (controller) {\n            try {\n                const { done, value } = await iterator.next();\n                if (done) {\n                    _onFinish();\n                    controller.close();\n                    return;\n                }\n                let len = value.byteLength;\n                if (onProgress) {\n                    let loadedBytes = bytes += len;\n                    onProgress(loadedBytes);\n                }\n                controller.enqueue(new Uint8Array(value));\n            } catch (err) {\n                _onFinish(err);\n                throw err;\n            }\n        },\n        cancel (reason) {\n            _onFinish(reason);\n            return iterator.return();\n        }\n    }, {\n        highWaterMark: 2\n    });\n};\nconst DEFAULT_CHUNK_SIZE = 64 * 1024;\nconst { isFunction } = utils$1;\nconst globalFetchAPI = (({ Request, Response })=>({\n        Request,\n        Response\n    }))(utils$1.global);\nconst { ReadableStream: ReadableStream$1, TextEncoder: TextEncoder$1 } = utils$1.global;\nconst test = (fn, ...args)=>{\n    try {\n        return !!fn(...args);\n    } catch (e) {\n        return false;\n    }\n};\nconst factory = (env)=>{\n    env = utils$1.merge.call({\n        skipUndefined: true\n    }, globalFetchAPI, env);\n    const { fetch: envFetch, Request, Response } = env;\n    const isFetchSupported = envFetch ? isFunction(envFetch) : typeof fetch === \"function\";\n    const isRequestSupported = isFunction(Request);\n    const isResponseSupported = isFunction(Response);\n    if (!isFetchSupported) {\n        return false;\n    }\n    const isReadableStreamSupported = isFetchSupported && isFunction(ReadableStream$1);\n    const encodeText = isFetchSupported && (typeof TextEncoder$1 === \"function\" ? ((encoder)=>(str)=>encoder.encode(str))(new TextEncoder$1()) : async (str)=>new Uint8Array(await new Request(str).arrayBuffer()));\n    const supportsRequestStream = isRequestSupported && isReadableStreamSupported && test(()=>{\n        let duplexAccessed = false;\n        const hasContentType = new Request(platform.origin, {\n            body: new ReadableStream$1(),\n            method: \"POST\",\n            get duplex () {\n                duplexAccessed = true;\n                return \"half\";\n            }\n        }).headers.has(\"Content-Type\");\n        return duplexAccessed && !hasContentType;\n    });\n    const supportsResponseStream = isResponseSupported && isReadableStreamSupported && test(()=>utils$1.isReadableStream(new Response(\"\").body));\n    const resolvers = {\n        stream: supportsResponseStream && ((res)=>res.body)\n    };\n    isFetchSupported && (()=>{\n        [\n            \"text\",\n            \"arrayBuffer\",\n            \"blob\",\n            \"formData\",\n            \"stream\"\n        ].forEach((type)=>{\n            !resolvers[type] && (resolvers[type] = (res, config)=>{\n                let method = res && res[type];\n                if (method) {\n                    return method.call(res);\n                }\n                throw new AxiosError$1(`Response type '${type}' is not supported`, AxiosError$1.ERR_NOT_SUPPORT, config);\n            });\n        });\n    })();\n    const getBodyLength = async (body)=>{\n        if (body == null) {\n            return 0;\n        }\n        if (utils$1.isBlob(body)) {\n            return body.size;\n        }\n        if (utils$1.isSpecCompliantForm(body)) {\n            const _request = new Request(platform.origin, {\n                method: \"POST\",\n                body\n            });\n            return (await _request.arrayBuffer()).byteLength;\n        }\n        if (utils$1.isArrayBufferView(body) || utils$1.isArrayBuffer(body)) {\n            return body.byteLength;\n        }\n        if (utils$1.isURLSearchParams(body)) {\n            body = body + \"\";\n        }\n        if (utils$1.isString(body)) {\n            return (await encodeText(body)).byteLength;\n        }\n    };\n    const resolveBodyLength = async (headers, body)=>{\n        const length = utils$1.toFiniteNumber(headers.getContentLength());\n        return length == null ? getBodyLength(body) : length;\n    };\n    return async (config)=>{\n        let { url, method, data, signal, cancelToken, timeout, onDownloadProgress, onUploadProgress, responseType, headers, withCredentials = \"same-origin\", fetchOptions } = resolveConfig(config);\n        let _fetch = envFetch || fetch;\n        responseType = responseType ? (responseType + \"\").toLowerCase() : \"text\";\n        let composedSignal = composeSignals$1([\n            signal,\n            cancelToken && cancelToken.toAbortSignal()\n        ], timeout);\n        let request = null;\n        const unsubscribe = composedSignal && composedSignal.unsubscribe && (()=>{\n            composedSignal.unsubscribe();\n        });\n        let requestContentLength;\n        try {\n            if (onUploadProgress && supportsRequestStream && method !== \"get\" && method !== \"head\" && (requestContentLength = await resolveBodyLength(headers, data)) !== 0) {\n                let _request = new Request(url, {\n                    method: \"POST\",\n                    body: data,\n                    duplex: \"half\"\n                });\n                let contentTypeHeader;\n                if (utils$1.isFormData(data) && (contentTypeHeader = _request.headers.get(\"content-type\"))) {\n                    headers.setContentType(contentTypeHeader);\n                }\n                if (_request.body) {\n                    const [onProgress, flush] = progressEventDecorator(requestContentLength, progressEventReducer(asyncDecorator(onUploadProgress)));\n                    data = trackStream(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush);\n                }\n            }\n            if (!utils$1.isString(withCredentials)) {\n                withCredentials = withCredentials ? \"include\" : \"omit\";\n            }\n            // Cloudflare Workers throws when credentials are defined\n            // see https://github.com/cloudflare/workerd/issues/902\n            const isCredentialsSupported = isRequestSupported && \"credentials\" in Request.prototype;\n            const resolvedOptions = {\n                ...fetchOptions,\n                signal: composedSignal,\n                method: method.toUpperCase(),\n                headers: headers.normalize().toJSON(),\n                body: data,\n                duplex: \"half\",\n                credentials: isCredentialsSupported ? withCredentials : undefined\n            };\n            request = isRequestSupported && new Request(url, resolvedOptions);\n            let response = await (isRequestSupported ? _fetch(request, fetchOptions) : _fetch(url, resolvedOptions));\n            const isStreamResponse = supportsResponseStream && (responseType === \"stream\" || responseType === \"response\");\n            if (supportsResponseStream && (onDownloadProgress || isStreamResponse && unsubscribe)) {\n                const options = {};\n                [\n                    \"status\",\n                    \"statusText\",\n                    \"headers\"\n                ].forEach((prop)=>{\n                    options[prop] = response[prop];\n                });\n                const responseContentLength = utils$1.toFiniteNumber(response.headers.get(\"content-length\"));\n                const [onProgress, flush] = onDownloadProgress && progressEventDecorator(responseContentLength, progressEventReducer(asyncDecorator(onDownloadProgress), true)) || [];\n                response = new Response(trackStream(response.body, DEFAULT_CHUNK_SIZE, onProgress, ()=>{\n                    flush && flush();\n                    unsubscribe && unsubscribe();\n                }), options);\n            }\n            responseType = responseType || \"text\";\n            let responseData = await resolvers[utils$1.findKey(resolvers, responseType) || \"text\"](response, config);\n            !isStreamResponse && unsubscribe && unsubscribe();\n            return await new Promise((resolve, reject)=>{\n                settle(resolve, reject, {\n                    data: responseData,\n                    headers: AxiosHeaders$1.from(response.headers),\n                    status: response.status,\n                    statusText: response.statusText,\n                    config,\n                    request\n                });\n            });\n        } catch (err) {\n            unsubscribe && unsubscribe();\n            if (err && err.name === \"TypeError\" && /Load failed|fetch/i.test(err.message)) {\n                throw Object.assign(new AxiosError$1(\"Network Error\", AxiosError$1.ERR_NETWORK, config, request), {\n                    cause: err.cause || err\n                });\n            }\n            throw AxiosError$1.from(err, err && err.code, config, request);\n        }\n    };\n};\nconst seedCache = new Map();\nconst getFetch = (config)=>{\n    let env = config && config.env || {};\n    const { fetch: fetch1, Request, Response } = env;\n    const seeds = [\n        Request,\n        Response,\n        fetch1\n    ];\n    let len = seeds.length, i = len, seed, target, map = seedCache;\n    while(i--){\n        seed = seeds[i];\n        target = map.get(seed);\n        target === undefined && map.set(seed, target = i ? new Map() : factory(env));\n        map = target;\n    }\n    return target;\n};\ngetFetch();\n/**\n * Known adapters mapping.\n * Provides environment-specific adapters for Axios:\n * - `http` for Node.js\n * - `xhr` for browsers\n * - `fetch` for fetch API-based requests\n * \n * @type {Object<string, Function|Object>}\n */ const knownAdapters = {\n    http: httpAdapter,\n    xhr: xhrAdapter,\n    fetch: {\n        get: getFetch\n    }\n};\n// Assign adapter names for easier debugging and identification\nutils$1.forEach(knownAdapters, (fn, value)=>{\n    if (fn) {\n        try {\n            Object.defineProperty(fn, \"name\", {\n                value\n            });\n        } catch (e) {\n        // eslint-disable-next-line no-empty\n        }\n        Object.defineProperty(fn, \"adapterName\", {\n            value\n        });\n    }\n});\n/**\n * Render a rejection reason string for unknown or unsupported adapters\n * \n * @param {string} reason\n * @returns {string}\n */ const renderReason = (reason)=>`- ${reason}`;\n/**\n * Check if the adapter is resolved (function, null, or false)\n * \n * @param {Function|null|false} adapter\n * @returns {boolean}\n */ const isResolvedHandle = (adapter)=>utils$1.isFunction(adapter) || adapter === null || adapter === false;\n/**\n * Get the first suitable adapter from the provided list.\n * Tries each adapter in order until a supported one is found.\n * Throws an AxiosError if no adapter is suitable.\n * \n * @param {Array<string|Function>|string|Function} adapters - Adapter(s) by name or function.\n * @param {Object} config - Axios request configuration\n * @throws {AxiosError} If no suitable adapter is available\n * @returns {Function} The resolved adapter function\n */ function getAdapter(adapters, config) {\n    adapters = utils$1.isArray(adapters) ? adapters : [\n        adapters\n    ];\n    const { length } = adapters;\n    let nameOrAdapter;\n    let adapter;\n    const rejectedReasons = {};\n    for(let i = 0; i < length; i++){\n        nameOrAdapter = adapters[i];\n        let id;\n        adapter = nameOrAdapter;\n        if (!isResolvedHandle(nameOrAdapter)) {\n            adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];\n            if (adapter === undefined) {\n                throw new AxiosError$1(`Unknown adapter '${id}'`);\n            }\n        }\n        if (adapter && (utils$1.isFunction(adapter) || (adapter = adapter.get(config)))) {\n            break;\n        }\n        rejectedReasons[id || \"#\" + i] = adapter;\n    }\n    if (!adapter) {\n        const reasons = Object.entries(rejectedReasons).map(([id, state])=>`adapter ${id} ` + (state === false ? \"is not supported by the environment\" : \"is not available in the build\"));\n        let s = length ? reasons.length > 1 ? \"since :\\n\" + reasons.map(renderReason).join(\"\\n\") : \" \" + renderReason(reasons[0]) : \"as no adapter specified\";\n        throw new AxiosError$1(`There is no suitable adapter to dispatch the request ` + s, \"ERR_NOT_SUPPORT\");\n    }\n    return adapter;\n}\n/**\n * Exports Axios adapters and utility to resolve an adapter\n */ const adapters = {\n    /**\n   * Resolve an adapter from a list of adapter names or functions.\n   * @type {Function}\n   */ getAdapter,\n    /**\n   * Exposes all known adapters\n   * @type {Object<string, Function|Object>}\n   */ adapters: knownAdapters\n};\n/**\n * Throws a `CanceledError` if cancellation has been requested.\n *\n * @param {Object} config The config that is to be used for the request\n *\n * @returns {void}\n */ function throwIfCancellationRequested(config) {\n    if (config.cancelToken) {\n        config.cancelToken.throwIfRequested();\n    }\n    if (config.signal && config.signal.aborted) {\n        throw new CanceledError$1(null, config);\n    }\n}\n/**\n * Dispatch a request to the server using the configured adapter.\n *\n * @param {object} config The config that is to be used for the request\n *\n * @returns {Promise} The Promise to be fulfilled\n */ function dispatchRequest(config) {\n    throwIfCancellationRequested(config);\n    config.headers = AxiosHeaders$1.from(config.headers);\n    // Transform request data\n    config.data = transformData.call(config, config.transformRequest);\n    if ([\n        \"post\",\n        \"put\",\n        \"patch\"\n    ].indexOf(config.method) !== -1) {\n        config.headers.setContentType(\"application/x-www-form-urlencoded\", false);\n    }\n    const adapter = adapters.getAdapter(config.adapter || defaults$1.adapter, config);\n    return adapter(config).then(function onAdapterResolution(response) {\n        throwIfCancellationRequested(config);\n        // Transform response data\n        response.data = transformData.call(config, config.transformResponse, response);\n        response.headers = AxiosHeaders$1.from(response.headers);\n        return response;\n    }, function onAdapterRejection(reason) {\n        if (!isCancel(reason)) {\n            throwIfCancellationRequested(config);\n            // Transform response data\n            if (reason && reason.response) {\n                reason.response.data = transformData.call(config, config.transformResponse, reason.response);\n                reason.response.headers = AxiosHeaders$1.from(reason.response.headers);\n            }\n        }\n        return Promise.reject(reason);\n    });\n}\nconst validators$1 = {};\n// eslint-disable-next-line func-names\n[\n    \"object\",\n    \"boolean\",\n    \"number\",\n    \"function\",\n    \"string\",\n    \"symbol\"\n].forEach((type, i)=>{\n    validators$1[type] = function validator(thing) {\n        return typeof thing === type || \"a\" + (i < 1 ? \"n \" : \" \") + type;\n    };\n});\nconst deprecatedWarnings = {};\n/**\n * Transitional option validator\n *\n * @param {function|boolean?} validator - set to false if the transitional option has been removed\n * @param {string?} version - deprecated version / removed since version\n * @param {string?} message - some message with additional info\n *\n * @returns {function}\n */ validators$1.transitional = function transitional(validator, version, message) {\n    function formatMessage(opt, desc) {\n        return \"[Axios v\" + VERSION + \"] Transitional option '\" + opt + \"'\" + desc + (message ? \". \" + message : \"\");\n    }\n    // eslint-disable-next-line func-names\n    return (value, opt, opts)=>{\n        if (validator === false) {\n            throw new AxiosError$1(formatMessage(opt, \" has been removed\" + (version ? \" in \" + version : \"\")), AxiosError$1.ERR_DEPRECATED);\n        }\n        if (version && !deprecatedWarnings[opt]) {\n            deprecatedWarnings[opt] = true;\n            // eslint-disable-next-line no-console\n            console.warn(formatMessage(opt, \" has been deprecated since v\" + version + \" and will be removed in the near future\"));\n        }\n        return validator ? validator(value, opt, opts) : true;\n    };\n};\nvalidators$1.spelling = function spelling(correctSpelling) {\n    return (value, opt)=>{\n        // eslint-disable-next-line no-console\n        console.warn(`${opt} is likely a misspelling of ${correctSpelling}`);\n        return true;\n    };\n};\n/**\n * Assert object's properties type\n *\n * @param {object} options\n * @param {object} schema\n * @param {boolean?} allowUnknown\n *\n * @returns {object}\n */ function assertOptions(options, schema, allowUnknown) {\n    if (typeof options !== \"object\") {\n        throw new AxiosError$1(\"options must be an object\", AxiosError$1.ERR_BAD_OPTION_VALUE);\n    }\n    const keys = Object.keys(options);\n    let i = keys.length;\n    while(i-- > 0){\n        const opt = keys[i];\n        const validator = schema[opt];\n        if (validator) {\n            const value = options[opt];\n            const result = value === undefined || validator(value, opt, options);\n            if (result !== true) {\n                throw new AxiosError$1(\"option \" + opt + \" must be \" + result, AxiosError$1.ERR_BAD_OPTION_VALUE);\n            }\n            continue;\n        }\n        if (allowUnknown !== true) {\n            throw new AxiosError$1(\"Unknown option \" + opt, AxiosError$1.ERR_BAD_OPTION);\n        }\n    }\n}\nconst validator = {\n    assertOptions,\n    validators: validators$1\n};\nconst validators = validator.validators;\n/**\n * Create a new instance of Axios\n *\n * @param {Object} instanceConfig The default config for the instance\n *\n * @return {Axios} A new instance of Axios\n */ class Axios {\n    constructor(instanceConfig){\n        this.defaults = instanceConfig || {};\n        this.interceptors = {\n            request: new InterceptorManager$1(),\n            response: new InterceptorManager$1()\n        };\n    }\n    /**\n   * Dispatch a request\n   *\n   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)\n   * @param {?Object} config\n   *\n   * @returns {Promise} The Promise to be fulfilled\n   */ async request(configOrUrl, config) {\n        try {\n            return await this._request(configOrUrl, config);\n        } catch (err) {\n            if (err instanceof Error) {\n                let dummy = {};\n                Error.captureStackTrace ? Error.captureStackTrace(dummy) : dummy = new Error();\n                // slice off the Error: ... line\n                const stack = dummy.stack ? dummy.stack.replace(/^.+\\n/, \"\") : \"\";\n                try {\n                    if (!err.stack) {\n                        err.stack = stack;\n                    // match without the 2 top stack lines\n                    } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\\n.+\\n/, \"\"))) {\n                        err.stack += \"\\n\" + stack;\n                    }\n                } catch (e) {\n                // ignore the case where \"stack\" is an un-writable property\n                }\n            }\n            throw err;\n        }\n    }\n    _request(configOrUrl, config) {\n        /*eslint no-param-reassign:0*/ // Allow for axios('example/url'[, config]) a la fetch API\n        if (typeof configOrUrl === \"string\") {\n            config = config || {};\n            config.url = configOrUrl;\n        } else {\n            config = configOrUrl || {};\n        }\n        config = mergeConfig(this.defaults, config);\n        const { transitional, paramsSerializer, headers } = config;\n        if (transitional !== undefined) {\n            validator.assertOptions(transitional, {\n                silentJSONParsing: validators.transitional(validators.boolean),\n                forcedJSONParsing: validators.transitional(validators.boolean),\n                clarifyTimeoutError: validators.transitional(validators.boolean)\n            }, false);\n        }\n        if (paramsSerializer != null) {\n            if (utils$1.isFunction(paramsSerializer)) {\n                config.paramsSerializer = {\n                    serialize: paramsSerializer\n                };\n            } else {\n                validator.assertOptions(paramsSerializer, {\n                    encode: validators.function,\n                    serialize: validators.function\n                }, true);\n            }\n        }\n        // Set config.allowAbsoluteUrls\n        if (config.allowAbsoluteUrls !== undefined) ;\n        else if (this.defaults.allowAbsoluteUrls !== undefined) {\n            config.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls;\n        } else {\n            config.allowAbsoluteUrls = true;\n        }\n        validator.assertOptions(config, {\n            baseUrl: validators.spelling(\"baseURL\"),\n            withXsrfToken: validators.spelling(\"withXSRFToken\")\n        }, true);\n        // Set config.method\n        config.method = (config.method || this.defaults.method || \"get\").toLowerCase();\n        // Flatten headers\n        let contextHeaders = headers && utils$1.merge(headers.common, headers[config.method]);\n        headers && utils$1.forEach([\n            \"delete\",\n            \"get\",\n            \"head\",\n            \"post\",\n            \"put\",\n            \"patch\",\n            \"common\"\n        ], (method)=>{\n            delete headers[method];\n        });\n        config.headers = AxiosHeaders$1.concat(contextHeaders, headers);\n        // filter out skipped interceptors\n        const requestInterceptorChain = [];\n        let synchronousRequestInterceptors = true;\n        this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {\n            if (typeof interceptor.runWhen === \"function\" && interceptor.runWhen(config) === false) {\n                return;\n            }\n            synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;\n            requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);\n        });\n        const responseInterceptorChain = [];\n        this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {\n            responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);\n        });\n        let promise;\n        let i = 0;\n        let len;\n        if (!synchronousRequestInterceptors) {\n            const chain = [\n                dispatchRequest.bind(this),\n                undefined\n            ];\n            chain.unshift(...requestInterceptorChain);\n            chain.push(...responseInterceptorChain);\n            len = chain.length;\n            promise = Promise.resolve(config);\n            while(i < len){\n                promise = promise.then(chain[i++], chain[i++]);\n            }\n            return promise;\n        }\n        len = requestInterceptorChain.length;\n        let newConfig = config;\n        while(i < len){\n            const onFulfilled = requestInterceptorChain[i++];\n            const onRejected = requestInterceptorChain[i++];\n            try {\n                newConfig = onFulfilled(newConfig);\n            } catch (error) {\n                onRejected.call(this, error);\n                break;\n            }\n        }\n        try {\n            promise = dispatchRequest.call(this, newConfig);\n        } catch (error) {\n            return Promise.reject(error);\n        }\n        i = 0;\n        len = responseInterceptorChain.length;\n        while(i < len){\n            promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);\n        }\n        return promise;\n    }\n    getUri(config) {\n        config = mergeConfig(this.defaults, config);\n        const fullPath = buildFullPath(config.baseURL, config.url, config.allowAbsoluteUrls);\n        return buildURL(fullPath, config.params, config.paramsSerializer);\n    }\n}\n// Provide aliases for supported request methods\nutils$1.forEach([\n    \"delete\",\n    \"get\",\n    \"head\",\n    \"options\"\n], function forEachMethodNoData(method) {\n    /*eslint func-names:0*/ Axios.prototype[method] = function(url, config) {\n        return this.request(mergeConfig(config || {}, {\n            method,\n            url,\n            data: (config || {}).data\n        }));\n    };\n});\nutils$1.forEach([\n    \"post\",\n    \"put\",\n    \"patch\"\n], function forEachMethodWithData(method) {\n    /*eslint func-names:0*/ function generateHTTPMethod(isForm) {\n        return function httpMethod(url, data, config) {\n            return this.request(mergeConfig(config || {}, {\n                method,\n                headers: isForm ? {\n                    \"Content-Type\": \"multipart/form-data\"\n                } : {},\n                url,\n                data\n            }));\n        };\n    }\n    Axios.prototype[method] = generateHTTPMethod();\n    Axios.prototype[method + \"Form\"] = generateHTTPMethod(true);\n});\nconst Axios$1 = Axios;\n/**\n * A `CancelToken` is an object that can be used to request cancellation of an operation.\n *\n * @param {Function} executor The executor function.\n *\n * @returns {CancelToken}\n */ class CancelToken {\n    constructor(executor){\n        if (typeof executor !== \"function\") {\n            throw new TypeError(\"executor must be a function.\");\n        }\n        let resolvePromise;\n        this.promise = new Promise(function promiseExecutor(resolve) {\n            resolvePromise = resolve;\n        });\n        const token = this;\n        // eslint-disable-next-line func-names\n        this.promise.then((cancel)=>{\n            if (!token._listeners) return;\n            let i = token._listeners.length;\n            while(i-- > 0){\n                token._listeners[i](cancel);\n            }\n            token._listeners = null;\n        });\n        // eslint-disable-next-line func-names\n        this.promise.then = (onfulfilled)=>{\n            let _resolve;\n            // eslint-disable-next-line func-names\n            const promise = new Promise((resolve)=>{\n                token.subscribe(resolve);\n                _resolve = resolve;\n            }).then(onfulfilled);\n            promise.cancel = function reject() {\n                token.unsubscribe(_resolve);\n            };\n            return promise;\n        };\n        executor(function cancel(message, config, request) {\n            if (token.reason) {\n                // Cancellation has already been requested\n                return;\n            }\n            token.reason = new CanceledError$1(message, config, request);\n            resolvePromise(token.reason);\n        });\n    }\n    /**\n   * Throws a `CanceledError` if cancellation has been requested.\n   */ throwIfRequested() {\n        if (this.reason) {\n            throw this.reason;\n        }\n    }\n    /**\n   * Subscribe to the cancel signal\n   */ subscribe(listener) {\n        if (this.reason) {\n            listener(this.reason);\n            return;\n        }\n        if (this._listeners) {\n            this._listeners.push(listener);\n        } else {\n            this._listeners = [\n                listener\n            ];\n        }\n    }\n    /**\n   * Unsubscribe from the cancel signal\n   */ unsubscribe(listener) {\n        if (!this._listeners) {\n            return;\n        }\n        const index = this._listeners.indexOf(listener);\n        if (index !== -1) {\n            this._listeners.splice(index, 1);\n        }\n    }\n    toAbortSignal() {\n        const controller = new AbortController();\n        const abort = (err)=>{\n            controller.abort(err);\n        };\n        this.subscribe(abort);\n        controller.signal.unsubscribe = ()=>this.unsubscribe(abort);\n        return controller.signal;\n    }\n    /**\n   * Returns an object that contains a new `CancelToken` and a function that, when called,\n   * cancels the `CancelToken`.\n   */ static source() {\n        let cancel;\n        const token = new CancelToken(function executor(c) {\n            cancel = c;\n        });\n        return {\n            token,\n            cancel\n        };\n    }\n}\nconst CancelToken$1 = CancelToken;\n/**\n * Syntactic sugar for invoking a function and expanding an array for arguments.\n *\n * Common use case would be to use `Function.prototype.apply`.\n *\n *  ```js\n *  function f(x, y, z) {}\n *  const args = [1, 2, 3];\n *  f.apply(null, args);\n *  ```\n *\n * With `spread` this example can be re-written.\n *\n *  ```js\n *  spread(function(x, y, z) {})([1, 2, 3]);\n *  ```\n *\n * @param {Function} callback\n *\n * @returns {Function}\n */ function spread(callback) {\n    return function wrap(arr) {\n        return callback.apply(null, arr);\n    };\n}\n/**\n * Determines whether the payload is an error thrown by Axios\n *\n * @param {*} payload The value to test\n *\n * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false\n */ function isAxiosError(payload) {\n    return utils$1.isObject(payload) && payload.isAxiosError === true;\n}\nconst HttpStatusCode = {\n    Continue: 100,\n    SwitchingProtocols: 101,\n    Processing: 102,\n    EarlyHints: 103,\n    Ok: 200,\n    Created: 201,\n    Accepted: 202,\n    NonAuthoritativeInformation: 203,\n    NoContent: 204,\n    ResetContent: 205,\n    PartialContent: 206,\n    MultiStatus: 207,\n    AlreadyReported: 208,\n    ImUsed: 226,\n    MultipleChoices: 300,\n    MovedPermanently: 301,\n    Found: 302,\n    SeeOther: 303,\n    NotModified: 304,\n    UseProxy: 305,\n    Unused: 306,\n    TemporaryRedirect: 307,\n    PermanentRedirect: 308,\n    BadRequest: 400,\n    Unauthorized: 401,\n    PaymentRequired: 402,\n    Forbidden: 403,\n    NotFound: 404,\n    MethodNotAllowed: 405,\n    NotAcceptable: 406,\n    ProxyAuthenticationRequired: 407,\n    RequestTimeout: 408,\n    Conflict: 409,\n    Gone: 410,\n    LengthRequired: 411,\n    PreconditionFailed: 412,\n    PayloadTooLarge: 413,\n    UriTooLong: 414,\n    UnsupportedMediaType: 415,\n    RangeNotSatisfiable: 416,\n    ExpectationFailed: 417,\n    ImATeapot: 418,\n    MisdirectedRequest: 421,\n    UnprocessableEntity: 422,\n    Locked: 423,\n    FailedDependency: 424,\n    TooEarly: 425,\n    UpgradeRequired: 426,\n    PreconditionRequired: 428,\n    TooManyRequests: 429,\n    RequestHeaderFieldsTooLarge: 431,\n    UnavailableForLegalReasons: 451,\n    InternalServerError: 500,\n    NotImplemented: 501,\n    BadGateway: 502,\n    ServiceUnavailable: 503,\n    GatewayTimeout: 504,\n    HttpVersionNotSupported: 505,\n    VariantAlsoNegotiates: 506,\n    InsufficientStorage: 507,\n    LoopDetected: 508,\n    NotExtended: 510,\n    NetworkAuthenticationRequired: 511,\n    WebServerIsDown: 521,\n    ConnectionTimedOut: 522,\n    OriginIsUnreachable: 523,\n    TimeoutOccurred: 524,\n    SslHandshakeFailed: 525,\n    InvalidSslCertificate: 526\n};\nObject.entries(HttpStatusCode).forEach(([key, value])=>{\n    HttpStatusCode[value] = key;\n});\nconst HttpStatusCode$1 = HttpStatusCode;\n/**\n * Create an instance of Axios\n *\n * @param {Object} defaultConfig The default config for the instance\n *\n * @returns {Axios} A new instance of Axios\n */ function createInstance(defaultConfig) {\n    const context = new Axios$1(defaultConfig);\n    const instance = bind(Axios$1.prototype.request, context);\n    // Copy axios.prototype to instance\n    utils$1.extend(instance, Axios$1.prototype, context, {\n        allOwnKeys: true\n    });\n    // Copy context to instance\n    utils$1.extend(instance, context, null, {\n        allOwnKeys: true\n    });\n    // Factory for creating new instances\n    instance.create = function create(instanceConfig) {\n        return createInstance(mergeConfig(defaultConfig, instanceConfig));\n    };\n    return instance;\n}\n// Create the default instance to be exported\nconst axios = createInstance(defaults$1);\n// Expose Axios class to allow class inheritance\naxios.Axios = Axios$1;\n// Expose Cancel & CancelToken\naxios.CanceledError = CanceledError$1;\naxios.CancelToken = CancelToken$1;\naxios.isCancel = isCancel;\naxios.VERSION = VERSION;\naxios.toFormData = toFormData;\n// Expose AxiosError class\naxios.AxiosError = AxiosError$1;\n// alias for CanceledError for backward compatibility\naxios.Cancel = axios.CanceledError;\n// Expose all/spread\naxios.all = function all(promises) {\n    return Promise.all(promises);\n};\naxios.spread = spread;\n// Expose isAxiosError\naxios.isAxiosError = isAxiosError;\n// Expose mergeConfig\naxios.mergeConfig = mergeConfig;\naxios.AxiosHeaders = AxiosHeaders$1;\naxios.formToJSON = (thing)=>formDataToJSON(utils$1.isHTMLForm(thing) ? new FormData(thing) : thing);\naxios.getAdapter = adapters.getAdapter;\naxios.HttpStatusCode = HttpStatusCode$1;\naxios.default = axios;\nmodule.exports = axios; //# sourceMappingURL=axios.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYXhpb3MvZGlzdC9ub2RlL2F4aW9zLmNqcyIsIm1hcHBpbmdzIjoiQUFBQSxxRUFBcUUsR0FDckU7QUFFQSxNQUFNQSxhQUFhQyxtQkFBT0EsQ0FBQztBQUMzQixNQUFNQyxTQUFTRCxtQkFBT0EsQ0FBQztBQUN2QixNQUFNRSxNQUFNRixtQkFBT0EsQ0FBQztBQUNwQixNQUFNRyxlQUFlSCxtQkFBT0EsQ0FBQztBQUM3QixNQUFNSSxPQUFPSixtQkFBT0EsQ0FBQztBQUNyQixNQUFNSyxRQUFRTCxtQkFBT0EsQ0FBQztBQUN0QixNQUFNTSxRQUFRTixtQkFBT0EsQ0FBQztBQUN0QixNQUFNTyxPQUFPUCxtQkFBT0EsQ0FBQztBQUNyQixNQUFNUSxrQkFBa0JSLG1CQUFPQSxDQUFDO0FBQ2hDLE1BQU1TLE9BQU9ULG1CQUFPQSxDQUFDO0FBQ3JCLE1BQU1VLFNBQVNWLG1CQUFPQSxDQUFDO0FBQ3ZCLE1BQU1XLFNBQVNYLG1CQUFPQSxDQUFDO0FBRXZCLFNBQVNZLHNCQUF1QkMsQ0FBQztJQUFJLE9BQU9BLEtBQUssT0FBT0EsTUFBTSxZQUFZLGFBQWFBLElBQUlBLElBQUk7UUFBRSxXQUFXQTtJQUFFO0FBQUc7QUFFakgsTUFBTUMsb0JBQW9CLFdBQVcsR0FBRUYsc0JBQXNCYjtBQUM3RCxNQUFNZ0Isa0JBQWtCLFdBQVcsR0FBRUgsc0JBQXNCWDtBQUMzRCxNQUFNZSxlQUFlLFdBQVcsR0FBRUosc0JBQXNCVjtBQUN4RCxNQUFNZSx3QkFBd0IsV0FBVyxHQUFFTCxzQkFBc0JUO0FBQ2pFLE1BQU1lLGdCQUFnQixXQUFXLEdBQUVOLHNCQUFzQlI7QUFDekQsTUFBTWUsaUJBQWlCLFdBQVcsR0FBRVAsc0JBQXNCUDtBQUMxRCxNQUFNZSxpQkFBaUIsV0FBVyxHQUFFUixzQkFBc0JOO0FBQzFELE1BQU1lLGdCQUFnQixXQUFXLEdBQUVULHNCQUFzQkw7QUFDekQsTUFBTWUsMkJBQTJCLFdBQVcsR0FBRVYsc0JBQXNCSjtBQUNw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LE9BQU9DLE9BQU8sR0FBR04sT0FDakIsa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZmlkZHlmaWRkeS8uL25vZGVfbW9kdWxlcy9heGlvcy9kaXN0L25vZGUvYXhpb3MuY2pzP2MxMjUiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIEF4aW9zIHYxLjEzLjQgQ29weXJpZ2h0IChjKSAyMDI2IE1hdHQgWmFicmlza2llIGFuZCBjb250cmlidXRvcnMgKi9cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgRm9ybURhdGEkMSA9IHJlcXVpcmUoJ2Zvcm0tZGF0YScpO1xuY29uc3QgY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJyk7XG5jb25zdCB1cmwgPSByZXF1aXJlKCd1cmwnKTtcbmNvbnN0IHByb3h5RnJvbUVudiA9IHJlcXVpcmUoJ3Byb3h5LWZyb20tZW52Jyk7XG5jb25zdCBodHRwID0gcmVxdWlyZSgnaHR0cCcpO1xuY29uc3QgaHR0cHMgPSByZXF1aXJlKCdodHRwcycpO1xuY29uc3QgaHR0cDIgPSByZXF1aXJlKCdodHRwMicpO1xuY29uc3QgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbmNvbnN0IGZvbGxvd1JlZGlyZWN0cyA9IHJlcXVpcmUoJ2ZvbGxvdy1yZWRpcmVjdHMnKTtcbmNvbnN0IHpsaWIgPSByZXF1aXJlKCd6bGliJyk7XG5jb25zdCBzdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKTtcbmNvbnN0IGV2ZW50cyA9IHJlcXVpcmUoJ2V2ZW50cycpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcERlZmF1bHRMZWdhY3kgKGUpIHsgcmV0dXJuIGUgJiYgdHlwZW9mIGUgPT09ICdvYmplY3QnICYmICdkZWZhdWx0JyBpbiBlID8gZSA6IHsgJ2RlZmF1bHQnOiBlIH07IH1cblxuY29uc3QgRm9ybURhdGFfX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BEZWZhdWx0TGVnYWN5KEZvcm1EYXRhJDEpO1xuY29uc3QgY3J5cHRvX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19pbnRlcm9wRGVmYXVsdExlZ2FjeShjcnlwdG8pO1xuY29uc3QgdXJsX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19pbnRlcm9wRGVmYXVsdExlZ2FjeSh1cmwpO1xuY29uc3QgcHJveHlGcm9tRW52X19kZWZhdWx0ID0gLyojX19QVVJFX18qL19pbnRlcm9wRGVmYXVsdExlZ2FjeShwcm94eUZyb21FbnYpO1xuY29uc3QgaHR0cF9fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9faW50ZXJvcERlZmF1bHRMZWdhY3koaHR0cCk7XG5jb25zdCBodHRwc19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9faW50ZXJvcERlZmF1bHRMZWdhY3koaHR0cHMpO1xuY29uc3QgaHR0cDJfX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BEZWZhdWx0TGVnYWN5KGh0dHAyKTtcbmNvbnN0IHV0aWxfX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BEZWZhdWx0TGVnYWN5KHV0aWwpO1xuY29uc3QgZm9sbG93UmVkaXJlY3RzX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19pbnRlcm9wRGVmYXVsdExlZ2FjeShmb2xsb3dSZWRpcmVjdHMpO1xuY29uc3QgemxpYl9fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9faW50ZXJvcERlZmF1bHRMZWdhY3koemxpYik7XG5jb25zdCBzdHJlYW1fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BEZWZhdWx0TGVnYWN5KHN0cmVhbSk7XG5cbi8qKlxuICogQ3JlYXRlIGEgYm91bmQgdmVyc2lvbiBvZiBhIGZ1bmN0aW9uIHdpdGggYSBzcGVjaWZpZWQgYHRoaXNgIGNvbnRleHRcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAtIFRoZSBmdW5jdGlvbiB0byBiaW5kXG4gKiBAcGFyYW0geyp9IHRoaXNBcmcgLSBUaGUgdmFsdWUgdG8gYmUgcGFzc2VkIGFzIHRoZSBgdGhpc2AgcGFyYW1ldGVyXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IEEgbmV3IGZ1bmN0aW9uIHRoYXQgd2lsbCBjYWxsIHRoZSBvcmlnaW5hbCBmdW5jdGlvbiB3aXRoIHRoZSBzcGVjaWZpZWQgYHRoaXNgIGNvbnRleHRcbiAqL1xuZnVuY3Rpb24gYmluZChmbiwgdGhpc0FyZykge1xuICByZXR1cm4gZnVuY3Rpb24gd3JhcCgpIHtcbiAgICByZXR1cm4gZm4uYXBwbHkodGhpc0FyZywgYXJndW1lbnRzKTtcbiAgfTtcbn1cblxuLy8gdXRpbHMgaXMgYSBsaWJyYXJ5IG9mIGdlbmVyaWMgaGVscGVyIGZ1bmN0aW9ucyBub24tc3BlY2lmaWMgdG8gYXhpb3NcblxuY29uc3Qge3RvU3RyaW5nfSA9IE9iamVjdC5wcm90b3R5cGU7XG5jb25zdCB7Z2V0UHJvdG90eXBlT2Z9ID0gT2JqZWN0O1xuY29uc3Qge2l0ZXJhdG9yLCB0b1N0cmluZ1RhZ30gPSBTeW1ib2w7XG5cbmNvbnN0IGtpbmRPZiA9IChjYWNoZSA9PiB0aGluZyA9PiB7XG4gICAgY29uc3Qgc3RyID0gdG9TdHJpbmcuY2FsbCh0aGluZyk7XG4gICAgcmV0dXJuIGNhY2hlW3N0cl0gfHwgKGNhY2hlW3N0cl0gPSBzdHIuc2xpY2UoOCwgLTEpLnRvTG93ZXJDYXNlKCkpO1xufSkoT2JqZWN0LmNyZWF0ZShudWxsKSk7XG5cbmNvbnN0IGtpbmRPZlRlc3QgPSAodHlwZSkgPT4ge1xuICB0eXBlID0gdHlwZS50b0xvd2VyQ2FzZSgpO1xuICByZXR1cm4gKHRoaW5nKSA9PiBraW5kT2YodGhpbmcpID09PSB0eXBlXG59O1xuXG5jb25zdCB0eXBlT2ZUZXN0ID0gdHlwZSA9PiB0aGluZyA9PiB0eXBlb2YgdGhpbmcgPT09IHR5cGU7XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYW4gQXJyYXlcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYW4gQXJyYXksIG90aGVyd2lzZSBmYWxzZVxuICovXG5jb25zdCB7aXNBcnJheX0gPSBBcnJheTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyB1bmRlZmluZWRcbiAqXG4gKiBAcGFyYW0geyp9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSB2YWx1ZSBpcyB1bmRlZmluZWQsIG90aGVyd2lzZSBmYWxzZVxuICovXG5jb25zdCBpc1VuZGVmaW5lZCA9IHR5cGVPZlRlc3QoJ3VuZGVmaW5lZCcpO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgQnVmZmVyXG4gKlxuICogQHBhcmFtIHsqfSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEJ1ZmZlciwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQnVmZmVyKHZhbCkge1xuICByZXR1cm4gdmFsICE9PSBudWxsICYmICFpc1VuZGVmaW5lZCh2YWwpICYmIHZhbC5jb25zdHJ1Y3RvciAhPT0gbnVsbCAmJiAhaXNVbmRlZmluZWQodmFsLmNvbnN0cnVjdG9yKVxuICAgICYmIGlzRnVuY3Rpb24kMSh2YWwuY29uc3RydWN0b3IuaXNCdWZmZXIpICYmIHZhbC5jb25zdHJ1Y3Rvci5pc0J1ZmZlcih2YWwpO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGFuIEFycmF5QnVmZmVyXG4gKlxuICogQHBhcmFtIHsqfSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhbiBBcnJheUJ1ZmZlciwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmNvbnN0IGlzQXJyYXlCdWZmZXIgPSBraW5kT2ZUZXN0KCdBcnJheUJ1ZmZlcicpO1xuXG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSB2aWV3IG9uIGFuIEFycmF5QnVmZmVyXG4gKlxuICogQHBhcmFtIHsqfSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIHZpZXcgb24gYW4gQXJyYXlCdWZmZXIsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5QnVmZmVyVmlldyh2YWwpIHtcbiAgbGV0IHJlc3VsdDtcbiAgaWYgKCh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnKSAmJiAoQXJyYXlCdWZmZXIuaXNWaWV3KSkge1xuICAgIHJlc3VsdCA9IEFycmF5QnVmZmVyLmlzVmlldyh2YWwpO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdCA9ICh2YWwpICYmICh2YWwuYnVmZmVyKSAmJiAoaXNBcnJheUJ1ZmZlcih2YWwuYnVmZmVyKSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIFN0cmluZ1xuICpcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBTdHJpbmcsIG90aGVyd2lzZSBmYWxzZVxuICovXG5jb25zdCBpc1N0cmluZyA9IHR5cGVPZlRlc3QoJ3N0cmluZycpO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRnVuY3Rpb25cbiAqXG4gKiBAcGFyYW0geyp9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBGdW5jdGlvbiwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmNvbnN0IGlzRnVuY3Rpb24kMSA9IHR5cGVPZlRlc3QoJ2Z1bmN0aW9uJyk7XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBOdW1iZXJcbiAqXG4gKiBAcGFyYW0geyp9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgTnVtYmVyLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuY29uc3QgaXNOdW1iZXIgPSB0eXBlT2ZUZXN0KCdudW1iZXInKTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhbiBPYmplY3RcbiAqXG4gKiBAcGFyYW0geyp9IHRoaW5nIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYW4gT2JqZWN0LCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuY29uc3QgaXNPYmplY3QgPSAodGhpbmcpID0+IHRoaW5nICE9PSBudWxsICYmIHR5cGVvZiB0aGluZyA9PT0gJ29iamVjdCc7XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBCb29sZWFuXG4gKlxuICogQHBhcmFtIHsqfSB0aGluZyBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBCb29sZWFuLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuY29uc3QgaXNCb29sZWFuID0gdGhpbmcgPT4gdGhpbmcgPT09IHRydWUgfHwgdGhpbmcgPT09IGZhbHNlO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgcGxhaW4gT2JqZWN0XG4gKlxuICogQHBhcmFtIHsqfSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIHBsYWluIE9iamVjdCwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmNvbnN0IGlzUGxhaW5PYmplY3QgPSAodmFsKSA9PiB7XG4gIGlmIChraW5kT2YodmFsKSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBjb25zdCBwcm90b3R5cGUgPSBnZXRQcm90b3R5cGVPZih2YWwpO1xuICByZXR1cm4gKHByb3RvdHlwZSA9PT0gbnVsbCB8fCBwcm90b3R5cGUgPT09IE9iamVjdC5wcm90b3R5cGUgfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvdHlwZSkgPT09IG51bGwpICYmICEodG9TdHJpbmdUYWcgaW4gdmFsKSAmJiAhKGl0ZXJhdG9yIGluIHZhbCk7XG59O1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGFuIGVtcHR5IG9iamVjdCAoc2FmZWx5IGhhbmRsZXMgQnVmZmVycylcbiAqXG4gKiBAcGFyYW0geyp9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGFuIGVtcHR5IG9iamVjdCwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmNvbnN0IGlzRW1wdHlPYmplY3QgPSAodmFsKSA9PiB7XG4gIC8vIEVhcmx5IHJldHVybiBmb3Igbm9uLW9iamVjdHMgb3IgQnVmZmVycyB0byBwcmV2ZW50IFJhbmdlRXJyb3JcbiAgaWYgKCFpc09iamVjdCh2YWwpIHx8IGlzQnVmZmVyKHZhbCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB0cnkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyh2YWwpLmxlbmd0aCA9PT0gMCAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsKSA9PT0gT2JqZWN0LnByb3RvdHlwZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIEZhbGxiYWNrIGZvciBhbnkgb3RoZXIgb2JqZWN0cyB0aGF0IG1pZ2h0IGNhdXNlIFJhbmdlRXJyb3Igd2l0aCBPYmplY3Qua2V5cygpXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRGF0ZVxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBEYXRlLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuY29uc3QgaXNEYXRlID0ga2luZE9mVGVzdCgnRGF0ZScpO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRmlsZVxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBGaWxlLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuY29uc3QgaXNGaWxlID0ga2luZE9mVGVzdCgnRmlsZScpO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgQmxvYlxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBCbG9iLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuY29uc3QgaXNCbG9iID0ga2luZE9mVGVzdCgnQmxvYicpO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRmlsZUxpc3RcbiAqXG4gKiBAcGFyYW0geyp9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgRmlsZSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmNvbnN0IGlzRmlsZUxpc3QgPSBraW5kT2ZUZXN0KCdGaWxlTGlzdCcpO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgU3RyZWFtXG4gKlxuICogQHBhcmFtIHsqfSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIFN0cmVhbSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmNvbnN0IGlzU3RyZWFtID0gKHZhbCkgPT4gaXNPYmplY3QodmFsKSAmJiBpc0Z1bmN0aW9uJDEodmFsLnBpcGUpO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRm9ybURhdGFcbiAqXG4gKiBAcGFyYW0geyp9IHRoaW5nIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYW4gRm9ybURhdGEsIG90aGVyd2lzZSBmYWxzZVxuICovXG5jb25zdCBpc0Zvcm1EYXRhID0gKHRoaW5nKSA9PiB7XG4gIGxldCBraW5kO1xuICByZXR1cm4gdGhpbmcgJiYgKFxuICAgICh0eXBlb2YgRm9ybURhdGEgPT09ICdmdW5jdGlvbicgJiYgdGhpbmcgaW5zdGFuY2VvZiBGb3JtRGF0YSkgfHwgKFxuICAgICAgaXNGdW5jdGlvbiQxKHRoaW5nLmFwcGVuZCkgJiYgKFxuICAgICAgICAoa2luZCA9IGtpbmRPZih0aGluZykpID09PSAnZm9ybWRhdGEnIHx8XG4gICAgICAgIC8vIGRldGVjdCBmb3JtLWRhdGEgaW5zdGFuY2VcbiAgICAgICAgKGtpbmQgPT09ICdvYmplY3QnICYmIGlzRnVuY3Rpb24kMSh0aGluZy50b1N0cmluZykgJiYgdGhpbmcudG9TdHJpbmcoKSA9PT0gJ1tvYmplY3QgRm9ybURhdGFdJylcbiAgICAgIClcbiAgICApXG4gIClcbn07XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBVUkxTZWFyY2hQYXJhbXMgb2JqZWN0XG4gKlxuICogQHBhcmFtIHsqfSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIFVSTFNlYXJjaFBhcmFtcyBvYmplY3QsIG90aGVyd2lzZSBmYWxzZVxuICovXG5jb25zdCBpc1VSTFNlYXJjaFBhcmFtcyA9IGtpbmRPZlRlc3QoJ1VSTFNlYXJjaFBhcmFtcycpO1xuXG5jb25zdCBbaXNSZWFkYWJsZVN0cmVhbSwgaXNSZXF1ZXN0LCBpc1Jlc3BvbnNlLCBpc0hlYWRlcnNdID0gWydSZWFkYWJsZVN0cmVhbScsICdSZXF1ZXN0JywgJ1Jlc3BvbnNlJywgJ0hlYWRlcnMnXS5tYXAoa2luZE9mVGVzdCk7XG5cbi8qKlxuICogVHJpbSBleGNlc3Mgd2hpdGVzcGFjZSBvZmYgdGhlIGJlZ2lubmluZyBhbmQgZW5kIG9mIGEgc3RyaW5nXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciBUaGUgU3RyaW5nIHRvIHRyaW1cbiAqXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgU3RyaW5nIGZyZWVkIG9mIGV4Y2VzcyB3aGl0ZXNwYWNlXG4gKi9cbmNvbnN0IHRyaW0gPSAoc3RyKSA9PiBzdHIudHJpbSA/XG4gIHN0ci50cmltKCkgOiBzdHIucmVwbGFjZSgvXltcXHNcXHVGRUZGXFx4QTBdK3xbXFxzXFx1RkVGRlxceEEwXSskL2csICcnKTtcblxuLyoqXG4gKiBJdGVyYXRlIG92ZXIgYW4gQXJyYXkgb3IgYW4gT2JqZWN0IGludm9raW5nIGEgZnVuY3Rpb24gZm9yIGVhY2ggaXRlbS5cbiAqXG4gKiBJZiBgb2JqYCBpcyBhbiBBcnJheSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBwYXNzaW5nXG4gKiB0aGUgdmFsdWUsIGluZGV4LCBhbmQgY29tcGxldGUgYXJyYXkgZm9yIGVhY2ggaXRlbS5cbiAqXG4gKiBJZiAnb2JqJyBpcyBhbiBPYmplY3QgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgcGFzc2luZ1xuICogdGhlIHZhbHVlLCBrZXksIGFuZCBjb21wbGV0ZSBvYmplY3QgZm9yIGVhY2ggcHJvcGVydHkuXG4gKlxuICogQHBhcmFtIHtPYmplY3R8QXJyYXk8dW5rbm93bj59IG9iaiBUaGUgb2JqZWN0IHRvIGl0ZXJhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBjYWxsYmFjayB0byBpbnZva2UgZm9yIGVhY2ggaXRlbVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuYWxsT3duS2V5cyA9IGZhbHNlXVxuICogQHJldHVybnMge2FueX1cbiAqL1xuZnVuY3Rpb24gZm9yRWFjaChvYmosIGZuLCB7YWxsT3duS2V5cyA9IGZhbHNlfSA9IHt9KSB7XG4gIC8vIERvbid0IGJvdGhlciBpZiBubyB2YWx1ZSBwcm92aWRlZFxuICBpZiAob2JqID09PSBudWxsIHx8IHR5cGVvZiBvYmogPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgbGV0IGk7XG4gIGxldCBsO1xuXG4gIC8vIEZvcmNlIGFuIGFycmF5IGlmIG5vdCBhbHJlYWR5IHNvbWV0aGluZyBpdGVyYWJsZVxuICBpZiAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpIHtcbiAgICAvKmVzbGludCBuby1wYXJhbS1yZWFzc2lnbjowKi9cbiAgICBvYmogPSBbb2JqXTtcbiAgfVxuXG4gIGlmIChpc0FycmF5KG9iaikpIHtcbiAgICAvLyBJdGVyYXRlIG92ZXIgYXJyYXkgdmFsdWVzXG4gICAgZm9yIChpID0gMCwgbCA9IG9iai5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGZuLmNhbGwobnVsbCwgb2JqW2ldLCBpLCBvYmopO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBCdWZmZXIgY2hlY2tcbiAgICBpZiAoaXNCdWZmZXIob2JqKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEl0ZXJhdGUgb3ZlciBvYmplY3Qga2V5c1xuICAgIGNvbnN0IGtleXMgPSBhbGxPd25LZXlzID8gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob2JqKSA6IE9iamVjdC5rZXlzKG9iaik7XG4gICAgY29uc3QgbGVuID0ga2V5cy5sZW5ndGg7XG4gICAgbGV0IGtleTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgIGZuLmNhbGwobnVsbCwgb2JqW2tleV0sIGtleSwgb2JqKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluZEtleShvYmosIGtleSkge1xuICBpZiAoaXNCdWZmZXIob2JqKSl7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBrZXkgPSBrZXkudG9Mb3dlckNhc2UoKTtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gIGxldCBpID0ga2V5cy5sZW5ndGg7XG4gIGxldCBfa2V5O1xuICB3aGlsZSAoaS0tID4gMCkge1xuICAgIF9rZXkgPSBrZXlzW2ldO1xuICAgIGlmIChrZXkgPT09IF9rZXkudG9Mb3dlckNhc2UoKSkge1xuICAgICAgcmV0dXJuIF9rZXk7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG5jb25zdCBfZ2xvYmFsID0gKCgpID0+IHtcbiAgLyplc2xpbnQgbm8tdW5kZWY6MCovXG4gIGlmICh0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuIGdsb2JhbFRoaXM7XG4gIHJldHVybiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiBnbG9iYWwpXG59KSgpO1xuXG5jb25zdCBpc0NvbnRleHREZWZpbmVkID0gKGNvbnRleHQpID0+ICFpc1VuZGVmaW5lZChjb250ZXh0KSAmJiBjb250ZXh0ICE9PSBfZ2xvYmFsO1xuXG4vKipcbiAqIEFjY2VwdHMgdmFyYXJncyBleHBlY3RpbmcgZWFjaCBhcmd1bWVudCB0byBiZSBhbiBvYmplY3QsIHRoZW5cbiAqIGltbXV0YWJseSBtZXJnZXMgdGhlIHByb3BlcnRpZXMgb2YgZWFjaCBvYmplY3QgYW5kIHJldHVybnMgcmVzdWx0LlxuICpcbiAqIFdoZW4gbXVsdGlwbGUgb2JqZWN0cyBjb250YWluIHRoZSBzYW1lIGtleSB0aGUgbGF0ZXIgb2JqZWN0IGluXG4gKiB0aGUgYXJndW1lbnRzIGxpc3Qgd2lsbCB0YWtlIHByZWNlZGVuY2UuXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiBgYGBqc1xuICogY29uc3QgcmVzdWx0ID0gbWVyZ2Uoe2ZvbzogMTIzfSwge2ZvbzogNDU2fSk7XG4gKiBjb25zb2xlLmxvZyhyZXN1bHQuZm9vKTsgLy8gb3V0cHV0cyA0NTZcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmoxIE9iamVjdCB0byBtZXJnZVxuICpcbiAqIEByZXR1cm5zIHtPYmplY3R9IFJlc3VsdCBvZiBhbGwgbWVyZ2UgcHJvcGVydGllc1xuICovXG5mdW5jdGlvbiBtZXJnZSgvKiBvYmoxLCBvYmoyLCBvYmozLCAuLi4gKi8pIHtcbiAgY29uc3Qge2Nhc2VsZXNzLCBza2lwVW5kZWZpbmVkfSA9IGlzQ29udGV4dERlZmluZWQodGhpcykgJiYgdGhpcyB8fCB7fTtcbiAgY29uc3QgcmVzdWx0ID0ge307XG4gIGNvbnN0IGFzc2lnblZhbHVlID0gKHZhbCwga2V5KSA9PiB7XG4gICAgY29uc3QgdGFyZ2V0S2V5ID0gY2FzZWxlc3MgJiYgZmluZEtleShyZXN1bHQsIGtleSkgfHwga2V5O1xuICAgIGlmIChpc1BsYWluT2JqZWN0KHJlc3VsdFt0YXJnZXRLZXldKSAmJiBpc1BsYWluT2JqZWN0KHZhbCkpIHtcbiAgICAgIHJlc3VsdFt0YXJnZXRLZXldID0gbWVyZ2UocmVzdWx0W3RhcmdldEtleV0sIHZhbCk7XG4gICAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHZhbCkpIHtcbiAgICAgIHJlc3VsdFt0YXJnZXRLZXldID0gbWVyZ2Uoe30sIHZhbCk7XG4gICAgfSBlbHNlIGlmIChpc0FycmF5KHZhbCkpIHtcbiAgICAgIHJlc3VsdFt0YXJnZXRLZXldID0gdmFsLnNsaWNlKCk7XG4gICAgfSBlbHNlIGlmICghc2tpcFVuZGVmaW5lZCB8fCAhaXNVbmRlZmluZWQodmFsKSkge1xuICAgICAgcmVzdWx0W3RhcmdldEtleV0gPSB2YWw7XG4gICAgfVxuICB9O1xuXG4gIGZvciAobGV0IGkgPSAwLCBsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGFyZ3VtZW50c1tpXSAmJiBmb3JFYWNoKGFyZ3VtZW50c1tpXSwgYXNzaWduVmFsdWUpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogRXh0ZW5kcyBvYmplY3QgYSBieSBtdXRhYmx5IGFkZGluZyB0byBpdCB0aGUgcHJvcGVydGllcyBvZiBvYmplY3QgYi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYSBUaGUgb2JqZWN0IHRvIGJlIGV4dGVuZGVkXG4gKiBAcGFyYW0ge09iamVjdH0gYiBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyBmcm9tXG4gKiBAcGFyYW0ge09iamVjdH0gdGhpc0FyZyBUaGUgb2JqZWN0IHRvIGJpbmQgZnVuY3Rpb24gdG9cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmFsbE93bktleXNdXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgcmVzdWx0aW5nIHZhbHVlIG9mIG9iamVjdCBhXG4gKi9cbmNvbnN0IGV4dGVuZCA9IChhLCBiLCB0aGlzQXJnLCB7YWxsT3duS2V5c309IHt9KSA9PiB7XG4gIGZvckVhY2goYiwgKHZhbCwga2V5KSA9PiB7XG4gICAgaWYgKHRoaXNBcmcgJiYgaXNGdW5jdGlvbiQxKHZhbCkpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhLCBrZXksIHtcbiAgICAgICAgdmFsdWU6IGJpbmQodmFsLCB0aGlzQXJnKSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhLCBrZXksIHtcbiAgICAgICAgdmFsdWU6IHZhbCxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7YWxsT3duS2V5c30pO1xuICByZXR1cm4gYTtcbn07XG5cbi8qKlxuICogUmVtb3ZlIGJ5dGUgb3JkZXIgbWFya2VyLiBUaGlzIGNhdGNoZXMgRUYgQkIgQkYgKHRoZSBVVEYtOCBCT00pXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbnRlbnQgd2l0aCBCT01cbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBjb250ZW50IHZhbHVlIHdpdGhvdXQgQk9NXG4gKi9cbmNvbnN0IHN0cmlwQk9NID0gKGNvbnRlbnQpID0+IHtcbiAgaWYgKGNvbnRlbnQuY2hhckNvZGVBdCgwKSA9PT0gMHhGRUZGKSB7XG4gICAgY29udGVudCA9IGNvbnRlbnQuc2xpY2UoMSk7XG4gIH1cbiAgcmV0dXJuIGNvbnRlbnQ7XG59O1xuXG4vKipcbiAqIEluaGVyaXQgdGhlIHByb3RvdHlwZSBtZXRob2RzIGZyb20gb25lIGNvbnN0cnVjdG9yIGludG8gYW5vdGhlclxuICogQHBhcmFtIHtmdW5jdGlvbn0gY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHN1cGVyQ29uc3RydWN0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBbcHJvcHNdXG4gKiBAcGFyYW0ge29iamVjdH0gW2Rlc2NyaXB0b3JzXVxuICpcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5jb25zdCBpbmhlcml0cyA9IChjb25zdHJ1Y3Rvciwgc3VwZXJDb25zdHJ1Y3RvciwgcHJvcHMsIGRlc2NyaXB0b3JzKSA9PiB7XG4gIGNvbnN0cnVjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIGRlc2NyaXB0b3JzKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvbnN0cnVjdG9yLnByb3RvdHlwZSwgJ2NvbnN0cnVjdG9yJywge1xuICAgIHZhbHVlOiBjb25zdHJ1Y3RvcixcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb25zdHJ1Y3RvciwgJ3N1cGVyJywge1xuICAgIHZhbHVlOiBzdXBlckNvbnN0cnVjdG9yLnByb3RvdHlwZVxuICB9KTtcbiAgcHJvcHMgJiYgT2JqZWN0LmFzc2lnbihjb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3BzKTtcbn07XG5cbi8qKlxuICogUmVzb2x2ZSBvYmplY3Qgd2l0aCBkZWVwIHByb3RvdHlwZSBjaGFpbiB0byBhIGZsYXQgb2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlT2JqIHNvdXJjZSBvYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBbZGVzdE9ial1cbiAqIEBwYXJhbSB7RnVuY3Rpb258Qm9vbGVhbn0gW2ZpbHRlcl1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcm9wRmlsdGVyXVxuICpcbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKi9cbmNvbnN0IHRvRmxhdE9iamVjdCA9IChzb3VyY2VPYmosIGRlc3RPYmosIGZpbHRlciwgcHJvcEZpbHRlcikgPT4ge1xuICBsZXQgcHJvcHM7XG4gIGxldCBpO1xuICBsZXQgcHJvcDtcbiAgY29uc3QgbWVyZ2VkID0ge307XG5cbiAgZGVzdE9iaiA9IGRlc3RPYmogfHwge307XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1lcS1udWxsLGVxZXFlcVxuICBpZiAoc291cmNlT2JqID09IG51bGwpIHJldHVybiBkZXN0T2JqO1xuXG4gIGRvIHtcbiAgICBwcm9wcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHNvdXJjZU9iaik7XG4gICAgaSA9IHByb3BzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tID4gMCkge1xuICAgICAgcHJvcCA9IHByb3BzW2ldO1xuICAgICAgaWYgKCghcHJvcEZpbHRlciB8fCBwcm9wRmlsdGVyKHByb3AsIHNvdXJjZU9iaiwgZGVzdE9iaikpICYmICFtZXJnZWRbcHJvcF0pIHtcbiAgICAgICAgZGVzdE9ialtwcm9wXSA9IHNvdXJjZU9ialtwcm9wXTtcbiAgICAgICAgbWVyZ2VkW3Byb3BdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgc291cmNlT2JqID0gZmlsdGVyICE9PSBmYWxzZSAmJiBnZXRQcm90b3R5cGVPZihzb3VyY2VPYmopO1xuICB9IHdoaWxlIChzb3VyY2VPYmogJiYgKCFmaWx0ZXIgfHwgZmlsdGVyKHNvdXJjZU9iaiwgZGVzdE9iaikpICYmIHNvdXJjZU9iaiAhPT0gT2JqZWN0LnByb3RvdHlwZSk7XG5cbiAgcmV0dXJuIGRlc3RPYmo7XG59O1xuXG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciBhIHN0cmluZyBlbmRzIHdpdGggdGhlIGNoYXJhY3RlcnMgb2YgYSBzcGVjaWZpZWQgc3RyaW5nXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHBhcmFtIHtTdHJpbmd9IHNlYXJjaFN0cmluZ1xuICogQHBhcmFtIHtOdW1iZXJ9IFtwb3NpdGlvbj0gMF1cbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuY29uc3QgZW5kc1dpdGggPSAoc3RyLCBzZWFyY2hTdHJpbmcsIHBvc2l0aW9uKSA9PiB7XG4gIHN0ciA9IFN0cmluZyhzdHIpO1xuICBpZiAocG9zaXRpb24gPT09IHVuZGVmaW5lZCB8fCBwb3NpdGlvbiA+IHN0ci5sZW5ndGgpIHtcbiAgICBwb3NpdGlvbiA9IHN0ci5sZW5ndGg7XG4gIH1cbiAgcG9zaXRpb24gLT0gc2VhcmNoU3RyaW5nLmxlbmd0aDtcbiAgY29uc3QgbGFzdEluZGV4ID0gc3RyLmluZGV4T2Yoc2VhcmNoU3RyaW5nLCBwb3NpdGlvbik7XG4gIHJldHVybiBsYXN0SW5kZXggIT09IC0xICYmIGxhc3RJbmRleCA9PT0gcG9zaXRpb247XG59O1xuXG5cbi8qKlxuICogUmV0dXJucyBuZXcgYXJyYXkgZnJvbSBhcnJheSBsaWtlIG9iamVjdCBvciBudWxsIGlmIGZhaWxlZFxuICpcbiAqIEBwYXJhbSB7Kn0gW3RoaW5nXVxuICpcbiAqIEByZXR1cm5zIHs/QXJyYXl9XG4gKi9cbmNvbnN0IHRvQXJyYXkgPSAodGhpbmcpID0+IHtcbiAgaWYgKCF0aGluZykgcmV0dXJuIG51bGw7XG4gIGlmIChpc0FycmF5KHRoaW5nKSkgcmV0dXJuIHRoaW5nO1xuICBsZXQgaSA9IHRoaW5nLmxlbmd0aDtcbiAgaWYgKCFpc051bWJlcihpKSkgcmV0dXJuIG51bGw7XG4gIGNvbnN0IGFyciA9IG5ldyBBcnJheShpKTtcbiAgd2hpbGUgKGktLSA+IDApIHtcbiAgICBhcnJbaV0gPSB0aGluZ1tpXTtcbiAgfVxuICByZXR1cm4gYXJyO1xufTtcblxuLyoqXG4gKiBDaGVja2luZyBpZiB0aGUgVWludDhBcnJheSBleGlzdHMgYW5kIGlmIGl0IGRvZXMsIGl0IHJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGNoZWNrcyBpZiB0aGVcbiAqIHRoaW5nIHBhc3NlZCBpbiBpcyBhbiBpbnN0YW5jZSBvZiBVaW50OEFycmF5XG4gKlxuICogQHBhcmFtIHtUeXBlZEFycmF5fVxuICpcbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcbmNvbnN0IGlzVHlwZWRBcnJheSA9IChUeXBlZEFycmF5ID0+IHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcbiAgcmV0dXJuIHRoaW5nID0+IHtcbiAgICByZXR1cm4gVHlwZWRBcnJheSAmJiB0aGluZyBpbnN0YW5jZW9mIFR5cGVkQXJyYXk7XG4gIH07XG59KSh0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcgJiYgZ2V0UHJvdG90eXBlT2YoVWludDhBcnJheSkpO1xuXG4vKipcbiAqIEZvciBlYWNoIGVudHJ5IGluIHRoZSBvYmplY3QsIGNhbGwgdGhlIGZ1bmN0aW9uIHdpdGggdGhlIGtleSBhbmQgdmFsdWUuXG4gKlxuICogQHBhcmFtIHtPYmplY3Q8YW55LCBhbnk+fSBvYmogLSBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIC0gVGhlIGZ1bmN0aW9uIHRvIGNhbGwgZm9yIGVhY2ggZW50cnkuXG4gKlxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmNvbnN0IGZvckVhY2hFbnRyeSA9IChvYmosIGZuKSA9PiB7XG4gIGNvbnN0IGdlbmVyYXRvciA9IG9iaiAmJiBvYmpbaXRlcmF0b3JdO1xuXG4gIGNvbnN0IF9pdGVyYXRvciA9IGdlbmVyYXRvci5jYWxsKG9iaik7XG5cbiAgbGV0IHJlc3VsdDtcblxuICB3aGlsZSAoKHJlc3VsdCA9IF9pdGVyYXRvci5uZXh0KCkpICYmICFyZXN1bHQuZG9uZSkge1xuICAgIGNvbnN0IHBhaXIgPSByZXN1bHQudmFsdWU7XG4gICAgZm4uY2FsbChvYmosIHBhaXJbMF0sIHBhaXJbMV0pO1xuICB9XG59O1xuXG4vKipcbiAqIEl0IHRha2VzIGEgcmVndWxhciBleHByZXNzaW9uIGFuZCBhIHN0cmluZywgYW5kIHJldHVybnMgYW4gYXJyYXkgb2YgYWxsIHRoZSBtYXRjaGVzXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHJlZ0V4cCAtIFRoZSByZWd1bGFyIGV4cHJlc3Npb24gdG8gbWF0Y2ggYWdhaW5zdC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgLSBUaGUgc3RyaW5nIHRvIHNlYXJjaC5cbiAqXG4gKiBAcmV0dXJucyB7QXJyYXk8Ym9vbGVhbj59XG4gKi9cbmNvbnN0IG1hdGNoQWxsID0gKHJlZ0V4cCwgc3RyKSA9PiB7XG4gIGxldCBtYXRjaGVzO1xuICBjb25zdCBhcnIgPSBbXTtcblxuICB3aGlsZSAoKG1hdGNoZXMgPSByZWdFeHAuZXhlYyhzdHIpKSAhPT0gbnVsbCkge1xuICAgIGFyci5wdXNoKG1hdGNoZXMpO1xuICB9XG5cbiAgcmV0dXJuIGFycjtcbn07XG5cbi8qIENoZWNraW5nIGlmIHRoZSBraW5kT2ZUZXN0IGZ1bmN0aW9uIHJldHVybnMgdHJ1ZSB3aGVuIHBhc3NlZCBhbiBIVE1MRm9ybUVsZW1lbnQuICovXG5jb25zdCBpc0hUTUxGb3JtID0ga2luZE9mVGVzdCgnSFRNTEZvcm1FbGVtZW50Jyk7XG5cbmNvbnN0IHRvQ2FtZWxDYXNlID0gc3RyID0+IHtcbiAgcmV0dXJuIHN0ci50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL1stX1xcc10oW2EtelxcZF0pKFxcdyopL2csXG4gICAgZnVuY3Rpb24gcmVwbGFjZXIobSwgcDEsIHAyKSB7XG4gICAgICByZXR1cm4gcDEudG9VcHBlckNhc2UoKSArIHAyO1xuICAgIH1cbiAgKTtcbn07XG5cbi8qIENyZWF0aW5nIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGNoZWNrIGlmIGFuIG9iamVjdCBoYXMgYSBwcm9wZXJ0eS4gKi9cbmNvbnN0IGhhc093blByb3BlcnR5ID0gKCh7aGFzT3duUHJvcGVydHl9KSA9PiAob2JqLCBwcm9wKSA9PiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCkpKE9iamVjdC5wcm90b3R5cGUpO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgUmVnRXhwIG9iamVjdFxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBSZWdFeHAgb2JqZWN0LCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuY29uc3QgaXNSZWdFeHAgPSBraW5kT2ZUZXN0KCdSZWdFeHAnKTtcblxuY29uc3QgcmVkdWNlRGVzY3JpcHRvcnMgPSAob2JqLCByZWR1Y2VyKSA9PiB7XG4gIGNvbnN0IGRlc2NyaXB0b3JzID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMob2JqKTtcbiAgY29uc3QgcmVkdWNlZERlc2NyaXB0b3JzID0ge307XG5cbiAgZm9yRWFjaChkZXNjcmlwdG9ycywgKGRlc2NyaXB0b3IsIG5hbWUpID0+IHtcbiAgICBsZXQgcmV0O1xuICAgIGlmICgocmV0ID0gcmVkdWNlcihkZXNjcmlwdG9yLCBuYW1lLCBvYmopKSAhPT0gZmFsc2UpIHtcbiAgICAgIHJlZHVjZWREZXNjcmlwdG9yc1tuYW1lXSA9IHJldCB8fCBkZXNjcmlwdG9yO1xuICAgIH1cbiAgfSk7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMob2JqLCByZWR1Y2VkRGVzY3JpcHRvcnMpO1xufTtcblxuLyoqXG4gKiBNYWtlcyBhbGwgbWV0aG9kcyByZWFkLW9ubHlcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqL1xuXG5jb25zdCBmcmVlemVNZXRob2RzID0gKG9iaikgPT4ge1xuICByZWR1Y2VEZXNjcmlwdG9ycyhvYmosIChkZXNjcmlwdG9yLCBuYW1lKSA9PiB7XG4gICAgLy8gc2tpcCByZXN0cmljdGVkIHByb3BzIGluIHN0cmljdCBtb2RlXG4gICAgaWYgKGlzRnVuY3Rpb24kMShvYmopICYmIFsnYXJndW1lbnRzJywgJ2NhbGxlcicsICdjYWxsZWUnXS5pbmRleE9mKG5hbWUpICE9PSAtMSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IHZhbHVlID0gb2JqW25hbWVdO1xuXG4gICAgaWYgKCFpc0Z1bmN0aW9uJDEodmFsdWUpKSByZXR1cm47XG5cbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBmYWxzZTtcblxuICAgIGlmICgnd3JpdGFibGUnIGluIGRlc2NyaXB0b3IpIHtcbiAgICAgIGRlc2NyaXB0b3Iud3JpdGFibGUgPSBmYWxzZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIWRlc2NyaXB0b3Iuc2V0KSB7XG4gICAgICBkZXNjcmlwdG9yLnNldCA9ICgpID0+IHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ0NhbiBub3QgcmV3cml0ZSByZWFkLW9ubHkgbWV0aG9kIFxcJycgKyBuYW1lICsgJ1xcJycpO1xuICAgICAgfTtcbiAgICB9XG4gIH0pO1xufTtcblxuY29uc3QgdG9PYmplY3RTZXQgPSAoYXJyYXlPclN0cmluZywgZGVsaW1pdGVyKSA9PiB7XG4gIGNvbnN0IG9iaiA9IHt9O1xuXG4gIGNvbnN0IGRlZmluZSA9IChhcnIpID0+IHtcbiAgICBhcnIuZm9yRWFjaCh2YWx1ZSA9PiB7XG4gICAgICBvYmpbdmFsdWVdID0gdHJ1ZTtcbiAgICB9KTtcbiAgfTtcblxuICBpc0FycmF5KGFycmF5T3JTdHJpbmcpID8gZGVmaW5lKGFycmF5T3JTdHJpbmcpIDogZGVmaW5lKFN0cmluZyhhcnJheU9yU3RyaW5nKS5zcGxpdChkZWxpbWl0ZXIpKTtcblxuICByZXR1cm4gb2JqO1xufTtcblxuY29uc3Qgbm9vcCA9ICgpID0+IHt9O1xuXG5jb25zdCB0b0Zpbml0ZU51bWJlciA9ICh2YWx1ZSwgZGVmYXVsdFZhbHVlKSA9PiB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIE51bWJlci5pc0Zpbml0ZSh2YWx1ZSA9ICt2YWx1ZSkgPyB2YWx1ZSA6IGRlZmF1bHRWYWx1ZTtcbn07XG5cblxuXG4vKipcbiAqIElmIHRoZSB0aGluZyBpcyBhIEZvcm1EYXRhIG9iamVjdCwgcmV0dXJuIHRydWUsIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXG4gKlxuICogQHBhcmFtIHt1bmtub3dufSB0aGluZyAtIFRoZSB0aGluZyB0byBjaGVjay5cbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNTcGVjQ29tcGxpYW50Rm9ybSh0aGluZykge1xuICByZXR1cm4gISEodGhpbmcgJiYgaXNGdW5jdGlvbiQxKHRoaW5nLmFwcGVuZCkgJiYgdGhpbmdbdG9TdHJpbmdUYWddID09PSAnRm9ybURhdGEnICYmIHRoaW5nW2l0ZXJhdG9yXSk7XG59XG5cbmNvbnN0IHRvSlNPTk9iamVjdCA9IChvYmopID0+IHtcbiAgY29uc3Qgc3RhY2sgPSBuZXcgQXJyYXkoMTApO1xuXG4gIGNvbnN0IHZpc2l0ID0gKHNvdXJjZSwgaSkgPT4ge1xuXG4gICAgaWYgKGlzT2JqZWN0KHNvdXJjZSkpIHtcbiAgICAgIGlmIChzdGFjay5pbmRleE9mKHNvdXJjZSkgPj0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vQnVmZmVyIGNoZWNrXG4gICAgICBpZiAoaXNCdWZmZXIoc291cmNlKSkge1xuICAgICAgICByZXR1cm4gc291cmNlO1xuICAgICAgfVxuXG4gICAgICBpZighKCd0b0pTT04nIGluIHNvdXJjZSkpIHtcbiAgICAgICAgc3RhY2tbaV0gPSBzb3VyY2U7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGlzQXJyYXkoc291cmNlKSA/IFtdIDoge307XG5cbiAgICAgICAgZm9yRWFjaChzb3VyY2UsICh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgICAgY29uc3QgcmVkdWNlZFZhbHVlID0gdmlzaXQodmFsdWUsIGkgKyAxKTtcbiAgICAgICAgICAhaXNVbmRlZmluZWQocmVkdWNlZFZhbHVlKSAmJiAodGFyZ2V0W2tleV0gPSByZWR1Y2VkVmFsdWUpO1xuICAgICAgICB9KTtcblxuICAgICAgICBzdGFja1tpXSA9IHVuZGVmaW5lZDtcblxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzb3VyY2U7XG4gIH07XG5cbiAgcmV0dXJuIHZpc2l0KG9iaiwgMCk7XG59O1xuXG5jb25zdCBpc0FzeW5jRm4gPSBraW5kT2ZUZXN0KCdBc3luY0Z1bmN0aW9uJyk7XG5cbmNvbnN0IGlzVGhlbmFibGUgPSAodGhpbmcpID0+XG4gIHRoaW5nICYmIChpc09iamVjdCh0aGluZykgfHwgaXNGdW5jdGlvbiQxKHRoaW5nKSkgJiYgaXNGdW5jdGlvbiQxKHRoaW5nLnRoZW4pICYmIGlzRnVuY3Rpb24kMSh0aGluZy5jYXRjaCk7XG5cbi8vIG9yaWdpbmFsIGNvZGVcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9EaWdpdGFsQnJhaW5KUy9BeGlvc1Byb21pc2UvYmxvYi8xNmRlYWIxMzcxMGVjMDk3Nzk5MjIxMzFmM2ZhNTk1NDMyMGY4M2FiL2xpYi91dGlscy5qcyNMMTEtTDM0XG5cbmNvbnN0IF9zZXRJbW1lZGlhdGUgPSAoKHNldEltbWVkaWF0ZVN1cHBvcnRlZCwgcG9zdE1lc3NhZ2VTdXBwb3J0ZWQpID0+IHtcbiAgaWYgKHNldEltbWVkaWF0ZVN1cHBvcnRlZCkge1xuICAgIHJldHVybiBzZXRJbW1lZGlhdGU7XG4gIH1cblxuICByZXR1cm4gcG9zdE1lc3NhZ2VTdXBwb3J0ZWQgPyAoKHRva2VuLCBjYWxsYmFja3MpID0+IHtcbiAgICBfZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsICh7c291cmNlLCBkYXRhfSkgPT4ge1xuICAgICAgaWYgKHNvdXJjZSA9PT0gX2dsb2JhbCAmJiBkYXRhID09PSB0b2tlbikge1xuICAgICAgICBjYWxsYmFja3MubGVuZ3RoICYmIGNhbGxiYWNrcy5zaGlmdCgpKCk7XG4gICAgICB9XG4gICAgfSwgZmFsc2UpO1xuXG4gICAgcmV0dXJuIChjYikgPT4ge1xuICAgICAgY2FsbGJhY2tzLnB1c2goY2IpO1xuICAgICAgX2dsb2JhbC5wb3N0TWVzc2FnZSh0b2tlbiwgXCIqXCIpO1xuICAgIH1cbiAgfSkoYGF4aW9zQCR7TWF0aC5yYW5kb20oKX1gLCBbXSkgOiAoY2IpID0+IHNldFRpbWVvdXQoY2IpO1xufSkoXG4gIHR5cGVvZiBzZXRJbW1lZGlhdGUgPT09ICdmdW5jdGlvbicsXG4gIGlzRnVuY3Rpb24kMShfZ2xvYmFsLnBvc3RNZXNzYWdlKVxuKTtcblxuY29uc3QgYXNhcCA9IHR5cGVvZiBxdWV1ZU1pY3JvdGFzayAhPT0gJ3VuZGVmaW5lZCcgP1xuICBxdWV1ZU1pY3JvdGFzay5iaW5kKF9nbG9iYWwpIDogKCB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcy5uZXh0VGljayB8fCBfc2V0SW1tZWRpYXRlKTtcblxuLy8gKioqKioqKioqKioqKioqKioqKioqXG5cblxuY29uc3QgaXNJdGVyYWJsZSA9ICh0aGluZykgPT4gdGhpbmcgIT0gbnVsbCAmJiBpc0Z1bmN0aW9uJDEodGhpbmdbaXRlcmF0b3JdKTtcblxuXG5jb25zdCB1dGlscyQxID0ge1xuICBpc0FycmF5LFxuICBpc0FycmF5QnVmZmVyLFxuICBpc0J1ZmZlcixcbiAgaXNGb3JtRGF0YSxcbiAgaXNBcnJheUJ1ZmZlclZpZXcsXG4gIGlzU3RyaW5nLFxuICBpc051bWJlcixcbiAgaXNCb29sZWFuLFxuICBpc09iamVjdCxcbiAgaXNQbGFpbk9iamVjdCxcbiAgaXNFbXB0eU9iamVjdCxcbiAgaXNSZWFkYWJsZVN0cmVhbSxcbiAgaXNSZXF1ZXN0LFxuICBpc1Jlc3BvbnNlLFxuICBpc0hlYWRlcnMsXG4gIGlzVW5kZWZpbmVkLFxuICBpc0RhdGUsXG4gIGlzRmlsZSxcbiAgaXNCbG9iLFxuICBpc1JlZ0V4cCxcbiAgaXNGdW5jdGlvbjogaXNGdW5jdGlvbiQxLFxuICBpc1N0cmVhbSxcbiAgaXNVUkxTZWFyY2hQYXJhbXMsXG4gIGlzVHlwZWRBcnJheSxcbiAgaXNGaWxlTGlzdCxcbiAgZm9yRWFjaCxcbiAgbWVyZ2UsXG4gIGV4dGVuZCxcbiAgdHJpbSxcbiAgc3RyaXBCT00sXG4gIGluaGVyaXRzLFxuICB0b0ZsYXRPYmplY3QsXG4gIGtpbmRPZixcbiAga2luZE9mVGVzdCxcbiAgZW5kc1dpdGgsXG4gIHRvQXJyYXksXG4gIGZvckVhY2hFbnRyeSxcbiAgbWF0Y2hBbGwsXG4gIGlzSFRNTEZvcm0sXG4gIGhhc093blByb3BlcnR5LFxuICBoYXNPd25Qcm9wOiBoYXNPd25Qcm9wZXJ0eSwgLy8gYW4gYWxpYXMgdG8gYXZvaWQgRVNMaW50IG5vLXByb3RvdHlwZS1idWlsdGlucyBkZXRlY3Rpb25cbiAgcmVkdWNlRGVzY3JpcHRvcnMsXG4gIGZyZWV6ZU1ldGhvZHMsXG4gIHRvT2JqZWN0U2V0LFxuICB0b0NhbWVsQ2FzZSxcbiAgbm9vcCxcbiAgdG9GaW5pdGVOdW1iZXIsXG4gIGZpbmRLZXksXG4gIGdsb2JhbDogX2dsb2JhbCxcbiAgaXNDb250ZXh0RGVmaW5lZCxcbiAgaXNTcGVjQ29tcGxpYW50Rm9ybSxcbiAgdG9KU09OT2JqZWN0LFxuICBpc0FzeW5jRm4sXG4gIGlzVGhlbmFibGUsXG4gIHNldEltbWVkaWF0ZTogX3NldEltbWVkaWF0ZSxcbiAgYXNhcCxcbiAgaXNJdGVyYWJsZVxufTtcblxuY2xhc3MgQXhpb3NFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBzdGF0aWMgZnJvbShlcnJvciwgY29kZSwgY29uZmlnLCByZXF1ZXN0LCByZXNwb25zZSwgY3VzdG9tUHJvcHMpIHtcbiAgICAgICAgY29uc3QgYXhpb3NFcnJvciA9IG5ldyBBeGlvc0Vycm9yKGVycm9yLm1lc3NhZ2UsIGNvZGUgfHwgZXJyb3IuY29kZSwgY29uZmlnLCByZXF1ZXN0LCByZXNwb25zZSk7XG4gICAgICAgIGF4aW9zRXJyb3IuY2F1c2UgPSBlcnJvcjtcbiAgICAgICAgYXhpb3NFcnJvci5uYW1lID0gZXJyb3IubmFtZTtcbiAgICAgICAgY3VzdG9tUHJvcHMgJiYgT2JqZWN0LmFzc2lnbihheGlvc0Vycm9yLCBjdXN0b21Qcm9wcyk7XG4gICAgICAgIHJldHVybiBheGlvc0Vycm9yO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhbiBFcnJvciB3aXRoIHRoZSBzcGVjaWZpZWQgbWVzc2FnZSwgY29uZmlnLCBlcnJvciBjb2RlLCByZXF1ZXN0IGFuZCByZXNwb25zZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIFRoZSBlcnJvciBtZXNzYWdlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY29kZV0gVGhlIGVycm9yIGNvZGUgKGZvciBleGFtcGxlLCAnRUNPTk5BQk9SVEVEJykuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWddIFRoZSBjb25maWcuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtyZXF1ZXN0XSBUaGUgcmVxdWVzdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3Jlc3BvbnNlXSBUaGUgcmVzcG9uc2UuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7RXJyb3J9IFRoZSBjcmVhdGVkIGVycm9yLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIGNvZGUsIGNvbmZpZywgcmVxdWVzdCwgcmVzcG9uc2UpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIHRoaXMubmFtZSA9ICdBeGlvc0Vycm9yJztcbiAgICAgICAgdGhpcy5pc0F4aW9zRXJyb3IgPSB0cnVlO1xuICAgICAgICBjb2RlICYmICh0aGlzLmNvZGUgPSBjb2RlKTtcbiAgICAgICAgY29uZmlnICYmICh0aGlzLmNvbmZpZyA9IGNvbmZpZyk7XG4gICAgICAgIHJlcXVlc3QgJiYgKHRoaXMucmVxdWVzdCA9IHJlcXVlc3QpO1xuICAgICAgICBpZiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgIHRoaXMucmVzcG9uc2UgPSByZXNwb25zZTtcbiAgICAgICAgICAgIHRoaXMuc3RhdHVzID0gcmVzcG9uc2Uuc3RhdHVzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLy8gU3RhbmRhcmRcbiAgICAgICAgICAgIG1lc3NhZ2U6IHRoaXMubWVzc2FnZSxcbiAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgICAgIC8vIE1pY3Jvc29mdFxuICAgICAgICAgICAgZGVzY3JpcHRpb246IHRoaXMuZGVzY3JpcHRpb24sXG4gICAgICAgICAgICBudW1iZXI6IHRoaXMubnVtYmVyLFxuICAgICAgICAgICAgLy8gTW96aWxsYVxuICAgICAgICAgICAgZmlsZU5hbWU6IHRoaXMuZmlsZU5hbWUsXG4gICAgICAgICAgICBsaW5lTnVtYmVyOiB0aGlzLmxpbmVOdW1iZXIsXG4gICAgICAgICAgICBjb2x1bW5OdW1iZXI6IHRoaXMuY29sdW1uTnVtYmVyLFxuICAgICAgICAgICAgc3RhY2s6IHRoaXMuc3RhY2ssXG4gICAgICAgICAgICAvLyBBeGlvc1xuICAgICAgICAgICAgY29uZmlnOiB1dGlscyQxLnRvSlNPTk9iamVjdCh0aGlzLmNvbmZpZyksXG4gICAgICAgICAgICBjb2RlOiB0aGlzLmNvZGUsXG4gICAgICAgICAgICBzdGF0dXM6IHRoaXMuc3RhdHVzLFxuICAgICAgICB9O1xuICAgIH1cbn1cblxuLy8gVGhpcyBjYW4gYmUgY2hhbmdlZCB0byBzdGF0aWMgcHJvcGVydGllcyBhcyBzb29uIGFzIHRoZSBwYXJzZXIgb3B0aW9ucyBpbiAuZXNsaW50LmNqcyBhcmUgdXBkYXRlZC5cbkF4aW9zRXJyb3IuRVJSX0JBRF9PUFRJT05fVkFMVUUgPSAnRVJSX0JBRF9PUFRJT05fVkFMVUUnO1xuQXhpb3NFcnJvci5FUlJfQkFEX09QVElPTiA9ICdFUlJfQkFEX09QVElPTic7XG5BeGlvc0Vycm9yLkVDT05OQUJPUlRFRCA9ICdFQ09OTkFCT1JURUQnO1xuQXhpb3NFcnJvci5FVElNRURPVVQgPSAnRVRJTUVET1VUJztcbkF4aW9zRXJyb3IuRVJSX05FVFdPUksgPSAnRVJSX05FVFdPUksnO1xuQXhpb3NFcnJvci5FUlJfRlJfVE9PX01BTllfUkVESVJFQ1RTID0gJ0VSUl9GUl9UT09fTUFOWV9SRURJUkVDVFMnO1xuQXhpb3NFcnJvci5FUlJfREVQUkVDQVRFRCA9ICdFUlJfREVQUkVDQVRFRCc7XG5BeGlvc0Vycm9yLkVSUl9CQURfUkVTUE9OU0UgPSAnRVJSX0JBRF9SRVNQT05TRSc7XG5BeGlvc0Vycm9yLkVSUl9CQURfUkVRVUVTVCA9ICdFUlJfQkFEX1JFUVVFU1QnO1xuQXhpb3NFcnJvci5FUlJfQ0FOQ0VMRUQgPSAnRVJSX0NBTkNFTEVEJztcbkF4aW9zRXJyb3IuRVJSX05PVF9TVVBQT1JUID0gJ0VSUl9OT1RfU1VQUE9SVCc7XG5BeGlvc0Vycm9yLkVSUl9JTlZBTElEX1VSTCA9ICdFUlJfSU5WQUxJRF9VUkwnO1xuXG5jb25zdCBBeGlvc0Vycm9yJDEgPSBBeGlvc0Vycm9yO1xuXG4vKipcbiAqIERldGVybWluZXMgaWYgdGhlIGdpdmVuIHRoaW5nIGlzIGEgYXJyYXkgb3IganMgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0aGluZyAtIFRoZSBvYmplY3Qgb3IgYXJyYXkgdG8gYmUgdmlzaXRlZC5cbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNWaXNpdGFibGUodGhpbmcpIHtcbiAgcmV0dXJuIHV0aWxzJDEuaXNQbGFpbk9iamVjdCh0aGluZykgfHwgdXRpbHMkMS5pc0FycmF5KHRoaW5nKTtcbn1cblxuLyoqXG4gKiBJdCByZW1vdmVzIHRoZSBicmFja2V0cyBmcm9tIHRoZSBlbmQgb2YgYSBzdHJpbmdcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0gVGhlIGtleSBvZiB0aGUgcGFyYW1ldGVyLlxuICpcbiAqIEByZXR1cm5zIHtzdHJpbmd9IHRoZSBrZXkgd2l0aG91dCB0aGUgYnJhY2tldHMuXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUJyYWNrZXRzKGtleSkge1xuICByZXR1cm4gdXRpbHMkMS5lbmRzV2l0aChrZXksICdbXScpID8ga2V5LnNsaWNlKDAsIC0yKSA6IGtleTtcbn1cblxuLyoqXG4gKiBJdCB0YWtlcyBhIHBhdGgsIGEga2V5LCBhbmQgYSBib29sZWFuLCBhbmQgcmV0dXJucyBhIHN0cmluZ1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIC0gVGhlIHBhdGggdG8gdGhlIGN1cnJlbnQga2V5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSAtIFRoZSBrZXkgb2YgdGhlIGN1cnJlbnQgb2JqZWN0IGJlaW5nIGl0ZXJhdGVkIG92ZXIuXG4gKiBAcGFyYW0ge3N0cmluZ30gZG90cyAtIElmIHRydWUsIHRoZSBrZXkgd2lsbCBiZSByZW5kZXJlZCB3aXRoIGRvdHMgaW5zdGVhZCBvZiBicmFja2V0cy5cbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgcGF0aCB0byB0aGUgY3VycmVudCBrZXkuXG4gKi9cbmZ1bmN0aW9uIHJlbmRlcktleShwYXRoLCBrZXksIGRvdHMpIHtcbiAgaWYgKCFwYXRoKSByZXR1cm4ga2V5O1xuICByZXR1cm4gcGF0aC5jb25jYXQoa2V5KS5tYXAoZnVuY3Rpb24gZWFjaCh0b2tlbiwgaSkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgIHRva2VuID0gcmVtb3ZlQnJhY2tldHModG9rZW4pO1xuICAgIHJldHVybiAhZG90cyAmJiBpID8gJ1snICsgdG9rZW4gKyAnXScgOiB0b2tlbjtcbiAgfSkuam9pbihkb3RzID8gJy4nIDogJycpO1xufVxuXG4vKipcbiAqIElmIHRoZSBhcnJheSBpcyBhbiBhcnJheSBhbmQgbm9uZSBvZiBpdHMgZWxlbWVudHMgYXJlIHZpc2l0YWJsZSwgdGhlbiBpdCdzIGEgZmxhdCBhcnJheS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PGFueT59IGFyciAtIFRoZSBhcnJheSB0byBjaGVja1xuICpcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc0ZsYXRBcnJheShhcnIpIHtcbiAgcmV0dXJuIHV0aWxzJDEuaXNBcnJheShhcnIpICYmICFhcnIuc29tZShpc1Zpc2l0YWJsZSk7XG59XG5cbmNvbnN0IHByZWRpY2F0ZXMgPSB1dGlscyQxLnRvRmxhdE9iamVjdCh1dGlscyQxLCB7fSwgbnVsbCwgZnVuY3Rpb24gZmlsdGVyKHByb3ApIHtcbiAgcmV0dXJuIC9eaXNbQS1aXS8udGVzdChwcm9wKTtcbn0pO1xuXG4vKipcbiAqIENvbnZlcnQgYSBkYXRhIG9iamVjdCB0byBGb3JtRGF0YVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7P09iamVjdH0gW2Zvcm1EYXRhXVxuICogQHBhcmFtIHs/T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLnZpc2l0b3JdXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm1ldGFUb2tlbnMgPSB0cnVlXVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5kb3RzID0gZmFsc2VdXG4gKiBAcGFyYW0gez9Cb29sZWFufSBbb3B0aW9ucy5pbmRleGVzID0gZmFsc2VdXG4gKlxuICogQHJldHVybnMge09iamVjdH1cbiAqKi9cblxuLyoqXG4gKiBJdCBjb252ZXJ0cyBhbiBvYmplY3QgaW50byBhIEZvcm1EYXRhIG9iamVjdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0PGFueSwgYW55Pn0gb2JqIC0gVGhlIG9iamVjdCB0byBjb252ZXJ0IHRvIGZvcm0gZGF0YS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBmb3JtRGF0YSAtIFRoZSBGb3JtRGF0YSBvYmplY3QgdG8gYXBwZW5kIHRvLlxuICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLCBhbnk+fSBvcHRpb25zXG4gKlxuICogQHJldHVybnNcbiAqL1xuZnVuY3Rpb24gdG9Gb3JtRGF0YShvYmosIGZvcm1EYXRhLCBvcHRpb25zKSB7XG4gIGlmICghdXRpbHMkMS5pc09iamVjdChvYmopKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndGFyZ2V0IG11c3QgYmUgYW4gb2JqZWN0Jyk7XG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgZm9ybURhdGEgPSBmb3JtRGF0YSB8fCBuZXcgKEZvcm1EYXRhX19kZWZhdWx0W1wiZGVmYXVsdFwiXSB8fCBGb3JtRGF0YSkoKTtcblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgb3B0aW9ucyA9IHV0aWxzJDEudG9GbGF0T2JqZWN0KG9wdGlvbnMsIHtcbiAgICBtZXRhVG9rZW5zOiB0cnVlLFxuICAgIGRvdHM6IGZhbHNlLFxuICAgIGluZGV4ZXM6IGZhbHNlXG4gIH0sIGZhbHNlLCBmdW5jdGlvbiBkZWZpbmVkKG9wdGlvbiwgc291cmNlKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVxLW51bGwsZXFlcWVxXG4gICAgcmV0dXJuICF1dGlscyQxLmlzVW5kZWZpbmVkKHNvdXJjZVtvcHRpb25dKTtcbiAgfSk7XG5cbiAgY29uc3QgbWV0YVRva2VucyA9IG9wdGlvbnMubWV0YVRva2VucztcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVzZS1iZWZvcmUtZGVmaW5lXG4gIGNvbnN0IHZpc2l0b3IgPSBvcHRpb25zLnZpc2l0b3IgfHwgZGVmYXVsdFZpc2l0b3I7XG4gIGNvbnN0IGRvdHMgPSBvcHRpb25zLmRvdHM7XG4gIGNvbnN0IGluZGV4ZXMgPSBvcHRpb25zLmluZGV4ZXM7XG4gIGNvbnN0IF9CbG9iID0gb3B0aW9ucy5CbG9iIHx8IHR5cGVvZiBCbG9iICE9PSAndW5kZWZpbmVkJyAmJiBCbG9iO1xuICBjb25zdCB1c2VCbG9iID0gX0Jsb2IgJiYgdXRpbHMkMS5pc1NwZWNDb21wbGlhbnRGb3JtKGZvcm1EYXRhKTtcblxuICBpZiAoIXV0aWxzJDEuaXNGdW5jdGlvbih2aXNpdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3Zpc2l0b3IgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gIH1cblxuICBmdW5jdGlvbiBjb252ZXJ0VmFsdWUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT09IG51bGwpIHJldHVybiAnJztcblxuICAgIGlmICh1dGlscyQxLmlzRGF0ZSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB2YWx1ZS50b0lTT1N0cmluZygpO1xuICAgIH1cblxuICAgIGlmICh1dGlscyQxLmlzQm9vbGVhbih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuICAgIH1cblxuICAgIGlmICghdXNlQmxvYiAmJiB1dGlscyQxLmlzQmxvYih2YWx1ZSkpIHtcbiAgICAgIHRocm93IG5ldyBBeGlvc0Vycm9yJDEoJ0Jsb2IgaXMgbm90IHN1cHBvcnRlZC4gVXNlIGEgQnVmZmVyIGluc3RlYWQuJyk7XG4gICAgfVxuXG4gICAgaWYgKHV0aWxzJDEuaXNBcnJheUJ1ZmZlcih2YWx1ZSkgfHwgdXRpbHMkMS5pc1R5cGVkQXJyYXkodmFsdWUpKSB7XG4gICAgICByZXR1cm4gdXNlQmxvYiAmJiB0eXBlb2YgQmxvYiA9PT0gJ2Z1bmN0aW9uJyA/IG5ldyBCbG9iKFt2YWx1ZV0pIDogQnVmZmVyLmZyb20odmFsdWUpO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWZhdWx0IHZpc2l0b3IuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSBrZXlcbiAgICogQHBhcmFtIHtBcnJheTxTdHJpbmd8TnVtYmVyPn0gcGF0aFxuICAgKiBAdGhpcyB7Rm9ybURhdGF9XG4gICAqXG4gICAqIEByZXR1cm5zIHtib29sZWFufSByZXR1cm4gdHJ1ZSB0byB2aXNpdCB0aGUgZWFjaCBwcm9wIG9mIHRoZSB2YWx1ZSByZWN1cnNpdmVseVxuICAgKi9cbiAgZnVuY3Rpb24gZGVmYXVsdFZpc2l0b3IodmFsdWUsIGtleSwgcGF0aCkge1xuICAgIGxldCBhcnIgPSB2YWx1ZTtcblxuICAgIGlmICh2YWx1ZSAmJiAhcGF0aCAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICBpZiAodXRpbHMkMS5lbmRzV2l0aChrZXksICd7fScpKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICBrZXkgPSBtZXRhVG9rZW5zID8ga2V5IDoga2V5LnNsaWNlKDAsIC0yKTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgIHZhbHVlID0gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgKHV0aWxzJDEuaXNBcnJheSh2YWx1ZSkgJiYgaXNGbGF0QXJyYXkodmFsdWUpKSB8fFxuICAgICAgICAoKHV0aWxzJDEuaXNGaWxlTGlzdCh2YWx1ZSkgfHwgdXRpbHMkMS5lbmRzV2l0aChrZXksICdbXScpKSAmJiAoYXJyID0gdXRpbHMkMS50b0FycmF5KHZhbHVlKSlcbiAgICAgICAgKSkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAga2V5ID0gcmVtb3ZlQnJhY2tldHMoa2V5KTtcblxuICAgICAgICBhcnIuZm9yRWFjaChmdW5jdGlvbiBlYWNoKGVsLCBpbmRleCkge1xuICAgICAgICAgICEodXRpbHMkMS5pc1VuZGVmaW5lZChlbCkgfHwgZWwgPT09IG51bGwpICYmIGZvcm1EYXRhLmFwcGVuZChcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXN0ZWQtdGVybmFyeVxuICAgICAgICAgICAgaW5kZXhlcyA9PT0gdHJ1ZSA/IHJlbmRlcktleShba2V5XSwgaW5kZXgsIGRvdHMpIDogKGluZGV4ZXMgPT09IG51bGwgPyBrZXkgOiBrZXkgKyAnW10nKSxcbiAgICAgICAgICAgIGNvbnZlcnRWYWx1ZShlbClcbiAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpc1Zpc2l0YWJsZSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGZvcm1EYXRhLmFwcGVuZChyZW5kZXJLZXkocGF0aCwga2V5LCBkb3RzKSwgY29udmVydFZhbHVlKHZhbHVlKSk7XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBjb25zdCBzdGFjayA9IFtdO1xuXG4gIGNvbnN0IGV4cG9zZWRIZWxwZXJzID0gT2JqZWN0LmFzc2lnbihwcmVkaWNhdGVzLCB7XG4gICAgZGVmYXVsdFZpc2l0b3IsXG4gICAgY29udmVydFZhbHVlLFxuICAgIGlzVmlzaXRhYmxlXG4gIH0pO1xuXG4gIGZ1bmN0aW9uIGJ1aWxkKHZhbHVlLCBwYXRoKSB7XG4gICAgaWYgKHV0aWxzJDEuaXNVbmRlZmluZWQodmFsdWUpKSByZXR1cm47XG5cbiAgICBpZiAoc3RhY2suaW5kZXhPZih2YWx1ZSkgIT09IC0xKSB7XG4gICAgICB0aHJvdyBFcnJvcignQ2lyY3VsYXIgcmVmZXJlbmNlIGRldGVjdGVkIGluICcgKyBwYXRoLmpvaW4oJy4nKSk7XG4gICAgfVxuXG4gICAgc3RhY2sucHVzaCh2YWx1ZSk7XG5cbiAgICB1dGlscyQxLmZvckVhY2godmFsdWUsIGZ1bmN0aW9uIGVhY2goZWwsIGtleSkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gISh1dGlscyQxLmlzVW5kZWZpbmVkKGVsKSB8fCBlbCA9PT0gbnVsbCkgJiYgdmlzaXRvci5jYWxsKFxuICAgICAgICBmb3JtRGF0YSwgZWwsIHV0aWxzJDEuaXNTdHJpbmcoa2V5KSA/IGtleS50cmltKCkgOiBrZXksIHBhdGgsIGV4cG9zZWRIZWxwZXJzXG4gICAgICApO1xuXG4gICAgICBpZiAocmVzdWx0ID09PSB0cnVlKSB7XG4gICAgICAgIGJ1aWxkKGVsLCBwYXRoID8gcGF0aC5jb25jYXQoa2V5KSA6IFtrZXldKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHN0YWNrLnBvcCgpO1xuICB9XG5cbiAgaWYgKCF1dGlscyQxLmlzT2JqZWN0KG9iaikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdkYXRhIG11c3QgYmUgYW4gb2JqZWN0Jyk7XG4gIH1cblxuICBidWlsZChvYmopO1xuXG4gIHJldHVybiBmb3JtRGF0YTtcbn1cblxuLyoqXG4gKiBJdCBlbmNvZGVzIGEgc3RyaW5nIGJ5IHJlcGxhY2luZyBhbGwgY2hhcmFjdGVycyB0aGF0IGFyZSBub3QgaW4gdGhlIHVucmVzZXJ2ZWQgc2V0IHdpdGhcbiAqIHRoZWlyIHBlcmNlbnQtZW5jb2RlZCBlcXVpdmFsZW50c1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgLSBUaGUgc3RyaW5nIHRvIGVuY29kZS5cbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgZW5jb2RlZCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGVuY29kZSQxKHN0cikge1xuICBjb25zdCBjaGFyTWFwID0ge1xuICAgICchJzogJyUyMScsXG4gICAgXCInXCI6ICclMjcnLFxuICAgICcoJzogJyUyOCcsXG4gICAgJyknOiAnJTI5JyxcbiAgICAnfic6ICclN0UnLFxuICAgICclMjAnOiAnKycsXG4gICAgJyUwMCc6ICdcXHgwMCdcbiAgfTtcbiAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChzdHIpLnJlcGxhY2UoL1shJygpfl18JTIwfCUwMC9nLCBmdW5jdGlvbiByZXBsYWNlcihtYXRjaCkge1xuICAgIHJldHVybiBjaGFyTWFwW21hdGNoXTtcbiAgfSk7XG59XG5cbi8qKlxuICogSXQgdGFrZXMgYSBwYXJhbXMgb2JqZWN0IGFuZCBjb252ZXJ0cyBpdCB0byBhIEZvcm1EYXRhIG9iamVjdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0PHN0cmluZywgYW55Pn0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgdG8gYmUgY29udmVydGVkIHRvIGEgRm9ybURhdGEgb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLCBhbnk+fSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgb2JqZWN0IHBhc3NlZCB0byB0aGUgQXhpb3MgY29uc3RydWN0b3IuXG4gKlxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmZ1bmN0aW9uIEF4aW9zVVJMU2VhcmNoUGFyYW1zKHBhcmFtcywgb3B0aW9ucykge1xuICB0aGlzLl9wYWlycyA9IFtdO1xuXG4gIHBhcmFtcyAmJiB0b0Zvcm1EYXRhKHBhcmFtcywgdGhpcywgb3B0aW9ucyk7XG59XG5cbmNvbnN0IHByb3RvdHlwZSA9IEF4aW9zVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZTtcblxucHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uIGFwcGVuZChuYW1lLCB2YWx1ZSkge1xuICB0aGlzLl9wYWlycy5wdXNoKFtuYW1lLCB2YWx1ZV0pO1xufTtcblxucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoZW5jb2Rlcikge1xuICBjb25zdCBfZW5jb2RlID0gZW5jb2RlciA/IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIGVuY29kZXIuY2FsbCh0aGlzLCB2YWx1ZSwgZW5jb2RlJDEpO1xuICB9IDogZW5jb2RlJDE7XG5cbiAgcmV0dXJuIHRoaXMuX3BhaXJzLm1hcChmdW5jdGlvbiBlYWNoKHBhaXIpIHtcbiAgICByZXR1cm4gX2VuY29kZShwYWlyWzBdKSArICc9JyArIF9lbmNvZGUocGFpclsxXSk7XG4gIH0sICcnKS5qb2luKCcmJyk7XG59O1xuXG4vKipcbiAqIEl0IHJlcGxhY2VzIGFsbCBpbnN0YW5jZXMgb2YgdGhlIGNoYXJhY3RlcnMgYDpgLCBgJGAsIGAsYCwgYCtgLCBgW2AsIGFuZCBgXWAgd2l0aCB0aGVpclxuICogVVJJIGVuY29kZWQgY291bnRlcnBhcnRzXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbCBUaGUgdmFsdWUgdG8gYmUgZW5jb2RlZC5cbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgZW5jb2RlZCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gZW5jb2RlKHZhbCkge1xuICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHZhbCkuXG4gICAgcmVwbGFjZSgvJTNBL2dpLCAnOicpLlxuICAgIHJlcGxhY2UoLyUyNC9nLCAnJCcpLlxuICAgIHJlcGxhY2UoLyUyQy9naSwgJywnKS5cbiAgICByZXBsYWNlKC8lMjAvZywgJysnKTtcbn1cblxuLyoqXG4gKiBCdWlsZCBhIFVSTCBieSBhcHBlbmRpbmcgcGFyYW1zIHRvIHRoZSBlbmRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIFRoZSBiYXNlIG9mIHRoZSB1cmwgKGUuZy4sIGh0dHA6Ly93d3cuZ29vZ2xlLmNvbSlcbiAqIEBwYXJhbSB7b2JqZWN0fSBbcGFyYW1zXSBUaGUgcGFyYW1zIHRvIGJlIGFwcGVuZGVkXG4gKiBAcGFyYW0gez8ob2JqZWN0fEZ1bmN0aW9uKX0gb3B0aW9uc1xuICpcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBmb3JtYXR0ZWQgdXJsXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkVVJMKHVybCwgcGFyYW1zLCBvcHRpb25zKSB7XG4gIGlmICghcGFyYW1zKSB7XG4gICAgcmV0dXJuIHVybDtcbiAgfVxuXG4gIGNvbnN0IF9lbmNvZGUgPSBvcHRpb25zICYmIG9wdGlvbnMuZW5jb2RlIHx8IGVuY29kZTtcblxuICBjb25zdCBfb3B0aW9ucyA9IHV0aWxzJDEuaXNGdW5jdGlvbihvcHRpb25zKSA/IHtcbiAgICBzZXJpYWxpemU6IG9wdGlvbnNcbiAgfSA6IG9wdGlvbnM7XG5cbiAgY29uc3Qgc2VyaWFsaXplRm4gPSBfb3B0aW9ucyAmJiBfb3B0aW9ucy5zZXJpYWxpemU7XG5cbiAgbGV0IHNlcmlhbGl6ZWRQYXJhbXM7XG5cbiAgaWYgKHNlcmlhbGl6ZUZuKSB7XG4gICAgc2VyaWFsaXplZFBhcmFtcyA9IHNlcmlhbGl6ZUZuKHBhcmFtcywgX29wdGlvbnMpO1xuICB9IGVsc2Uge1xuICAgIHNlcmlhbGl6ZWRQYXJhbXMgPSB1dGlscyQxLmlzVVJMU2VhcmNoUGFyYW1zKHBhcmFtcykgP1xuICAgICAgcGFyYW1zLnRvU3RyaW5nKCkgOlxuICAgICAgbmV3IEF4aW9zVVJMU2VhcmNoUGFyYW1zKHBhcmFtcywgX29wdGlvbnMpLnRvU3RyaW5nKF9lbmNvZGUpO1xuICB9XG5cbiAgaWYgKHNlcmlhbGl6ZWRQYXJhbXMpIHtcbiAgICBjb25zdCBoYXNobWFya0luZGV4ID0gdXJsLmluZGV4T2YoXCIjXCIpO1xuXG4gICAgaWYgKGhhc2htYXJrSW5kZXggIT09IC0xKSB7XG4gICAgICB1cmwgPSB1cmwuc2xpY2UoMCwgaGFzaG1hcmtJbmRleCk7XG4gICAgfVxuICAgIHVybCArPSAodXJsLmluZGV4T2YoJz8nKSA9PT0gLTEgPyAnPycgOiAnJicpICsgc2VyaWFsaXplZFBhcmFtcztcbiAgfVxuXG4gIHJldHVybiB1cmw7XG59XG5cbmNsYXNzIEludGVyY2VwdG9yTWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuaGFuZGxlcnMgPSBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYSBuZXcgaW50ZXJjZXB0b3IgdG8gdGhlIHN0YWNrXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bGZpbGxlZCBUaGUgZnVuY3Rpb24gdG8gaGFuZGxlIGB0aGVuYCBmb3IgYSBgUHJvbWlzZWBcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gcmVqZWN0ZWQgVGhlIGZ1bmN0aW9uIHRvIGhhbmRsZSBgcmVqZWN0YCBmb3IgYSBgUHJvbWlzZWBcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgVGhlIG9wdGlvbnMgZm9yIHRoZSBpbnRlcmNlcHRvciwgc3luY2hyb25vdXMgYW5kIHJ1bldoZW5cbiAgICpcbiAgICogQHJldHVybiB7TnVtYmVyfSBBbiBJRCB1c2VkIHRvIHJlbW92ZSBpbnRlcmNlcHRvciBsYXRlclxuICAgKi9cbiAgdXNlKGZ1bGZpbGxlZCwgcmVqZWN0ZWQsIG9wdGlvbnMpIHtcbiAgICB0aGlzLmhhbmRsZXJzLnB1c2goe1xuICAgICAgZnVsZmlsbGVkLFxuICAgICAgcmVqZWN0ZWQsXG4gICAgICBzeW5jaHJvbm91czogb3B0aW9ucyA/IG9wdGlvbnMuc3luY2hyb25vdXMgOiBmYWxzZSxcbiAgICAgIHJ1bldoZW46IG9wdGlvbnMgPyBvcHRpb25zLnJ1bldoZW4gOiBudWxsXG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlcnMubGVuZ3RoIC0gMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYW4gaW50ZXJjZXB0b3IgZnJvbSB0aGUgc3RhY2tcbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGlkIFRoZSBJRCB0aGF0IHdhcyByZXR1cm5lZCBieSBgdXNlYFxuICAgKlxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIGVqZWN0KGlkKSB7XG4gICAgaWYgKHRoaXMuaGFuZGxlcnNbaWRdKSB7XG4gICAgICB0aGlzLmhhbmRsZXJzW2lkXSA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENsZWFyIGFsbCBpbnRlcmNlcHRvcnMgZnJvbSB0aGUgc3RhY2tcbiAgICpcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBjbGVhcigpIHtcbiAgICBpZiAodGhpcy5oYW5kbGVycykge1xuICAgICAgdGhpcy5oYW5kbGVycyA9IFtdO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJdGVyYXRlIG92ZXIgYWxsIHRoZSByZWdpc3RlcmVkIGludGVyY2VwdG9yc1xuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBpcyBwYXJ0aWN1bGFybHkgdXNlZnVsIGZvciBza2lwcGluZyBvdmVyIGFueVxuICAgKiBpbnRlcmNlcHRvcnMgdGhhdCBtYXkgaGF2ZSBiZWNvbWUgYG51bGxgIGNhbGxpbmcgYGVqZWN0YC5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIGNhbGwgZm9yIGVhY2ggaW50ZXJjZXB0b3JcbiAgICpcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBmb3JFYWNoKGZuKSB7XG4gICAgdXRpbHMkMS5mb3JFYWNoKHRoaXMuaGFuZGxlcnMsIGZ1bmN0aW9uIGZvckVhY2hIYW5kbGVyKGgpIHtcbiAgICAgIGlmIChoICE9PSBudWxsKSB7XG4gICAgICAgIGZuKGgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbmNvbnN0IEludGVyY2VwdG9yTWFuYWdlciQxID0gSW50ZXJjZXB0b3JNYW5hZ2VyO1xuXG5jb25zdCB0cmFuc2l0aW9uYWxEZWZhdWx0cyA9IHtcbiAgc2lsZW50SlNPTlBhcnNpbmc6IHRydWUsXG4gIGZvcmNlZEpTT05QYXJzaW5nOiB0cnVlLFxuICBjbGFyaWZ5VGltZW91dEVycm9yOiBmYWxzZVxufTtcblxuY29uc3QgVVJMU2VhcmNoUGFyYW1zID0gdXJsX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5VUkxTZWFyY2hQYXJhbXM7XG5cbmNvbnN0IEFMUEhBID0gJ2FiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6JztcblxuY29uc3QgRElHSVQgPSAnMDEyMzQ1Njc4OSc7XG5cbmNvbnN0IEFMUEhBQkVUID0ge1xuICBESUdJVCxcbiAgQUxQSEEsXG4gIEFMUEhBX0RJR0lUOiBBTFBIQSArIEFMUEhBLnRvVXBwZXJDYXNlKCkgKyBESUdJVFxufTtcblxuY29uc3QgZ2VuZXJhdGVTdHJpbmcgPSAoc2l6ZSA9IDE2LCBhbHBoYWJldCA9IEFMUEhBQkVULkFMUEhBX0RJR0lUKSA9PiB7XG4gIGxldCBzdHIgPSAnJztcbiAgY29uc3Qge2xlbmd0aH0gPSBhbHBoYWJldDtcbiAgY29uc3QgcmFuZG9tVmFsdWVzID0gbmV3IFVpbnQzMkFycmF5KHNpemUpO1xuICBjcnlwdG9fX2RlZmF1bHRbXCJkZWZhdWx0XCJdLnJhbmRvbUZpbGxTeW5jKHJhbmRvbVZhbHVlcyk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgc3RyICs9IGFscGhhYmV0W3JhbmRvbVZhbHVlc1tpXSAlIGxlbmd0aF07XG4gIH1cblxuICByZXR1cm4gc3RyO1xufTtcblxuXG5jb25zdCBwbGF0Zm9ybSQxID0ge1xuICBpc05vZGU6IHRydWUsXG4gIGNsYXNzZXM6IHtcbiAgICBVUkxTZWFyY2hQYXJhbXMsXG4gICAgRm9ybURhdGE6IEZvcm1EYXRhX19kZWZhdWx0W1wiZGVmYXVsdFwiXSxcbiAgICBCbG9iOiB0eXBlb2YgQmxvYiAhPT0gJ3VuZGVmaW5lZCcgJiYgQmxvYiB8fCBudWxsXG4gIH0sXG4gIEFMUEhBQkVULFxuICBnZW5lcmF0ZVN0cmluZyxcbiAgcHJvdG9jb2xzOiBbICdodHRwJywgJ2h0dHBzJywgJ2ZpbGUnLCAnZGF0YScgXVxufTtcblxuY29uc3QgaGFzQnJvd3NlckVudiA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCc7XG5cbmNvbnN0IF9uYXZpZ2F0b3IgPSB0eXBlb2YgbmF2aWdhdG9yID09PSAnb2JqZWN0JyAmJiBuYXZpZ2F0b3IgfHwgdW5kZWZpbmVkO1xuXG4vKipcbiAqIERldGVybWluZSBpZiB3ZSdyZSBydW5uaW5nIGluIGEgc3RhbmRhcmQgYnJvd3NlciBlbnZpcm9ubWVudFxuICpcbiAqIFRoaXMgYWxsb3dzIGF4aW9zIHRvIHJ1biBpbiBhIHdlYiB3b3JrZXIsIGFuZCByZWFjdC1uYXRpdmUuXG4gKiBCb3RoIGVudmlyb25tZW50cyBzdXBwb3J0IFhNTEh0dHBSZXF1ZXN0LCBidXQgbm90IGZ1bGx5IHN0YW5kYXJkIGdsb2JhbHMuXG4gKlxuICogd2ViIHdvcmtlcnM6XG4gKiAgdHlwZW9mIHdpbmRvdyAtPiB1bmRlZmluZWRcbiAqICB0eXBlb2YgZG9jdW1lbnQgLT4gdW5kZWZpbmVkXG4gKlxuICogcmVhY3QtbmF0aXZlOlxuICogIG5hdmlnYXRvci5wcm9kdWN0IC0+ICdSZWFjdE5hdGl2ZSdcbiAqIG5hdGl2ZXNjcmlwdFxuICogIG5hdmlnYXRvci5wcm9kdWN0IC0+ICdOYXRpdmVTY3JpcHQnIG9yICdOUydcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuY29uc3QgaGFzU3RhbmRhcmRCcm93c2VyRW52ID0gaGFzQnJvd3NlckVudiAmJlxuICAoIV9uYXZpZ2F0b3IgfHwgWydSZWFjdE5hdGl2ZScsICdOYXRpdmVTY3JpcHQnLCAnTlMnXS5pbmRleE9mKF9uYXZpZ2F0b3IucHJvZHVjdCkgPCAwKTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgd2UncmUgcnVubmluZyBpbiBhIHN0YW5kYXJkIGJyb3dzZXIgd2ViV29ya2VyIGVudmlyb25tZW50XG4gKlxuICogQWx0aG91Z2ggdGhlIGBpc1N0YW5kYXJkQnJvd3NlckVudmAgbWV0aG9kIGluZGljYXRlcyB0aGF0XG4gKiBgYWxsb3dzIGF4aW9zIHRvIHJ1biBpbiBhIHdlYiB3b3JrZXJgLCB0aGUgV2ViV29ya2VyIHdpbGwgc3RpbGwgYmVcbiAqIGZpbHRlcmVkIG91dCBkdWUgdG8gaXRzIGp1ZGdtZW50IHN0YW5kYXJkXG4gKiBgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJ2AuXG4gKiBUaGlzIGxlYWRzIHRvIGEgcHJvYmxlbSB3aGVuIGF4aW9zIHBvc3QgYEZvcm1EYXRhYCBpbiB3ZWJXb3JrZXJcbiAqL1xuY29uc3QgaGFzU3RhbmRhcmRCcm93c2VyV2ViV29ya2VyRW52ID0gKCgpID0+IHtcbiAgcmV0dXJuIChcbiAgICB0eXBlb2YgV29ya2VyR2xvYmFsU2NvcGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gICAgc2VsZiBpbnN0YW5jZW9mIFdvcmtlckdsb2JhbFNjb3BlICYmXG4gICAgdHlwZW9mIHNlbGYuaW1wb3J0U2NyaXB0cyA9PT0gJ2Z1bmN0aW9uJ1xuICApO1xufSkoKTtcblxuY29uc3Qgb3JpZ2luID0gaGFzQnJvd3NlckVudiAmJiB3aW5kb3cubG9jYXRpb24uaHJlZiB8fCAnaHR0cDovL2xvY2FsaG9zdCc7XG5cbmNvbnN0IHV0aWxzID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIGhhc0Jyb3dzZXJFbnY6IGhhc0Jyb3dzZXJFbnYsXG4gIGhhc1N0YW5kYXJkQnJvd3NlcldlYldvcmtlckVudjogaGFzU3RhbmRhcmRCcm93c2VyV2ViV29ya2VyRW52LFxuICBoYXNTdGFuZGFyZEJyb3dzZXJFbnY6IGhhc1N0YW5kYXJkQnJvd3NlckVudixcbiAgbmF2aWdhdG9yOiBfbmF2aWdhdG9yLFxuICBvcmlnaW46IG9yaWdpblxufSk7XG5cbmNvbnN0IHBsYXRmb3JtID0ge1xuICAuLi51dGlscyxcbiAgLi4ucGxhdGZvcm0kMVxufTtcblxuZnVuY3Rpb24gdG9VUkxFbmNvZGVkRm9ybShkYXRhLCBvcHRpb25zKSB7XG4gIHJldHVybiB0b0Zvcm1EYXRhKGRhdGEsIG5ldyBwbGF0Zm9ybS5jbGFzc2VzLlVSTFNlYXJjaFBhcmFtcygpLCB7XG4gICAgdmlzaXRvcjogZnVuY3Rpb24odmFsdWUsIGtleSwgcGF0aCwgaGVscGVycykge1xuICAgICAgaWYgKHBsYXRmb3JtLmlzTm9kZSAmJiB1dGlscyQxLmlzQnVmZmVyKHZhbHVlKSkge1xuICAgICAgICB0aGlzLmFwcGVuZChrZXksIHZhbHVlLnRvU3RyaW5nKCdiYXNlNjQnKSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGhlbHBlcnMuZGVmYXVsdFZpc2l0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIC4uLm9wdGlvbnNcbiAgfSk7XG59XG5cbi8qKlxuICogSXQgdGFrZXMgYSBzdHJpbmcgbGlrZSBgZm9vW3hdW3ldW3pdYCBhbmQgcmV0dXJucyBhbiBhcnJheSBsaWtlIGBbJ2ZvbycsICd4JywgJ3knLCAneiddXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICpcbiAqIEByZXR1cm5zIEFuIGFycmF5IG9mIHN0cmluZ3MuXG4gKi9cbmZ1bmN0aW9uIHBhcnNlUHJvcFBhdGgobmFtZSkge1xuICAvLyBmb29beF1beV1bel1cbiAgLy8gZm9vLngueS56XG4gIC8vIGZvby14LXktelxuICAvLyBmb28geCB5IHpcbiAgcmV0dXJuIHV0aWxzJDEubWF0Y2hBbGwoL1xcdyt8XFxbKFxcdyopXS9nLCBuYW1lKS5tYXAobWF0Y2ggPT4ge1xuICAgIHJldHVybiBtYXRjaFswXSA9PT0gJ1tdJyA/ICcnIDogbWF0Y2hbMV0gfHwgbWF0Y2hbMF07XG4gIH0pO1xufVxuXG4vKipcbiAqIENvbnZlcnQgYW4gYXJyYXkgdG8gYW4gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8YW55Pn0gYXJyIC0gVGhlIGFycmF5IHRvIGNvbnZlcnQgdG8gYW4gb2JqZWN0LlxuICpcbiAqIEByZXR1cm5zIEFuIG9iamVjdCB3aXRoIHRoZSBzYW1lIGtleXMgYW5kIHZhbHVlcyBhcyB0aGUgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGFycmF5VG9PYmplY3QoYXJyKSB7XG4gIGNvbnN0IG9iaiA9IHt9O1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoYXJyKTtcbiAgbGV0IGk7XG4gIGNvbnN0IGxlbiA9IGtleXMubGVuZ3RoO1xuICBsZXQga2V5O1xuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBrZXkgPSBrZXlzW2ldO1xuICAgIG9ialtrZXldID0gYXJyW2tleV07XG4gIH1cbiAgcmV0dXJuIG9iajtcbn1cblxuLyoqXG4gKiBJdCB0YWtlcyBhIEZvcm1EYXRhIG9iamVjdCBhbmQgcmV0dXJucyBhIEphdmFTY3JpcHQgb2JqZWN0XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGZvcm1EYXRhIFRoZSBGb3JtRGF0YSBvYmplY3QgdG8gY29udmVydCB0byBKU09OLlxuICpcbiAqIEByZXR1cm5zIHtPYmplY3Q8c3RyaW5nLCBhbnk+IHwgbnVsbH0gVGhlIGNvbnZlcnRlZCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGZvcm1EYXRhVG9KU09OKGZvcm1EYXRhKSB7XG4gIGZ1bmN0aW9uIGJ1aWxkUGF0aChwYXRoLCB2YWx1ZSwgdGFyZ2V0LCBpbmRleCkge1xuICAgIGxldCBuYW1lID0gcGF0aFtpbmRleCsrXTtcblxuICAgIGlmIChuYW1lID09PSAnX19wcm90b19fJykgcmV0dXJuIHRydWU7XG5cbiAgICBjb25zdCBpc051bWVyaWNLZXkgPSBOdW1iZXIuaXNGaW5pdGUoK25hbWUpO1xuICAgIGNvbnN0IGlzTGFzdCA9IGluZGV4ID49IHBhdGgubGVuZ3RoO1xuICAgIG5hbWUgPSAhbmFtZSAmJiB1dGlscyQxLmlzQXJyYXkodGFyZ2V0KSA/IHRhcmdldC5sZW5ndGggOiBuYW1lO1xuXG4gICAgaWYgKGlzTGFzdCkge1xuICAgICAgaWYgKHV0aWxzJDEuaGFzT3duUHJvcCh0YXJnZXQsIG5hbWUpKSB7XG4gICAgICAgIHRhcmdldFtuYW1lXSA9IFt0YXJnZXRbbmFtZV0sIHZhbHVlXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRhcmdldFtuYW1lXSA9IHZhbHVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gIWlzTnVtZXJpY0tleTtcbiAgICB9XG5cbiAgICBpZiAoIXRhcmdldFtuYW1lXSB8fCAhdXRpbHMkMS5pc09iamVjdCh0YXJnZXRbbmFtZV0pKSB7XG4gICAgICB0YXJnZXRbbmFtZV0gPSBbXTtcbiAgICB9XG5cbiAgICBjb25zdCByZXN1bHQgPSBidWlsZFBhdGgocGF0aCwgdmFsdWUsIHRhcmdldFtuYW1lXSwgaW5kZXgpO1xuXG4gICAgaWYgKHJlc3VsdCAmJiB1dGlscyQxLmlzQXJyYXkodGFyZ2V0W25hbWVdKSkge1xuICAgICAgdGFyZ2V0W25hbWVdID0gYXJyYXlUb09iamVjdCh0YXJnZXRbbmFtZV0pO1xuICAgIH1cblxuICAgIHJldHVybiAhaXNOdW1lcmljS2V5O1xuICB9XG5cbiAgaWYgKHV0aWxzJDEuaXNGb3JtRGF0YShmb3JtRGF0YSkgJiYgdXRpbHMkMS5pc0Z1bmN0aW9uKGZvcm1EYXRhLmVudHJpZXMpKSB7XG4gICAgY29uc3Qgb2JqID0ge307XG5cbiAgICB1dGlscyQxLmZvckVhY2hFbnRyeShmb3JtRGF0YSwgKG5hbWUsIHZhbHVlKSA9PiB7XG4gICAgICBidWlsZFBhdGgocGFyc2VQcm9wUGF0aChuYW1lKSwgdmFsdWUsIG9iaiwgMCk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogSXQgdGFrZXMgYSBzdHJpbmcsIHRyaWVzIHRvIHBhcnNlIGl0LCBhbmQgaWYgaXQgZmFpbHMsIGl0IHJldHVybnMgdGhlIHN0cmluZ2lmaWVkIHZlcnNpb25cbiAqIG9mIHRoZSBpbnB1dFxuICpcbiAqIEBwYXJhbSB7YW55fSByYXdWYWx1ZSAtIFRoZSB2YWx1ZSB0byBiZSBzdHJpbmdpZmllZC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHBhcnNlciAtIEEgZnVuY3Rpb24gdGhhdCBwYXJzZXMgYSBzdHJpbmcgaW50byBhIEphdmFTY3JpcHQgb2JqZWN0LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZW5jb2RlciAtIEEgZnVuY3Rpb24gdGhhdCB0YWtlcyBhIHZhbHVlIGFuZCByZXR1cm5zIGEgc3RyaW5nLlxuICpcbiAqIEByZXR1cm5zIHtzdHJpbmd9IEEgc3RyaW5naWZpZWQgdmVyc2lvbiBvZiB0aGUgcmF3VmFsdWUuXG4gKi9cbmZ1bmN0aW9uIHN0cmluZ2lmeVNhZmVseShyYXdWYWx1ZSwgcGFyc2VyLCBlbmNvZGVyKSB7XG4gIGlmICh1dGlscyQxLmlzU3RyaW5nKHJhd1ZhbHVlKSkge1xuICAgIHRyeSB7XG4gICAgICAocGFyc2VyIHx8IEpTT04ucGFyc2UpKHJhd1ZhbHVlKTtcbiAgICAgIHJldHVybiB1dGlscyQxLnRyaW0ocmF3VmFsdWUpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmIChlLm5hbWUgIT09ICdTeW50YXhFcnJvcicpIHtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gKGVuY29kZXIgfHwgSlNPTi5zdHJpbmdpZnkpKHJhd1ZhbHVlKTtcbn1cblxuY29uc3QgZGVmYXVsdHMgPSB7XG5cbiAgdHJhbnNpdGlvbmFsOiB0cmFuc2l0aW9uYWxEZWZhdWx0cyxcblxuICBhZGFwdGVyOiBbJ3hocicsICdodHRwJywgJ2ZldGNoJ10sXG5cbiAgdHJhbnNmb3JtUmVxdWVzdDogW2Z1bmN0aW9uIHRyYW5zZm9ybVJlcXVlc3QoZGF0YSwgaGVhZGVycykge1xuICAgIGNvbnN0IGNvbnRlbnRUeXBlID0gaGVhZGVycy5nZXRDb250ZW50VHlwZSgpIHx8ICcnO1xuICAgIGNvbnN0IGhhc0pTT05Db250ZW50VHlwZSA9IGNvbnRlbnRUeXBlLmluZGV4T2YoJ2FwcGxpY2F0aW9uL2pzb24nKSA+IC0xO1xuICAgIGNvbnN0IGlzT2JqZWN0UGF5bG9hZCA9IHV0aWxzJDEuaXNPYmplY3QoZGF0YSk7XG5cbiAgICBpZiAoaXNPYmplY3RQYXlsb2FkICYmIHV0aWxzJDEuaXNIVE1MRm9ybShkYXRhKSkge1xuICAgICAgZGF0YSA9IG5ldyBGb3JtRGF0YShkYXRhKTtcbiAgICB9XG5cbiAgICBjb25zdCBpc0Zvcm1EYXRhID0gdXRpbHMkMS5pc0Zvcm1EYXRhKGRhdGEpO1xuXG4gICAgaWYgKGlzRm9ybURhdGEpIHtcbiAgICAgIHJldHVybiBoYXNKU09OQ29udGVudFR5cGUgPyBKU09OLnN0cmluZ2lmeShmb3JtRGF0YVRvSlNPTihkYXRhKSkgOiBkYXRhO1xuICAgIH1cblxuICAgIGlmICh1dGlscyQxLmlzQXJyYXlCdWZmZXIoZGF0YSkgfHxcbiAgICAgIHV0aWxzJDEuaXNCdWZmZXIoZGF0YSkgfHxcbiAgICAgIHV0aWxzJDEuaXNTdHJlYW0oZGF0YSkgfHxcbiAgICAgIHV0aWxzJDEuaXNGaWxlKGRhdGEpIHx8XG4gICAgICB1dGlscyQxLmlzQmxvYihkYXRhKSB8fFxuICAgICAgdXRpbHMkMS5pc1JlYWRhYmxlU3RyZWFtKGRhdGEpXG4gICAgKSB7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgaWYgKHV0aWxzJDEuaXNBcnJheUJ1ZmZlclZpZXcoZGF0YSkpIHtcbiAgICAgIHJldHVybiBkYXRhLmJ1ZmZlcjtcbiAgICB9XG4gICAgaWYgKHV0aWxzJDEuaXNVUkxTZWFyY2hQYXJhbXMoZGF0YSkpIHtcbiAgICAgIGhlYWRlcnMuc2V0Q29udGVudFR5cGUoJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDtjaGFyc2V0PXV0Zi04JywgZmFsc2UpO1xuICAgICAgcmV0dXJuIGRhdGEudG9TdHJpbmcoKTtcbiAgICB9XG5cbiAgICBsZXQgaXNGaWxlTGlzdDtcblxuICAgIGlmIChpc09iamVjdFBheWxvYWQpIHtcbiAgICAgIGlmIChjb250ZW50VHlwZS5pbmRleE9mKCdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnKSA+IC0xKSB7XG4gICAgICAgIHJldHVybiB0b1VSTEVuY29kZWRGb3JtKGRhdGEsIHRoaXMuZm9ybVNlcmlhbGl6ZXIpLnRvU3RyaW5nKCk7XG4gICAgICB9XG5cbiAgICAgIGlmICgoaXNGaWxlTGlzdCA9IHV0aWxzJDEuaXNGaWxlTGlzdChkYXRhKSkgfHwgY29udGVudFR5cGUuaW5kZXhPZignbXVsdGlwYXJ0L2Zvcm0tZGF0YScpID4gLTEpIHtcbiAgICAgICAgY29uc3QgX0Zvcm1EYXRhID0gdGhpcy5lbnYgJiYgdGhpcy5lbnYuRm9ybURhdGE7XG5cbiAgICAgICAgcmV0dXJuIHRvRm9ybURhdGEoXG4gICAgICAgICAgaXNGaWxlTGlzdCA/IHsnZmlsZXNbXSc6IGRhdGF9IDogZGF0YSxcbiAgICAgICAgICBfRm9ybURhdGEgJiYgbmV3IF9Gb3JtRGF0YSgpLFxuICAgICAgICAgIHRoaXMuZm9ybVNlcmlhbGl6ZXJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaXNPYmplY3RQYXlsb2FkIHx8IGhhc0pTT05Db250ZW50VHlwZSApIHtcbiAgICAgIGhlYWRlcnMuc2V0Q29udGVudFR5cGUoJ2FwcGxpY2F0aW9uL2pzb24nLCBmYWxzZSk7XG4gICAgICByZXR1cm4gc3RyaW5naWZ5U2FmZWx5KGRhdGEpO1xuICAgIH1cblxuICAgIHJldHVybiBkYXRhO1xuICB9XSxcblxuICB0cmFuc2Zvcm1SZXNwb25zZTogW2Z1bmN0aW9uIHRyYW5zZm9ybVJlc3BvbnNlKGRhdGEpIHtcbiAgICBjb25zdCB0cmFuc2l0aW9uYWwgPSB0aGlzLnRyYW5zaXRpb25hbCB8fCBkZWZhdWx0cy50cmFuc2l0aW9uYWw7XG4gICAgY29uc3QgZm9yY2VkSlNPTlBhcnNpbmcgPSB0cmFuc2l0aW9uYWwgJiYgdHJhbnNpdGlvbmFsLmZvcmNlZEpTT05QYXJzaW5nO1xuICAgIGNvbnN0IEpTT05SZXF1ZXN0ZWQgPSB0aGlzLnJlc3BvbnNlVHlwZSA9PT0gJ2pzb24nO1xuXG4gICAgaWYgKHV0aWxzJDEuaXNSZXNwb25zZShkYXRhKSB8fCB1dGlscyQxLmlzUmVhZGFibGVTdHJlYW0oZGF0YSkpIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cblxuICAgIGlmIChkYXRhICYmIHV0aWxzJDEuaXNTdHJpbmcoZGF0YSkgJiYgKChmb3JjZWRKU09OUGFyc2luZyAmJiAhdGhpcy5yZXNwb25zZVR5cGUpIHx8IEpTT05SZXF1ZXN0ZWQpKSB7XG4gICAgICBjb25zdCBzaWxlbnRKU09OUGFyc2luZyA9IHRyYW5zaXRpb25hbCAmJiB0cmFuc2l0aW9uYWwuc2lsZW50SlNPTlBhcnNpbmc7XG4gICAgICBjb25zdCBzdHJpY3RKU09OUGFyc2luZyA9ICFzaWxlbnRKU09OUGFyc2luZyAmJiBKU09OUmVxdWVzdGVkO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShkYXRhLCB0aGlzLnBhcnNlUmV2aXZlcik7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChzdHJpY3RKU09OUGFyc2luZykge1xuICAgICAgICAgIGlmIChlLm5hbWUgPT09ICdTeW50YXhFcnJvcicpIHtcbiAgICAgICAgICAgIHRocm93IEF4aW9zRXJyb3IkMS5mcm9tKGUsIEF4aW9zRXJyb3IkMS5FUlJfQkFEX1JFU1BPTlNFLCB0aGlzLCBudWxsLCB0aGlzLnJlc3BvbnNlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBkYXRhO1xuICB9XSxcblxuICAvKipcbiAgICogQSB0aW1lb3V0IGluIG1pbGxpc2Vjb25kcyB0byBhYm9ydCBhIHJlcXVlc3QuIElmIHNldCB0byAwIChkZWZhdWx0KSBhXG4gICAqIHRpbWVvdXQgaXMgbm90IGNyZWF0ZWQuXG4gICAqL1xuICB0aW1lb3V0OiAwLFxuXG4gIHhzcmZDb29raWVOYW1lOiAnWFNSRi1UT0tFTicsXG4gIHhzcmZIZWFkZXJOYW1lOiAnWC1YU1JGLVRPS0VOJyxcblxuICBtYXhDb250ZW50TGVuZ3RoOiAtMSxcbiAgbWF4Qm9keUxlbmd0aDogLTEsXG5cbiAgZW52OiB7XG4gICAgRm9ybURhdGE6IHBsYXRmb3JtLmNsYXNzZXMuRm9ybURhdGEsXG4gICAgQmxvYjogcGxhdGZvcm0uY2xhc3Nlcy5CbG9iXG4gIH0sXG5cbiAgdmFsaWRhdGVTdGF0dXM6IGZ1bmN0aW9uIHZhbGlkYXRlU3RhdHVzKHN0YXR1cykge1xuICAgIHJldHVybiBzdGF0dXMgPj0gMjAwICYmIHN0YXR1cyA8IDMwMDtcbiAgfSxcblxuICBoZWFkZXJzOiB7XG4gICAgY29tbW9uOiB7XG4gICAgICAnQWNjZXB0JzogJ2FwcGxpY2F0aW9uL2pzb24sIHRleHQvcGxhaW4sICovKicsXG4gICAgICAnQ29udGVudC1UeXBlJzogdW5kZWZpbmVkXG4gICAgfVxuICB9XG59O1xuXG51dGlscyQxLmZvckVhY2goWydkZWxldGUnLCAnZ2V0JywgJ2hlYWQnLCAncG9zdCcsICdwdXQnLCAncGF0Y2gnXSwgKG1ldGhvZCkgPT4ge1xuICBkZWZhdWx0cy5oZWFkZXJzW21ldGhvZF0gPSB7fTtcbn0pO1xuXG5jb25zdCBkZWZhdWx0cyQxID0gZGVmYXVsdHM7XG5cbi8vIFJhd0F4aW9zSGVhZGVycyB3aG9zZSBkdXBsaWNhdGVzIGFyZSBpZ25vcmVkIGJ5IG5vZGVcbi8vIGMuZi4gaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9odHRwLmh0bWwjaHR0cF9tZXNzYWdlX2hlYWRlcnNcbmNvbnN0IGlnbm9yZUR1cGxpY2F0ZU9mID0gdXRpbHMkMS50b09iamVjdFNldChbXG4gICdhZ2UnLCAnYXV0aG9yaXphdGlvbicsICdjb250ZW50LWxlbmd0aCcsICdjb250ZW50LXR5cGUnLCAnZXRhZycsXG4gICdleHBpcmVzJywgJ2Zyb20nLCAnaG9zdCcsICdpZi1tb2RpZmllZC1zaW5jZScsICdpZi11bm1vZGlmaWVkLXNpbmNlJyxcbiAgJ2xhc3QtbW9kaWZpZWQnLCAnbG9jYXRpb24nLCAnbWF4LWZvcndhcmRzJywgJ3Byb3h5LWF1dGhvcml6YXRpb24nLFxuICAncmVmZXJlcicsICdyZXRyeS1hZnRlcicsICd1c2VyLWFnZW50J1xuXSk7XG5cbi8qKlxuICogUGFyc2UgaGVhZGVycyBpbnRvIGFuIG9iamVjdFxuICpcbiAqIGBgYFxuICogRGF0ZTogV2VkLCAyNyBBdWcgMjAxNCAwODo1ODo0OSBHTVRcbiAqIENvbnRlbnQtVHlwZTogYXBwbGljYXRpb24vanNvblxuICogQ29ubmVjdGlvbjoga2VlcC1hbGl2ZVxuICogVHJhbnNmZXItRW5jb2Rpbmc6IGNodW5rZWRcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSByYXdIZWFkZXJzIEhlYWRlcnMgbmVlZGluZyB0byBiZSBwYXJzZWRcbiAqXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBIZWFkZXJzIHBhcnNlZCBpbnRvIGFuIG9iamVjdFxuICovXG5jb25zdCBwYXJzZUhlYWRlcnMgPSByYXdIZWFkZXJzID0+IHtcbiAgY29uc3QgcGFyc2VkID0ge307XG4gIGxldCBrZXk7XG4gIGxldCB2YWw7XG4gIGxldCBpO1xuXG4gIHJhd0hlYWRlcnMgJiYgcmF3SGVhZGVycy5zcGxpdCgnXFxuJykuZm9yRWFjaChmdW5jdGlvbiBwYXJzZXIobGluZSkge1xuICAgIGkgPSBsaW5lLmluZGV4T2YoJzonKTtcbiAgICBrZXkgPSBsaW5lLnN1YnN0cmluZygwLCBpKS50cmltKCkudG9Mb3dlckNhc2UoKTtcbiAgICB2YWwgPSBsaW5lLnN1YnN0cmluZyhpICsgMSkudHJpbSgpO1xuXG4gICAgaWYgKCFrZXkgfHwgKHBhcnNlZFtrZXldICYmIGlnbm9yZUR1cGxpY2F0ZU9mW2tleV0pKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGtleSA9PT0gJ3NldC1jb29raWUnKSB7XG4gICAgICBpZiAocGFyc2VkW2tleV0pIHtcbiAgICAgICAgcGFyc2VkW2tleV0ucHVzaCh2YWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyc2VkW2tleV0gPSBbdmFsXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcGFyc2VkW2tleV0gPSBwYXJzZWRba2V5XSA/IHBhcnNlZFtrZXldICsgJywgJyArIHZhbCA6IHZhbDtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBwYXJzZWQ7XG59O1xuXG5jb25zdCAkaW50ZXJuYWxzID0gU3ltYm9sKCdpbnRlcm5hbHMnKTtcblxuZnVuY3Rpb24gbm9ybWFsaXplSGVhZGVyKGhlYWRlcikge1xuICByZXR1cm4gaGVhZGVyICYmIFN0cmluZyhoZWFkZXIpLnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemVWYWx1ZSh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT09IGZhbHNlIHx8IHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gdXRpbHMkMS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlLm1hcChub3JtYWxpemVWYWx1ZSkgOiBTdHJpbmcodmFsdWUpO1xufVxuXG5mdW5jdGlvbiBwYXJzZVRva2VucyhzdHIpIHtcbiAgY29uc3QgdG9rZW5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgY29uc3QgdG9rZW5zUkUgPSAvKFteXFxzLDs9XSspXFxzKig/Oj1cXHMqKFteLDtdKykpPy9nO1xuICBsZXQgbWF0Y2g7XG5cbiAgd2hpbGUgKChtYXRjaCA9IHRva2Vuc1JFLmV4ZWMoc3RyKSkpIHtcbiAgICB0b2tlbnNbbWF0Y2hbMV1dID0gbWF0Y2hbMl07XG4gIH1cblxuICByZXR1cm4gdG9rZW5zO1xufVxuXG5jb25zdCBpc1ZhbGlkSGVhZGVyTmFtZSA9IChzdHIpID0+IC9eWy1fYS16QS1aMC05XmB8fiwhIyQlJicqKy5dKyQvLnRlc3Qoc3RyLnRyaW0oKSk7XG5cbmZ1bmN0aW9uIG1hdGNoSGVhZGVyVmFsdWUoY29udGV4dCwgdmFsdWUsIGhlYWRlciwgZmlsdGVyLCBpc0hlYWRlck5hbWVGaWx0ZXIpIHtcbiAgaWYgKHV0aWxzJDEuaXNGdW5jdGlvbihmaWx0ZXIpKSB7XG4gICAgcmV0dXJuIGZpbHRlci5jYWxsKHRoaXMsIHZhbHVlLCBoZWFkZXIpO1xuICB9XG5cbiAgaWYgKGlzSGVhZGVyTmFtZUZpbHRlcikge1xuICAgIHZhbHVlID0gaGVhZGVyO1xuICB9XG5cbiAgaWYgKCF1dGlscyQxLmlzU3RyaW5nKHZhbHVlKSkgcmV0dXJuO1xuXG4gIGlmICh1dGlscyQxLmlzU3RyaW5nKGZpbHRlcikpIHtcbiAgICByZXR1cm4gdmFsdWUuaW5kZXhPZihmaWx0ZXIpICE9PSAtMTtcbiAgfVxuXG4gIGlmICh1dGlscyQxLmlzUmVnRXhwKGZpbHRlcikpIHtcbiAgICByZXR1cm4gZmlsdGVyLnRlc3QodmFsdWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZvcm1hdEhlYWRlcihoZWFkZXIpIHtcbiAgcmV0dXJuIGhlYWRlci50cmltKClcbiAgICAudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC8oW2EtelxcZF0pKFxcdyopL2csICh3LCBjaGFyLCBzdHIpID0+IHtcbiAgICAgIHJldHVybiBjaGFyLnRvVXBwZXJDYXNlKCkgKyBzdHI7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGJ1aWxkQWNjZXNzb3JzKG9iaiwgaGVhZGVyKSB7XG4gIGNvbnN0IGFjY2Vzc29yTmFtZSA9IHV0aWxzJDEudG9DYW1lbENhc2UoJyAnICsgaGVhZGVyKTtcblxuICBbJ2dldCcsICdzZXQnLCAnaGFzJ10uZm9yRWFjaChtZXRob2ROYW1lID0+IHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBtZXRob2ROYW1lICsgYWNjZXNzb3JOYW1lLCB7XG4gICAgICB2YWx1ZTogZnVuY3Rpb24oYXJnMSwgYXJnMiwgYXJnMykge1xuICAgICAgICByZXR1cm4gdGhpc1ttZXRob2ROYW1lXS5jYWxsKHRoaXMsIGhlYWRlciwgYXJnMSwgYXJnMiwgYXJnMyk7XG4gICAgICB9LFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0pO1xufVxuXG5jbGFzcyBBeGlvc0hlYWRlcnMge1xuICBjb25zdHJ1Y3RvcihoZWFkZXJzKSB7XG4gICAgaGVhZGVycyAmJiB0aGlzLnNldChoZWFkZXJzKTtcbiAgfVxuXG4gIHNldChoZWFkZXIsIHZhbHVlT3JSZXdyaXRlLCByZXdyaXRlKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG5cbiAgICBmdW5jdGlvbiBzZXRIZWFkZXIoX3ZhbHVlLCBfaGVhZGVyLCBfcmV3cml0ZSkge1xuICAgICAgY29uc3QgbEhlYWRlciA9IG5vcm1hbGl6ZUhlYWRlcihfaGVhZGVyKTtcblxuICAgICAgaWYgKCFsSGVhZGVyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGVhZGVyIG5hbWUgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnKTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qga2V5ID0gdXRpbHMkMS5maW5kS2V5KHNlbGYsIGxIZWFkZXIpO1xuXG4gICAgICBpZigha2V5IHx8IHNlbGZba2V5XSA9PT0gdW5kZWZpbmVkIHx8IF9yZXdyaXRlID09PSB0cnVlIHx8IChfcmV3cml0ZSA9PT0gdW5kZWZpbmVkICYmIHNlbGZba2V5XSAhPT0gZmFsc2UpKSB7XG4gICAgICAgIHNlbGZba2V5IHx8IF9oZWFkZXJdID0gbm9ybWFsaXplVmFsdWUoX3ZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBzZXRIZWFkZXJzID0gKGhlYWRlcnMsIF9yZXdyaXRlKSA9PlxuICAgICAgdXRpbHMkMS5mb3JFYWNoKGhlYWRlcnMsIChfdmFsdWUsIF9oZWFkZXIpID0+IHNldEhlYWRlcihfdmFsdWUsIF9oZWFkZXIsIF9yZXdyaXRlKSk7XG5cbiAgICBpZiAodXRpbHMkMS5pc1BsYWluT2JqZWN0KGhlYWRlcikgfHwgaGVhZGVyIGluc3RhbmNlb2YgdGhpcy5jb25zdHJ1Y3Rvcikge1xuICAgICAgc2V0SGVhZGVycyhoZWFkZXIsIHZhbHVlT3JSZXdyaXRlKTtcbiAgICB9IGVsc2UgaWYodXRpbHMkMS5pc1N0cmluZyhoZWFkZXIpICYmIChoZWFkZXIgPSBoZWFkZXIudHJpbSgpKSAmJiAhaXNWYWxpZEhlYWRlck5hbWUoaGVhZGVyKSkge1xuICAgICAgc2V0SGVhZGVycyhwYXJzZUhlYWRlcnMoaGVhZGVyKSwgdmFsdWVPclJld3JpdGUpO1xuICAgIH0gZWxzZSBpZiAodXRpbHMkMS5pc09iamVjdChoZWFkZXIpICYmIHV0aWxzJDEuaXNJdGVyYWJsZShoZWFkZXIpKSB7XG4gICAgICBsZXQgb2JqID0ge30sIGRlc3QsIGtleTtcbiAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgaGVhZGVyKSB7XG4gICAgICAgIGlmICghdXRpbHMkMS5pc0FycmF5KGVudHJ5KSkge1xuICAgICAgICAgIHRocm93IFR5cGVFcnJvcignT2JqZWN0IGl0ZXJhdG9yIG11c3QgcmV0dXJuIGEga2V5LXZhbHVlIHBhaXInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9ialtrZXkgPSBlbnRyeVswXV0gPSAoZGVzdCA9IG9ialtrZXldKSA/XG4gICAgICAgICAgKHV0aWxzJDEuaXNBcnJheShkZXN0KSA/IFsuLi5kZXN0LCBlbnRyeVsxXV0gOiBbZGVzdCwgZW50cnlbMV1dKSA6IGVudHJ5WzFdO1xuICAgICAgfVxuXG4gICAgICBzZXRIZWFkZXJzKG9iaiwgdmFsdWVPclJld3JpdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBoZWFkZXIgIT0gbnVsbCAmJiBzZXRIZWFkZXIodmFsdWVPclJld3JpdGUsIGhlYWRlciwgcmV3cml0ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBnZXQoaGVhZGVyLCBwYXJzZXIpIHtcbiAgICBoZWFkZXIgPSBub3JtYWxpemVIZWFkZXIoaGVhZGVyKTtcblxuICAgIGlmIChoZWFkZXIpIHtcbiAgICAgIGNvbnN0IGtleSA9IHV0aWxzJDEuZmluZEtleSh0aGlzLCBoZWFkZXIpO1xuXG4gICAgICBpZiAoa2V5KSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpc1trZXldO1xuXG4gICAgICAgIGlmICghcGFyc2VyKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhcnNlciA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHJldHVybiBwYXJzZVRva2Vucyh2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodXRpbHMkMS5pc0Z1bmN0aW9uKHBhcnNlcikpIHtcbiAgICAgICAgICByZXR1cm4gcGFyc2VyLmNhbGwodGhpcywgdmFsdWUsIGtleSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodXRpbHMkMS5pc1JlZ0V4cChwYXJzZXIpKSB7XG4gICAgICAgICAgcmV0dXJuIHBhcnNlci5leGVjKHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3BhcnNlciBtdXN0IGJlIGJvb2xlYW58cmVnZXhwfGZ1bmN0aW9uJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaGFzKGhlYWRlciwgbWF0Y2hlcikge1xuICAgIGhlYWRlciA9IG5vcm1hbGl6ZUhlYWRlcihoZWFkZXIpO1xuXG4gICAgaWYgKGhlYWRlcikge1xuICAgICAgY29uc3Qga2V5ID0gdXRpbHMkMS5maW5kS2V5KHRoaXMsIGhlYWRlcik7XG5cbiAgICAgIHJldHVybiAhIShrZXkgJiYgdGhpc1trZXldICE9PSB1bmRlZmluZWQgJiYgKCFtYXRjaGVyIHx8IG1hdGNoSGVhZGVyVmFsdWUodGhpcywgdGhpc1trZXldLCBrZXksIG1hdGNoZXIpKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZGVsZXRlKGhlYWRlciwgbWF0Y2hlcikge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIGxldCBkZWxldGVkID0gZmFsc2U7XG5cbiAgICBmdW5jdGlvbiBkZWxldGVIZWFkZXIoX2hlYWRlcikge1xuICAgICAgX2hlYWRlciA9IG5vcm1hbGl6ZUhlYWRlcihfaGVhZGVyKTtcblxuICAgICAgaWYgKF9oZWFkZXIpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gdXRpbHMkMS5maW5kS2V5KHNlbGYsIF9oZWFkZXIpO1xuXG4gICAgICAgIGlmIChrZXkgJiYgKCFtYXRjaGVyIHx8IG1hdGNoSGVhZGVyVmFsdWUoc2VsZiwgc2VsZltrZXldLCBrZXksIG1hdGNoZXIpKSkge1xuICAgICAgICAgIGRlbGV0ZSBzZWxmW2tleV07XG5cbiAgICAgICAgICBkZWxldGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh1dGlscyQxLmlzQXJyYXkoaGVhZGVyKSkge1xuICAgICAgaGVhZGVyLmZvckVhY2goZGVsZXRlSGVhZGVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlSGVhZGVyKGhlYWRlcik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlbGV0ZWQ7XG4gIH1cblxuICBjbGVhcihtYXRjaGVyKSB7XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHRoaXMpO1xuICAgIGxldCBpID0ga2V5cy5sZW5ndGg7XG4gICAgbGV0IGRlbGV0ZWQgPSBmYWxzZTtcblxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGNvbnN0IGtleSA9IGtleXNbaV07XG4gICAgICBpZighbWF0Y2hlciB8fCBtYXRjaEhlYWRlclZhbHVlKHRoaXMsIHRoaXNba2V5XSwga2V5LCBtYXRjaGVyLCB0cnVlKSkge1xuICAgICAgICBkZWxldGUgdGhpc1trZXldO1xuICAgICAgICBkZWxldGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZGVsZXRlZDtcbiAgfVxuXG4gIG5vcm1hbGl6ZShmb3JtYXQpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBjb25zdCBoZWFkZXJzID0ge307XG5cbiAgICB1dGlscyQxLmZvckVhY2godGhpcywgKHZhbHVlLCBoZWFkZXIpID0+IHtcbiAgICAgIGNvbnN0IGtleSA9IHV0aWxzJDEuZmluZEtleShoZWFkZXJzLCBoZWFkZXIpO1xuXG4gICAgICBpZiAoa2V5KSB7XG4gICAgICAgIHNlbGZba2V5XSA9IG5vcm1hbGl6ZVZhbHVlKHZhbHVlKTtcbiAgICAgICAgZGVsZXRlIHNlbGZbaGVhZGVyXTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBub3JtYWxpemVkID0gZm9ybWF0ID8gZm9ybWF0SGVhZGVyKGhlYWRlcikgOiBTdHJpbmcoaGVhZGVyKS50cmltKCk7XG5cbiAgICAgIGlmIChub3JtYWxpemVkICE9PSBoZWFkZXIpIHtcbiAgICAgICAgZGVsZXRlIHNlbGZbaGVhZGVyXTtcbiAgICAgIH1cblxuICAgICAgc2VsZltub3JtYWxpemVkXSA9IG5vcm1hbGl6ZVZhbHVlKHZhbHVlKTtcblxuICAgICAgaGVhZGVyc1tub3JtYWxpemVkXSA9IHRydWU7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGNvbmNhdCguLi50YXJnZXRzKSB7XG4gICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IuY29uY2F0KHRoaXMsIC4uLnRhcmdldHMpO1xuICB9XG5cbiAgdG9KU09OKGFzU3RyaW5ncykge1xuICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgICB1dGlscyQxLmZvckVhY2godGhpcywgKHZhbHVlLCBoZWFkZXIpID0+IHtcbiAgICAgIHZhbHVlICE9IG51bGwgJiYgdmFsdWUgIT09IGZhbHNlICYmIChvYmpbaGVhZGVyXSA9IGFzU3RyaW5ncyAmJiB1dGlscyQxLmlzQXJyYXkodmFsdWUpID8gdmFsdWUuam9pbignLCAnKSA6IHZhbHVlKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICByZXR1cm4gT2JqZWN0LmVudHJpZXModGhpcy50b0pTT04oKSlbU3ltYm9sLml0ZXJhdG9yXSgpO1xuICB9XG5cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHRoaXMudG9KU09OKCkpLm1hcCgoW2hlYWRlciwgdmFsdWVdKSA9PiBoZWFkZXIgKyAnOiAnICsgdmFsdWUpLmpvaW4oJ1xcbicpO1xuICB9XG5cbiAgZ2V0U2V0Q29va2llKCkge1xuICAgIHJldHVybiB0aGlzLmdldChcInNldC1jb29raWVcIikgfHwgW107XG4gIH1cblxuICBnZXQgW1N5bWJvbC50b1N0cmluZ1RhZ10oKSB7XG4gICAgcmV0dXJuICdBeGlvc0hlYWRlcnMnO1xuICB9XG5cbiAgc3RhdGljIGZyb20odGhpbmcpIHtcbiAgICByZXR1cm4gdGhpbmcgaW5zdGFuY2VvZiB0aGlzID8gdGhpbmcgOiBuZXcgdGhpcyh0aGluZyk7XG4gIH1cblxuICBzdGF0aWMgY29uY2F0KGZpcnN0LCAuLi50YXJnZXRzKSB7XG4gICAgY29uc3QgY29tcHV0ZWQgPSBuZXcgdGhpcyhmaXJzdCk7XG5cbiAgICB0YXJnZXRzLmZvckVhY2goKHRhcmdldCkgPT4gY29tcHV0ZWQuc2V0KHRhcmdldCkpO1xuXG4gICAgcmV0dXJuIGNvbXB1dGVkO1xuICB9XG5cbiAgc3RhdGljIGFjY2Vzc29yKGhlYWRlcikge1xuICAgIGNvbnN0IGludGVybmFscyA9IHRoaXNbJGludGVybmFsc10gPSAodGhpc1skaW50ZXJuYWxzXSA9IHtcbiAgICAgIGFjY2Vzc29yczoge31cbiAgICB9KTtcblxuICAgIGNvbnN0IGFjY2Vzc29ycyA9IGludGVybmFscy5hY2Nlc3NvcnM7XG4gICAgY29uc3QgcHJvdG90eXBlID0gdGhpcy5wcm90b3R5cGU7XG5cbiAgICBmdW5jdGlvbiBkZWZpbmVBY2Nlc3NvcihfaGVhZGVyKSB7XG4gICAgICBjb25zdCBsSGVhZGVyID0gbm9ybWFsaXplSGVhZGVyKF9oZWFkZXIpO1xuXG4gICAgICBpZiAoIWFjY2Vzc29yc1tsSGVhZGVyXSkge1xuICAgICAgICBidWlsZEFjY2Vzc29ycyhwcm90b3R5cGUsIF9oZWFkZXIpO1xuICAgICAgICBhY2Nlc3NvcnNbbEhlYWRlcl0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHV0aWxzJDEuaXNBcnJheShoZWFkZXIpID8gaGVhZGVyLmZvckVhY2goZGVmaW5lQWNjZXNzb3IpIDogZGVmaW5lQWNjZXNzb3IoaGVhZGVyKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG59XG5cbkF4aW9zSGVhZGVycy5hY2Nlc3NvcihbJ0NvbnRlbnQtVHlwZScsICdDb250ZW50LUxlbmd0aCcsICdBY2NlcHQnLCAnQWNjZXB0LUVuY29kaW5nJywgJ1VzZXItQWdlbnQnLCAnQXV0aG9yaXphdGlvbiddKTtcblxuLy8gcmVzZXJ2ZWQgbmFtZXMgaG90Zml4XG51dGlscyQxLnJlZHVjZURlc2NyaXB0b3JzKEF4aW9zSGVhZGVycy5wcm90b3R5cGUsICh7dmFsdWV9LCBrZXkpID0+IHtcbiAgbGV0IG1hcHBlZCA9IGtleVswXS50b1VwcGVyQ2FzZSgpICsga2V5LnNsaWNlKDEpOyAvLyBtYXAgYHNldGAgPT4gYFNldGBcbiAgcmV0dXJuIHtcbiAgICBnZXQ6ICgpID0+IHZhbHVlLFxuICAgIHNldChoZWFkZXJWYWx1ZSkge1xuICAgICAgdGhpc1ttYXBwZWRdID0gaGVhZGVyVmFsdWU7XG4gICAgfVxuICB9XG59KTtcblxudXRpbHMkMS5mcmVlemVNZXRob2RzKEF4aW9zSGVhZGVycyk7XG5cbmNvbnN0IEF4aW9zSGVhZGVycyQxID0gQXhpb3NIZWFkZXJzO1xuXG4vKipcbiAqIFRyYW5zZm9ybSB0aGUgZGF0YSBmb3IgYSByZXF1ZXN0IG9yIGEgcmVzcG9uc2VcbiAqXG4gKiBAcGFyYW0ge0FycmF5fEZ1bmN0aW9ufSBmbnMgQSBzaW5nbGUgZnVuY3Rpb24gb3IgQXJyYXkgb2YgZnVuY3Rpb25zXG4gKiBAcGFyYW0gez9PYmplY3R9IHJlc3BvbnNlIFRoZSByZXNwb25zZSBvYmplY3RcbiAqXG4gKiBAcmV0dXJucyB7Kn0gVGhlIHJlc3VsdGluZyB0cmFuc2Zvcm1lZCBkYXRhXG4gKi9cbmZ1bmN0aW9uIHRyYW5zZm9ybURhdGEoZm5zLCByZXNwb25zZSkge1xuICBjb25zdCBjb25maWcgPSB0aGlzIHx8IGRlZmF1bHRzJDE7XG4gIGNvbnN0IGNvbnRleHQgPSByZXNwb25zZSB8fCBjb25maWc7XG4gIGNvbnN0IGhlYWRlcnMgPSBBeGlvc0hlYWRlcnMkMS5mcm9tKGNvbnRleHQuaGVhZGVycyk7XG4gIGxldCBkYXRhID0gY29udGV4dC5kYXRhO1xuXG4gIHV0aWxzJDEuZm9yRWFjaChmbnMsIGZ1bmN0aW9uIHRyYW5zZm9ybShmbikge1xuICAgIGRhdGEgPSBmbi5jYWxsKGNvbmZpZywgZGF0YSwgaGVhZGVycy5ub3JtYWxpemUoKSwgcmVzcG9uc2UgPyByZXNwb25zZS5zdGF0dXMgOiB1bmRlZmluZWQpO1xuICB9KTtcblxuICBoZWFkZXJzLm5vcm1hbGl6ZSgpO1xuXG4gIHJldHVybiBkYXRhO1xufVxuXG5mdW5jdGlvbiBpc0NhbmNlbCh2YWx1ZSkge1xuICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWUuX19DQU5DRUxfXyk7XG59XG5cbmNsYXNzIENhbmNlbGVkRXJyb3IgZXh0ZW5kcyBBeGlvc0Vycm9yJDEge1xuICAvKipcbiAgICogQSBgQ2FuY2VsZWRFcnJvcmAgaXMgYW4gb2JqZWN0IHRoYXQgaXMgdGhyb3duIHdoZW4gYW4gb3BlcmF0aW9uIGlzIGNhbmNlbGVkLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZz19IG1lc3NhZ2UgVGhlIG1lc3NhZ2UuXG4gICAqIEBwYXJhbSB7T2JqZWN0PX0gY29uZmlnIFRoZSBjb25maWcuXG4gICAqIEBwYXJhbSB7T2JqZWN0PX0gcmVxdWVzdCBUaGUgcmVxdWVzdC5cbiAgICpcbiAgICogQHJldHVybnMge0NhbmNlbGVkRXJyb3J9IFRoZSBjcmVhdGVkIGVycm9yLlxuICAgKi9cbiAgY29uc3RydWN0b3IobWVzc2FnZSwgY29uZmlnLCByZXF1ZXN0KSB7XG4gICAgc3VwZXIobWVzc2FnZSA9PSBudWxsID8gJ2NhbmNlbGVkJyA6IG1lc3NhZ2UsIEF4aW9zRXJyb3IkMS5FUlJfQ0FOQ0VMRUQsIGNvbmZpZywgcmVxdWVzdCk7XG4gICAgdGhpcy5uYW1lID0gJ0NhbmNlbGVkRXJyb3InO1xuICAgIHRoaXMuX19DQU5DRUxfXyA9IHRydWU7XG4gIH1cbn1cblxuY29uc3QgQ2FuY2VsZWRFcnJvciQxID0gQ2FuY2VsZWRFcnJvcjtcblxuLyoqXG4gKiBSZXNvbHZlIG9yIHJlamVjdCBhIFByb21pc2UgYmFzZWQgb24gcmVzcG9uc2Ugc3RhdHVzLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlc29sdmUgQSBmdW5jdGlvbiB0aGF0IHJlc29sdmVzIHRoZSBwcm9taXNlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVqZWN0IEEgZnVuY3Rpb24gdGhhdCByZWplY3RzIHRoZSBwcm9taXNlLlxuICogQHBhcmFtIHtvYmplY3R9IHJlc3BvbnNlIFRoZSByZXNwb25zZS5cbiAqXG4gKiBAcmV0dXJucyB7b2JqZWN0fSBUaGUgcmVzcG9uc2UuXG4gKi9cbmZ1bmN0aW9uIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHJlc3BvbnNlKSB7XG4gIGNvbnN0IHZhbGlkYXRlU3RhdHVzID0gcmVzcG9uc2UuY29uZmlnLnZhbGlkYXRlU3RhdHVzO1xuICBpZiAoIXJlc3BvbnNlLnN0YXR1cyB8fCAhdmFsaWRhdGVTdGF0dXMgfHwgdmFsaWRhdGVTdGF0dXMocmVzcG9uc2Uuc3RhdHVzKSkge1xuICAgIHJlc29sdmUocmVzcG9uc2UpO1xuICB9IGVsc2Uge1xuICAgIHJlamVjdChuZXcgQXhpb3NFcnJvciQxKFxuICAgICAgJ1JlcXVlc3QgZmFpbGVkIHdpdGggc3RhdHVzIGNvZGUgJyArIHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgIFtBeGlvc0Vycm9yJDEuRVJSX0JBRF9SRVFVRVNULCBBeGlvc0Vycm9yJDEuRVJSX0JBRF9SRVNQT05TRV1bTWF0aC5mbG9vcihyZXNwb25zZS5zdGF0dXMgLyAxMDApIC0gNF0sXG4gICAgICByZXNwb25zZS5jb25maWcsXG4gICAgICByZXNwb25zZS5yZXF1ZXN0LFxuICAgICAgcmVzcG9uc2VcbiAgICApKTtcbiAgfVxufVxuXG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciB0aGUgc3BlY2lmaWVkIFVSTCBpcyBhYnNvbHV0ZVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVGhlIFVSTCB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIHNwZWNpZmllZCBVUkwgaXMgYWJzb2x1dGUsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Fic29sdXRlVVJMKHVybCkge1xuICAvLyBBIFVSTCBpcyBjb25zaWRlcmVkIGFic29sdXRlIGlmIGl0IGJlZ2lucyB3aXRoIFwiPHNjaGVtZT46Ly9cIiBvciBcIi8vXCIgKHByb3RvY29sLXJlbGF0aXZlIFVSTCkuXG4gIC8vIFJGQyAzOTg2IGRlZmluZXMgc2NoZW1lIG5hbWUgYXMgYSBzZXF1ZW5jZSBvZiBjaGFyYWN0ZXJzIGJlZ2lubmluZyB3aXRoIGEgbGV0dGVyIGFuZCBmb2xsb3dlZFxuICAvLyBieSBhbnkgY29tYmluYXRpb24gb2YgbGV0dGVycywgZGlnaXRzLCBwbHVzLCBwZXJpb2QsIG9yIGh5cGhlbi5cbiAgcmV0dXJuIC9eKFthLXpdW2EtelxcZCtcXC0uXSo6KT9cXC9cXC8vaS50ZXN0KHVybCk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBVUkwgYnkgY29tYmluaW5nIHRoZSBzcGVjaWZpZWQgVVJMc1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlVVJMIFRoZSBiYXNlIFVSTFxuICogQHBhcmFtIHtzdHJpbmd9IHJlbGF0aXZlVVJMIFRoZSByZWxhdGl2ZSBVUkxcbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgY29tYmluZWQgVVJMXG4gKi9cbmZ1bmN0aW9uIGNvbWJpbmVVUkxzKGJhc2VVUkwsIHJlbGF0aXZlVVJMKSB7XG4gIHJldHVybiByZWxhdGl2ZVVSTFxuICAgID8gYmFzZVVSTC5yZXBsYWNlKC9cXC8/XFwvJC8sICcnKSArICcvJyArIHJlbGF0aXZlVVJMLnJlcGxhY2UoL15cXC8rLywgJycpXG4gICAgOiBiYXNlVVJMO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgVVJMIGJ5IGNvbWJpbmluZyB0aGUgYmFzZVVSTCB3aXRoIHRoZSByZXF1ZXN0ZWRVUkwsXG4gKiBvbmx5IHdoZW4gdGhlIHJlcXVlc3RlZFVSTCBpcyBub3QgYWxyZWFkeSBhbiBhYnNvbHV0ZSBVUkwuXG4gKiBJZiB0aGUgcmVxdWVzdFVSTCBpcyBhYnNvbHV0ZSwgdGhpcyBmdW5jdGlvbiByZXR1cm5zIHRoZSByZXF1ZXN0ZWRVUkwgdW50b3VjaGVkLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlVVJMIFRoZSBiYXNlIFVSTFxuICogQHBhcmFtIHtzdHJpbmd9IHJlcXVlc3RlZFVSTCBBYnNvbHV0ZSBvciByZWxhdGl2ZSBVUkwgdG8gY29tYmluZVxuICpcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBjb21iaW5lZCBmdWxsIHBhdGhcbiAqL1xuZnVuY3Rpb24gYnVpbGRGdWxsUGF0aChiYXNlVVJMLCByZXF1ZXN0ZWRVUkwsIGFsbG93QWJzb2x1dGVVcmxzKSB7XG4gIGxldCBpc1JlbGF0aXZlVXJsID0gIWlzQWJzb2x1dGVVUkwocmVxdWVzdGVkVVJMKTtcbiAgaWYgKGJhc2VVUkwgJiYgKGlzUmVsYXRpdmVVcmwgfHwgYWxsb3dBYnNvbHV0ZVVybHMgPT0gZmFsc2UpKSB7XG4gICAgcmV0dXJuIGNvbWJpbmVVUkxzKGJhc2VVUkwsIHJlcXVlc3RlZFVSTCk7XG4gIH1cbiAgcmV0dXJuIHJlcXVlc3RlZFVSTDtcbn1cblxuY29uc3QgVkVSU0lPTiA9IFwiMS4xMy40XCI7XG5cbmZ1bmN0aW9uIHBhcnNlUHJvdG9jb2wodXJsKSB7XG4gIGNvbnN0IG1hdGNoID0gL14oWy0rXFx3XXsxLDI1fSkoOj9cXC9cXC98OikvLmV4ZWModXJsKTtcbiAgcmV0dXJuIG1hdGNoICYmIG1hdGNoWzFdIHx8ICcnO1xufVxuXG5jb25zdCBEQVRBX1VSTF9QQVRURVJOID0gL14oPzooW147XSspOyk/KD86W147XSs7KT8oYmFzZTY0fCksKFtcXHNcXFNdKikkLztcblxuLyoqXG4gKiBQYXJzZSBkYXRhIHVyaSB0byBhIEJ1ZmZlciBvciBCbG9iXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVyaVxuICogQHBhcmFtIHs/Qm9vbGVhbn0gYXNCbG9iXG4gKiBAcGFyYW0gez9PYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7P0Z1bmN0aW9ufSBvcHRpb25zLkJsb2JcbiAqXG4gKiBAcmV0dXJucyB7QnVmZmVyfEJsb2J9XG4gKi9cbmZ1bmN0aW9uIGZyb21EYXRhVVJJKHVyaSwgYXNCbG9iLCBvcHRpb25zKSB7XG4gIGNvbnN0IF9CbG9iID0gb3B0aW9ucyAmJiBvcHRpb25zLkJsb2IgfHwgcGxhdGZvcm0uY2xhc3Nlcy5CbG9iO1xuICBjb25zdCBwcm90b2NvbCA9IHBhcnNlUHJvdG9jb2wodXJpKTtcblxuICBpZiAoYXNCbG9iID09PSB1bmRlZmluZWQgJiYgX0Jsb2IpIHtcbiAgICBhc0Jsb2IgPSB0cnVlO1xuICB9XG5cbiAgaWYgKHByb3RvY29sID09PSAnZGF0YScpIHtcbiAgICB1cmkgPSBwcm90b2NvbC5sZW5ndGggPyB1cmkuc2xpY2UocHJvdG9jb2wubGVuZ3RoICsgMSkgOiB1cmk7XG5cbiAgICBjb25zdCBtYXRjaCA9IERBVEFfVVJMX1BBVFRFUk4uZXhlYyh1cmkpO1xuXG4gICAgaWYgKCFtYXRjaCkge1xuICAgICAgdGhyb3cgbmV3IEF4aW9zRXJyb3IkMSgnSW52YWxpZCBVUkwnLCBBeGlvc0Vycm9yJDEuRVJSX0lOVkFMSURfVVJMKTtcbiAgICB9XG5cbiAgICBjb25zdCBtaW1lID0gbWF0Y2hbMV07XG4gICAgY29uc3QgaXNCYXNlNjQgPSBtYXRjaFsyXTtcbiAgICBjb25zdCBib2R5ID0gbWF0Y2hbM107XG4gICAgY29uc3QgYnVmZmVyID0gQnVmZmVyLmZyb20oZGVjb2RlVVJJQ29tcG9uZW50KGJvZHkpLCBpc0Jhc2U2NCA/ICdiYXNlNjQnIDogJ3V0ZjgnKTtcblxuICAgIGlmIChhc0Jsb2IpIHtcbiAgICAgIGlmICghX0Jsb2IpIHtcbiAgICAgICAgdGhyb3cgbmV3IEF4aW9zRXJyb3IkMSgnQmxvYiBpcyBub3Qgc3VwcG9ydGVkJywgQXhpb3NFcnJvciQxLkVSUl9OT1RfU1VQUE9SVCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgX0Jsb2IoW2J1ZmZlcl0sIHt0eXBlOiBtaW1lfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJ1ZmZlcjtcbiAgfVxuXG4gIHRocm93IG5ldyBBeGlvc0Vycm9yJDEoJ1Vuc3VwcG9ydGVkIHByb3RvY29sICcgKyBwcm90b2NvbCwgQXhpb3NFcnJvciQxLkVSUl9OT1RfU1VQUE9SVCk7XG59XG5cbmNvbnN0IGtJbnRlcm5hbHMgPSBTeW1ib2woJ2ludGVybmFscycpO1xuXG5jbGFzcyBBeGlvc1RyYW5zZm9ybVN0cmVhbSBleHRlbmRzIHN0cmVhbV9fZGVmYXVsdFtcImRlZmF1bHRcIl0uVHJhbnNmb3Jte1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHV0aWxzJDEudG9GbGF0T2JqZWN0KG9wdGlvbnMsIHtcbiAgICAgIG1heFJhdGU6IDAsXG4gICAgICBjaHVua1NpemU6IDY0ICogMTAyNCxcbiAgICAgIG1pbkNodW5rU2l6ZTogMTAwLFxuICAgICAgdGltZVdpbmRvdzogNTAwLFxuICAgICAgdGlja3NSYXRlOiAyLFxuICAgICAgc2FtcGxlc0NvdW50OiAxNVxuICAgIH0sIG51bGwsIChwcm9wLCBzb3VyY2UpID0+IHtcbiAgICAgIHJldHVybiAhdXRpbHMkMS5pc1VuZGVmaW5lZChzb3VyY2VbcHJvcF0pO1xuICAgIH0pO1xuXG4gICAgc3VwZXIoe1xuICAgICAgcmVhZGFibGVIaWdoV2F0ZXJNYXJrOiBvcHRpb25zLmNodW5rU2l6ZVxuICAgIH0pO1xuXG4gICAgY29uc3QgaW50ZXJuYWxzID0gdGhpc1trSW50ZXJuYWxzXSA9IHtcbiAgICAgIHRpbWVXaW5kb3c6IG9wdGlvbnMudGltZVdpbmRvdyxcbiAgICAgIGNodW5rU2l6ZTogb3B0aW9ucy5jaHVua1NpemUsXG4gICAgICBtYXhSYXRlOiBvcHRpb25zLm1heFJhdGUsXG4gICAgICBtaW5DaHVua1NpemU6IG9wdGlvbnMubWluQ2h1bmtTaXplLFxuICAgICAgYnl0ZXNTZWVuOiAwLFxuICAgICAgaXNDYXB0dXJlZDogZmFsc2UsXG4gICAgICBub3RpZmllZEJ5dGVzTG9hZGVkOiAwLFxuICAgICAgdHM6IERhdGUubm93KCksXG4gICAgICBieXRlczogMCxcbiAgICAgIG9uUmVhZENhbGxiYWNrOiBudWxsXG4gICAgfTtcblxuICAgIHRoaXMub24oJ25ld0xpc3RlbmVyJywgZXZlbnQgPT4ge1xuICAgICAgaWYgKGV2ZW50ID09PSAncHJvZ3Jlc3MnKSB7XG4gICAgICAgIGlmICghaW50ZXJuYWxzLmlzQ2FwdHVyZWQpIHtcbiAgICAgICAgICBpbnRlcm5hbHMuaXNDYXB0dXJlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIF9yZWFkKHNpemUpIHtcbiAgICBjb25zdCBpbnRlcm5hbHMgPSB0aGlzW2tJbnRlcm5hbHNdO1xuXG4gICAgaWYgKGludGVybmFscy5vblJlYWRDYWxsYmFjaykge1xuICAgICAgaW50ZXJuYWxzLm9uUmVhZENhbGxiYWNrKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN1cGVyLl9yZWFkKHNpemUpO1xuICB9XG5cbiAgX3RyYW5zZm9ybShjaHVuaywgZW5jb2RpbmcsIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgaW50ZXJuYWxzID0gdGhpc1trSW50ZXJuYWxzXTtcbiAgICBjb25zdCBtYXhSYXRlID0gaW50ZXJuYWxzLm1heFJhdGU7XG5cbiAgICBjb25zdCByZWFkYWJsZUhpZ2hXYXRlck1hcmsgPSB0aGlzLnJlYWRhYmxlSGlnaFdhdGVyTWFyaztcblxuICAgIGNvbnN0IHRpbWVXaW5kb3cgPSBpbnRlcm5hbHMudGltZVdpbmRvdztcblxuICAgIGNvbnN0IGRpdmlkZXIgPSAxMDAwIC8gdGltZVdpbmRvdztcbiAgICBjb25zdCBieXRlc1RocmVzaG9sZCA9IChtYXhSYXRlIC8gZGl2aWRlcik7XG4gICAgY29uc3QgbWluQ2h1bmtTaXplID0gaW50ZXJuYWxzLm1pbkNodW5rU2l6ZSAhPT0gZmFsc2UgPyBNYXRoLm1heChpbnRlcm5hbHMubWluQ2h1bmtTaXplLCBieXRlc1RocmVzaG9sZCAqIDAuMDEpIDogMDtcblxuICAgIGNvbnN0IHB1c2hDaHVuayA9IChfY2h1bmssIF9jYWxsYmFjaykgPT4ge1xuICAgICAgY29uc3QgYnl0ZXMgPSBCdWZmZXIuYnl0ZUxlbmd0aChfY2h1bmspO1xuICAgICAgaW50ZXJuYWxzLmJ5dGVzU2VlbiArPSBieXRlcztcbiAgICAgIGludGVybmFscy5ieXRlcyArPSBieXRlcztcblxuICAgICAgaW50ZXJuYWxzLmlzQ2FwdHVyZWQgJiYgdGhpcy5lbWl0KCdwcm9ncmVzcycsIGludGVybmFscy5ieXRlc1NlZW4pO1xuXG4gICAgICBpZiAodGhpcy5wdXNoKF9jaHVuaykpIHtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhfY2FsbGJhY2spO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW50ZXJuYWxzLm9uUmVhZENhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgICAgIGludGVybmFscy5vblJlYWRDYWxsYmFjayA9IG51bGw7XG4gICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhfY2FsbGJhY2spO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCB0cmFuc2Zvcm1DaHVuayA9IChfY2h1bmssIF9jYWxsYmFjaykgPT4ge1xuICAgICAgY29uc3QgY2h1bmtTaXplID0gQnVmZmVyLmJ5dGVMZW5ndGgoX2NodW5rKTtcbiAgICAgIGxldCBjaHVua1JlbWFpbmRlciA9IG51bGw7XG4gICAgICBsZXQgbWF4Q2h1bmtTaXplID0gcmVhZGFibGVIaWdoV2F0ZXJNYXJrO1xuICAgICAgbGV0IGJ5dGVzTGVmdDtcbiAgICAgIGxldCBwYXNzZWQgPSAwO1xuXG4gICAgICBpZiAobWF4UmF0ZSkge1xuICAgICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuXG4gICAgICAgIGlmICghaW50ZXJuYWxzLnRzIHx8IChwYXNzZWQgPSAobm93IC0gaW50ZXJuYWxzLnRzKSkgPj0gdGltZVdpbmRvdykge1xuICAgICAgICAgIGludGVybmFscy50cyA9IG5vdztcbiAgICAgICAgICBieXRlc0xlZnQgPSBieXRlc1RocmVzaG9sZCAtIGludGVybmFscy5ieXRlcztcbiAgICAgICAgICBpbnRlcm5hbHMuYnl0ZXMgPSBieXRlc0xlZnQgPCAwID8gLWJ5dGVzTGVmdCA6IDA7XG4gICAgICAgICAgcGFzc2VkID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGJ5dGVzTGVmdCA9IGJ5dGVzVGhyZXNob2xkIC0gaW50ZXJuYWxzLmJ5dGVzO1xuICAgICAgfVxuXG4gICAgICBpZiAobWF4UmF0ZSkge1xuICAgICAgICBpZiAoYnl0ZXNMZWZ0IDw9IDApIHtcbiAgICAgICAgICAvLyBuZXh0IHRpbWUgd2luZG93XG4gICAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgX2NhbGxiYWNrKG51bGwsIF9jaHVuayk7XG4gICAgICAgICAgfSwgdGltZVdpbmRvdyAtIHBhc3NlZCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYnl0ZXNMZWZ0IDwgbWF4Q2h1bmtTaXplKSB7XG4gICAgICAgICAgbWF4Q2h1bmtTaXplID0gYnl0ZXNMZWZ0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChtYXhDaHVua1NpemUgJiYgY2h1bmtTaXplID4gbWF4Q2h1bmtTaXplICYmIChjaHVua1NpemUgLSBtYXhDaHVua1NpemUpID4gbWluQ2h1bmtTaXplKSB7XG4gICAgICAgIGNodW5rUmVtYWluZGVyID0gX2NodW5rLnN1YmFycmF5KG1heENodW5rU2l6ZSk7XG4gICAgICAgIF9jaHVuayA9IF9jaHVuay5zdWJhcnJheSgwLCBtYXhDaHVua1NpemUpO1xuICAgICAgfVxuXG4gICAgICBwdXNoQ2h1bmsoX2NodW5rLCBjaHVua1JlbWFpbmRlciA/ICgpID0+IHtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhfY2FsbGJhY2ssIG51bGwsIGNodW5rUmVtYWluZGVyKTtcbiAgICAgIH0gOiBfY2FsbGJhY2spO1xuICAgIH07XG5cbiAgICB0cmFuc2Zvcm1DaHVuayhjaHVuaywgZnVuY3Rpb24gdHJhbnNmb3JtTmV4dENodW5rKGVyciwgX2NodW5rKSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoX2NodW5rKSB7XG4gICAgICAgIHRyYW5zZm9ybUNodW5rKF9jaHVuaywgdHJhbnNmb3JtTmV4dENodW5rKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbGxiYWNrKG51bGwpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbmNvbnN0IEF4aW9zVHJhbnNmb3JtU3RyZWFtJDEgPSBBeGlvc1RyYW5zZm9ybVN0cmVhbTtcblxuY29uc3Qge2FzeW5jSXRlcmF0b3J9ID0gU3ltYm9sO1xuXG5jb25zdCByZWFkQmxvYiA9IGFzeW5jIGZ1bmN0aW9uKiAoYmxvYikge1xuICBpZiAoYmxvYi5zdHJlYW0pIHtcbiAgICB5aWVsZCogYmxvYi5zdHJlYW0oKTtcbiAgfSBlbHNlIGlmIChibG9iLmFycmF5QnVmZmVyKSB7XG4gICAgeWllbGQgYXdhaXQgYmxvYi5hcnJheUJ1ZmZlcigpO1xuICB9IGVsc2UgaWYgKGJsb2JbYXN5bmNJdGVyYXRvcl0pIHtcbiAgICB5aWVsZCogYmxvYlthc3luY0l0ZXJhdG9yXSgpO1xuICB9IGVsc2Uge1xuICAgIHlpZWxkIGJsb2I7XG4gIH1cbn07XG5cbmNvbnN0IHJlYWRCbG9iJDEgPSByZWFkQmxvYjtcblxuY29uc3QgQk9VTkRBUllfQUxQSEFCRVQgPSBwbGF0Zm9ybS5BTFBIQUJFVC5BTFBIQV9ESUdJVCArICctXyc7XG5cbmNvbnN0IHRleHRFbmNvZGVyID0gdHlwZW9mIFRleHRFbmNvZGVyID09PSAnZnVuY3Rpb24nID8gbmV3IFRleHRFbmNvZGVyKCkgOiBuZXcgdXRpbF9fZGVmYXVsdFtcImRlZmF1bHRcIl0uVGV4dEVuY29kZXIoKTtcblxuY29uc3QgQ1JMRiA9ICdcXHJcXG4nO1xuY29uc3QgQ1JMRl9CWVRFUyA9IHRleHRFbmNvZGVyLmVuY29kZShDUkxGKTtcbmNvbnN0IENSTEZfQllURVNfQ09VTlQgPSAyO1xuXG5jbGFzcyBGb3JtRGF0YVBhcnQge1xuICBjb25zdHJ1Y3RvcihuYW1lLCB2YWx1ZSkge1xuICAgIGNvbnN0IHtlc2NhcGVOYW1lfSA9IHRoaXMuY29uc3RydWN0b3I7XG4gICAgY29uc3QgaXNTdHJpbmdWYWx1ZSA9IHV0aWxzJDEuaXNTdHJpbmcodmFsdWUpO1xuXG4gICAgbGV0IGhlYWRlcnMgPSBgQ29udGVudC1EaXNwb3NpdGlvbjogZm9ybS1kYXRhOyBuYW1lPVwiJHtlc2NhcGVOYW1lKG5hbWUpfVwiJHtcbiAgICAgICFpc1N0cmluZ1ZhbHVlICYmIHZhbHVlLm5hbWUgPyBgOyBmaWxlbmFtZT1cIiR7ZXNjYXBlTmFtZSh2YWx1ZS5uYW1lKX1cImAgOiAnJ1xuICAgIH0ke0NSTEZ9YDtcblxuICAgIGlmIChpc1N0cmluZ1ZhbHVlKSB7XG4gICAgICB2YWx1ZSA9IHRleHRFbmNvZGVyLmVuY29kZShTdHJpbmcodmFsdWUpLnJlcGxhY2UoL1xccj9cXG58XFxyXFxuPy9nLCBDUkxGKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhlYWRlcnMgKz0gYENvbnRlbnQtVHlwZTogJHt2YWx1ZS50eXBlIHx8IFwiYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtXCJ9JHtDUkxGfWA7XG4gICAgfVxuXG4gICAgdGhpcy5oZWFkZXJzID0gdGV4dEVuY29kZXIuZW5jb2RlKGhlYWRlcnMgKyBDUkxGKTtcblxuICAgIHRoaXMuY29udGVudExlbmd0aCA9IGlzU3RyaW5nVmFsdWUgPyB2YWx1ZS5ieXRlTGVuZ3RoIDogdmFsdWUuc2l6ZTtcblxuICAgIHRoaXMuc2l6ZSA9IHRoaXMuaGVhZGVycy5ieXRlTGVuZ3RoICsgdGhpcy5jb250ZW50TGVuZ3RoICsgQ1JMRl9CWVRFU19DT1VOVDtcblxuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICB9XG5cbiAgYXN5bmMgKmVuY29kZSgpe1xuICAgIHlpZWxkIHRoaXMuaGVhZGVycztcblxuICAgIGNvbnN0IHt2YWx1ZX0gPSB0aGlzO1xuXG4gICAgaWYodXRpbHMkMS5pc1R5cGVkQXJyYXkodmFsdWUpKSB7XG4gICAgICB5aWVsZCB2YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgeWllbGQqIHJlYWRCbG9iJDEodmFsdWUpO1xuICAgIH1cblxuICAgIHlpZWxkIENSTEZfQllURVM7XG4gIH1cblxuICBzdGF0aWMgZXNjYXBlTmFtZShuYW1lKSB7XG4gICAgICByZXR1cm4gU3RyaW5nKG5hbWUpLnJlcGxhY2UoL1tcXHJcXG5cIl0vZywgKG1hdGNoKSA9PiAoe1xuICAgICAgICAnXFxyJyA6ICclMEQnLFxuICAgICAgICAnXFxuJyA6ICclMEEnLFxuICAgICAgICAnXCInIDogJyUyMicsXG4gICAgICB9W21hdGNoXSkpO1xuICB9XG59XG5cbmNvbnN0IGZvcm1EYXRhVG9TdHJlYW0gPSAoZm9ybSwgaGVhZGVyc0hhbmRsZXIsIG9wdGlvbnMpID0+IHtcbiAgY29uc3Qge1xuICAgIHRhZyA9ICdmb3JtLWRhdGEtYm91bmRhcnknLFxuICAgIHNpemUgPSAyNSxcbiAgICBib3VuZGFyeSA9IHRhZyArICctJyArIHBsYXRmb3JtLmdlbmVyYXRlU3RyaW5nKHNpemUsIEJPVU5EQVJZX0FMUEhBQkVUKVxuICB9ID0gb3B0aW9ucyB8fCB7fTtcblxuICBpZighdXRpbHMkMS5pc0Zvcm1EYXRhKGZvcm0pKSB7XG4gICAgdGhyb3cgVHlwZUVycm9yKCdGb3JtRGF0YSBpbnN0YW5jZSByZXF1aXJlZCcpO1xuICB9XG5cbiAgaWYgKGJvdW5kYXJ5Lmxlbmd0aCA8IDEgfHwgYm91bmRhcnkubGVuZ3RoID4gNzApIHtcbiAgICB0aHJvdyBFcnJvcignYm91bmRhcnkgbXVzdCBiZSAxMC03MCBjaGFyYWN0ZXJzIGxvbmcnKVxuICB9XG5cbiAgY29uc3QgYm91bmRhcnlCeXRlcyA9IHRleHRFbmNvZGVyLmVuY29kZSgnLS0nICsgYm91bmRhcnkgKyBDUkxGKTtcbiAgY29uc3QgZm9vdGVyQnl0ZXMgPSB0ZXh0RW5jb2Rlci5lbmNvZGUoJy0tJyArIGJvdW5kYXJ5ICsgJy0tJyArIENSTEYpO1xuICBsZXQgY29udGVudExlbmd0aCA9IGZvb3RlckJ5dGVzLmJ5dGVMZW5ndGg7XG5cbiAgY29uc3QgcGFydHMgPSBBcnJheS5mcm9tKGZvcm0uZW50cmllcygpKS5tYXAoKFtuYW1lLCB2YWx1ZV0pID0+IHtcbiAgICBjb25zdCBwYXJ0ID0gbmV3IEZvcm1EYXRhUGFydChuYW1lLCB2YWx1ZSk7XG4gICAgY29udGVudExlbmd0aCArPSBwYXJ0LnNpemU7XG4gICAgcmV0dXJuIHBhcnQ7XG4gIH0pO1xuXG4gIGNvbnRlbnRMZW5ndGggKz0gYm91bmRhcnlCeXRlcy5ieXRlTGVuZ3RoICogcGFydHMubGVuZ3RoO1xuXG4gIGNvbnRlbnRMZW5ndGggPSB1dGlscyQxLnRvRmluaXRlTnVtYmVyKGNvbnRlbnRMZW5ndGgpO1xuXG4gIGNvbnN0IGNvbXB1dGVkSGVhZGVycyA9IHtcbiAgICAnQ29udGVudC1UeXBlJzogYG11bHRpcGFydC9mb3JtLWRhdGE7IGJvdW5kYXJ5PSR7Ym91bmRhcnl9YFxuICB9O1xuXG4gIGlmIChOdW1iZXIuaXNGaW5pdGUoY29udGVudExlbmd0aCkpIHtcbiAgICBjb21wdXRlZEhlYWRlcnNbJ0NvbnRlbnQtTGVuZ3RoJ10gPSBjb250ZW50TGVuZ3RoO1xuICB9XG5cbiAgaGVhZGVyc0hhbmRsZXIgJiYgaGVhZGVyc0hhbmRsZXIoY29tcHV0ZWRIZWFkZXJzKTtcblxuICByZXR1cm4gc3RyZWFtLlJlYWRhYmxlLmZyb20oKGFzeW5jIGZ1bmN0aW9uICooKSB7XG4gICAgZm9yKGNvbnN0IHBhcnQgb2YgcGFydHMpIHtcbiAgICAgIHlpZWxkIGJvdW5kYXJ5Qnl0ZXM7XG4gICAgICB5aWVsZCogcGFydC5lbmNvZGUoKTtcbiAgICB9XG5cbiAgICB5aWVsZCBmb290ZXJCeXRlcztcbiAgfSkoKSk7XG59O1xuXG5jb25zdCBmb3JtRGF0YVRvU3RyZWFtJDEgPSBmb3JtRGF0YVRvU3RyZWFtO1xuXG5jbGFzcyBabGliSGVhZGVyVHJhbnNmb3JtU3RyZWFtIGV4dGVuZHMgc3RyZWFtX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5UcmFuc2Zvcm0ge1xuICBfX3RyYW5zZm9ybShjaHVuaywgZW5jb2RpbmcsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5wdXNoKGNodW5rKTtcbiAgICBjYWxsYmFjaygpO1xuICB9XG5cbiAgX3RyYW5zZm9ybShjaHVuaywgZW5jb2RpbmcsIGNhbGxiYWNrKSB7XG4gICAgaWYgKGNodW5rLmxlbmd0aCAhPT0gMCkge1xuICAgICAgdGhpcy5fdHJhbnNmb3JtID0gdGhpcy5fX3RyYW5zZm9ybTtcblxuICAgICAgLy8gQWRkIERlZmF1bHQgQ29tcHJlc3Npb24gaGVhZGVycyBpZiBubyB6bGliIGhlYWRlcnMgYXJlIHByZXNlbnRcbiAgICAgIGlmIChjaHVua1swXSAhPT0gMTIwKSB7IC8vIEhleDogNzhcbiAgICAgICAgY29uc3QgaGVhZGVyID0gQnVmZmVyLmFsbG9jKDIpO1xuICAgICAgICBoZWFkZXJbMF0gPSAxMjA7IC8vIEhleDogNzhcbiAgICAgICAgaGVhZGVyWzFdID0gMTU2OyAvLyBIZXg6IDlDIFxuICAgICAgICB0aGlzLnB1c2goaGVhZGVyLCBlbmNvZGluZyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5fX3RyYW5zZm9ybShjaHVuaywgZW5jb2RpbmcsIGNhbGxiYWNrKTtcbiAgfVxufVxuXG5jb25zdCBabGliSGVhZGVyVHJhbnNmb3JtU3RyZWFtJDEgPSBabGliSGVhZGVyVHJhbnNmb3JtU3RyZWFtO1xuXG5jb25zdCBjYWxsYmFja2lmeSA9IChmbiwgcmVkdWNlcikgPT4ge1xuICByZXR1cm4gdXRpbHMkMS5pc0FzeW5jRm4oZm4pID8gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICBjb25zdCBjYiA9IGFyZ3MucG9wKCk7XG4gICAgZm4uYXBwbHkodGhpcywgYXJncykudGhlbigodmFsdWUpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJlZHVjZXIgPyBjYihudWxsLCAuLi5yZWR1Y2VyKHZhbHVlKSkgOiBjYihudWxsLCB2YWx1ZSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY2IoZXJyKTtcbiAgICAgIH1cbiAgICB9LCBjYik7XG4gIH0gOiBmbjtcbn07XG5cbmNvbnN0IGNhbGxiYWNraWZ5JDEgPSBjYWxsYmFja2lmeTtcblxuLyoqXG4gKiBDYWxjdWxhdGUgZGF0YSBtYXhSYXRlXG4gKiBAcGFyYW0ge051bWJlcn0gW3NhbXBsZXNDb3VudD0gMTBdXG4gKiBAcGFyYW0ge051bWJlcn0gW21pbj0gMTAwMF1cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn1cbiAqL1xuZnVuY3Rpb24gc3BlZWRvbWV0ZXIoc2FtcGxlc0NvdW50LCBtaW4pIHtcbiAgc2FtcGxlc0NvdW50ID0gc2FtcGxlc0NvdW50IHx8IDEwO1xuICBjb25zdCBieXRlcyA9IG5ldyBBcnJheShzYW1wbGVzQ291bnQpO1xuICBjb25zdCB0aW1lc3RhbXBzID0gbmV3IEFycmF5KHNhbXBsZXNDb3VudCk7XG4gIGxldCBoZWFkID0gMDtcbiAgbGV0IHRhaWwgPSAwO1xuICBsZXQgZmlyc3RTYW1wbGVUUztcblxuICBtaW4gPSBtaW4gIT09IHVuZGVmaW5lZCA/IG1pbiA6IDEwMDA7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHB1c2goY2h1bmtMZW5ndGgpIHtcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuXG4gICAgY29uc3Qgc3RhcnRlZEF0ID0gdGltZXN0YW1wc1t0YWlsXTtcblxuICAgIGlmICghZmlyc3RTYW1wbGVUUykge1xuICAgICAgZmlyc3RTYW1wbGVUUyA9IG5vdztcbiAgICB9XG5cbiAgICBieXRlc1toZWFkXSA9IGNodW5rTGVuZ3RoO1xuICAgIHRpbWVzdGFtcHNbaGVhZF0gPSBub3c7XG5cbiAgICBsZXQgaSA9IHRhaWw7XG4gICAgbGV0IGJ5dGVzQ291bnQgPSAwO1xuXG4gICAgd2hpbGUgKGkgIT09IGhlYWQpIHtcbiAgICAgIGJ5dGVzQ291bnQgKz0gYnl0ZXNbaSsrXTtcbiAgICAgIGkgPSBpICUgc2FtcGxlc0NvdW50O1xuICAgIH1cblxuICAgIGhlYWQgPSAoaGVhZCArIDEpICUgc2FtcGxlc0NvdW50O1xuXG4gICAgaWYgKGhlYWQgPT09IHRhaWwpIHtcbiAgICAgIHRhaWwgPSAodGFpbCArIDEpICUgc2FtcGxlc0NvdW50O1xuICAgIH1cblxuICAgIGlmIChub3cgLSBmaXJzdFNhbXBsZVRTIDwgbWluKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgcGFzc2VkID0gc3RhcnRlZEF0ICYmIG5vdyAtIHN0YXJ0ZWRBdDtcblxuICAgIHJldHVybiBwYXNzZWQgPyBNYXRoLnJvdW5kKGJ5dGVzQ291bnQgKiAxMDAwIC8gcGFzc2VkKSA6IHVuZGVmaW5lZDtcbiAgfTtcbn1cblxuLyoqXG4gKiBUaHJvdHRsZSBkZWNvcmF0b3JcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcGFyYW0ge051bWJlcn0gZnJlcVxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKi9cbmZ1bmN0aW9uIHRocm90dGxlKGZuLCBmcmVxKSB7XG4gIGxldCB0aW1lc3RhbXAgPSAwO1xuICBsZXQgdGhyZXNob2xkID0gMTAwMCAvIGZyZXE7XG4gIGxldCBsYXN0QXJncztcbiAgbGV0IHRpbWVyO1xuXG4gIGNvbnN0IGludm9rZSA9IChhcmdzLCBub3cgPSBEYXRlLm5vdygpKSA9PiB7XG4gICAgdGltZXN0YW1wID0gbm93O1xuICAgIGxhc3RBcmdzID0gbnVsbDtcbiAgICBpZiAodGltZXIpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICB0aW1lciA9IG51bGw7XG4gICAgfVxuICAgIGZuKC4uLmFyZ3MpO1xuICB9O1xuXG4gIGNvbnN0IHRocm90dGxlZCA9ICguLi5hcmdzKSA9PiB7XG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICBjb25zdCBwYXNzZWQgPSBub3cgLSB0aW1lc3RhbXA7XG4gICAgaWYgKCBwYXNzZWQgPj0gdGhyZXNob2xkKSB7XG4gICAgICBpbnZva2UoYXJncywgbm93KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGFzdEFyZ3MgPSBhcmdzO1xuICAgICAgaWYgKCF0aW1lcikge1xuICAgICAgICB0aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHRpbWVyID0gbnVsbDtcbiAgICAgICAgICBpbnZva2UobGFzdEFyZ3MpO1xuICAgICAgICB9LCB0aHJlc2hvbGQgLSBwYXNzZWQpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBjb25zdCBmbHVzaCA9ICgpID0+IGxhc3RBcmdzICYmIGludm9rZShsYXN0QXJncyk7XG5cbiAgcmV0dXJuIFt0aHJvdHRsZWQsIGZsdXNoXTtcbn1cblxuY29uc3QgcHJvZ3Jlc3NFdmVudFJlZHVjZXIgPSAobGlzdGVuZXIsIGlzRG93bmxvYWRTdHJlYW0sIGZyZXEgPSAzKSA9PiB7XG4gIGxldCBieXRlc05vdGlmaWVkID0gMDtcbiAgY29uc3QgX3NwZWVkb21ldGVyID0gc3BlZWRvbWV0ZXIoNTAsIDI1MCk7XG5cbiAgcmV0dXJuIHRocm90dGxlKGUgPT4ge1xuICAgIGNvbnN0IGxvYWRlZCA9IGUubG9hZGVkO1xuICAgIGNvbnN0IHRvdGFsID0gZS5sZW5ndGhDb21wdXRhYmxlID8gZS50b3RhbCA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCBwcm9ncmVzc0J5dGVzID0gbG9hZGVkIC0gYnl0ZXNOb3RpZmllZDtcbiAgICBjb25zdCByYXRlID0gX3NwZWVkb21ldGVyKHByb2dyZXNzQnl0ZXMpO1xuICAgIGNvbnN0IGluUmFuZ2UgPSBsb2FkZWQgPD0gdG90YWw7XG5cbiAgICBieXRlc05vdGlmaWVkID0gbG9hZGVkO1xuXG4gICAgY29uc3QgZGF0YSA9IHtcbiAgICAgIGxvYWRlZCxcbiAgICAgIHRvdGFsLFxuICAgICAgcHJvZ3Jlc3M6IHRvdGFsID8gKGxvYWRlZCAvIHRvdGFsKSA6IHVuZGVmaW5lZCxcbiAgICAgIGJ5dGVzOiBwcm9ncmVzc0J5dGVzLFxuICAgICAgcmF0ZTogcmF0ZSA/IHJhdGUgOiB1bmRlZmluZWQsXG4gICAgICBlc3RpbWF0ZWQ6IHJhdGUgJiYgdG90YWwgJiYgaW5SYW5nZSA/ICh0b3RhbCAtIGxvYWRlZCkgLyByYXRlIDogdW5kZWZpbmVkLFxuICAgICAgZXZlbnQ6IGUsXG4gICAgICBsZW5ndGhDb21wdXRhYmxlOiB0b3RhbCAhPSBudWxsLFxuICAgICAgW2lzRG93bmxvYWRTdHJlYW0gPyAnZG93bmxvYWQnIDogJ3VwbG9hZCddOiB0cnVlXG4gICAgfTtcblxuICAgIGxpc3RlbmVyKGRhdGEpO1xuICB9LCBmcmVxKTtcbn07XG5cbmNvbnN0IHByb2dyZXNzRXZlbnREZWNvcmF0b3IgPSAodG90YWwsIHRocm90dGxlZCkgPT4ge1xuICBjb25zdCBsZW5ndGhDb21wdXRhYmxlID0gdG90YWwgIT0gbnVsbDtcblxuICByZXR1cm4gWyhsb2FkZWQpID0+IHRocm90dGxlZFswXSh7XG4gICAgbGVuZ3RoQ29tcHV0YWJsZSxcbiAgICB0b3RhbCxcbiAgICBsb2FkZWRcbiAgfSksIHRocm90dGxlZFsxXV07XG59O1xuXG5jb25zdCBhc3luY0RlY29yYXRvciA9IChmbikgPT4gKC4uLmFyZ3MpID0+IHV0aWxzJDEuYXNhcCgoKSA9PiBmbiguLi5hcmdzKSk7XG5cbi8qKlxuICogRXN0aW1hdGUgZGVjb2RlZCBieXRlIGxlbmd0aCBvZiBhIGRhdGE6Ly8gVVJMICp3aXRob3V0KiBhbGxvY2F0aW5nIGxhcmdlIGJ1ZmZlcnMuXG4gKiAtIEZvciBiYXNlNjQ6IGNvbXB1dGUgZXhhY3QgZGVjb2RlZCBzaXplIHVzaW5nIGxlbmd0aCBhbmQgcGFkZGluZztcbiAqICAgICAgICAgICAgICAgaGFuZGxlICVYWCBhdCB0aGUgY2hhcmFjdGVyLWNvdW50IGxldmVsIChubyBzdHJpbmcgYWxsb2NhdGlvbikuXG4gKiAtIEZvciBub24tYmFzZTY0OiB1c2UgVVRGLTggYnl0ZUxlbmd0aCBvZiB0aGUgZW5jb2RlZCBib2R5IGFzIGEgc2FmZSB1cHBlciBib3VuZC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5mdW5jdGlvbiBlc3RpbWF0ZURhdGFVUkxEZWNvZGVkQnl0ZXModXJsKSB7XG4gIGlmICghdXJsIHx8IHR5cGVvZiB1cmwgIT09ICdzdHJpbmcnKSByZXR1cm4gMDtcbiAgaWYgKCF1cmwuc3RhcnRzV2l0aCgnZGF0YTonKSkgcmV0dXJuIDA7XG5cbiAgY29uc3QgY29tbWEgPSB1cmwuaW5kZXhPZignLCcpO1xuICBpZiAoY29tbWEgPCAwKSByZXR1cm4gMDtcblxuICBjb25zdCBtZXRhID0gdXJsLnNsaWNlKDUsIGNvbW1hKTtcbiAgY29uc3QgYm9keSA9IHVybC5zbGljZShjb21tYSArIDEpO1xuICBjb25zdCBpc0Jhc2U2NCA9IC87YmFzZTY0L2kudGVzdChtZXRhKTtcblxuICBpZiAoaXNCYXNlNjQpIHtcbiAgICBsZXQgZWZmZWN0aXZlTGVuID0gYm9keS5sZW5ndGg7XG4gICAgY29uc3QgbGVuID0gYm9keS5sZW5ndGg7IC8vIGNhY2hlIGxlbmd0aFxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgaWYgKGJvZHkuY2hhckNvZGVBdChpKSA9PT0gMzcgLyogJyUnICovICYmIGkgKyAyIDwgbGVuKSB7XG4gICAgICAgIGNvbnN0IGEgPSBib2R5LmNoYXJDb2RlQXQoaSArIDEpO1xuICAgICAgICBjb25zdCBiID0gYm9keS5jaGFyQ29kZUF0KGkgKyAyKTtcbiAgICAgICAgY29uc3QgaXNIZXggPVxuICAgICAgICAgICgoYSA+PSA0OCAmJiBhIDw9IDU3KSB8fCAoYSA+PSA2NSAmJiBhIDw9IDcwKSB8fCAoYSA+PSA5NyAmJiBhIDw9IDEwMikpICYmXG4gICAgICAgICAgKChiID49IDQ4ICYmIGIgPD0gNTcpIHx8IChiID49IDY1ICYmIGIgPD0gNzApIHx8IChiID49IDk3ICYmIGIgPD0gMTAyKSk7XG5cbiAgICAgICAgaWYgKGlzSGV4KSB7XG4gICAgICAgICAgZWZmZWN0aXZlTGVuIC09IDI7XG4gICAgICAgICAgaSArPSAyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IHBhZCA9IDA7XG4gICAgbGV0IGlkeCA9IGxlbiAtIDE7XG5cbiAgICBjb25zdCB0YWlsSXNQY3QzRCA9IChqKSA9PlxuICAgICAgaiA+PSAyICYmXG4gICAgICBib2R5LmNoYXJDb2RlQXQoaiAtIDIpID09PSAzNyAmJiAvLyAnJSdcbiAgICAgIGJvZHkuY2hhckNvZGVBdChqIC0gMSkgPT09IDUxICYmIC8vICczJ1xuICAgICAgKGJvZHkuY2hhckNvZGVBdChqKSA9PT0gNjggfHwgYm9keS5jaGFyQ29kZUF0KGopID09PSAxMDApOyAvLyAnRCcgb3IgJ2QnXG5cbiAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgIGlmIChib2R5LmNoYXJDb2RlQXQoaWR4KSA9PT0gNjEgLyogJz0nICovKSB7XG4gICAgICAgIHBhZCsrO1xuICAgICAgICBpZHgtLTtcbiAgICAgIH0gZWxzZSBpZiAodGFpbElzUGN0M0QoaWR4KSkge1xuICAgICAgICBwYWQrKztcbiAgICAgICAgaWR4IC09IDM7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBhZCA9PT0gMSAmJiBpZHggPj0gMCkge1xuICAgICAgaWYgKGJvZHkuY2hhckNvZGVBdChpZHgpID09PSA2MSAvKiAnPScgKi8pIHtcbiAgICAgICAgcGFkKys7XG4gICAgICB9IGVsc2UgaWYgKHRhaWxJc1BjdDNEKGlkeCkpIHtcbiAgICAgICAgcGFkKys7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgZ3JvdXBzID0gTWF0aC5mbG9vcihlZmZlY3RpdmVMZW4gLyA0KTtcbiAgICBjb25zdCBieXRlcyA9IGdyb3VwcyAqIDMgLSAocGFkIHx8IDApO1xuICAgIHJldHVybiBieXRlcyA+IDAgPyBieXRlcyA6IDA7XG4gIH1cblxuICByZXR1cm4gQnVmZmVyLmJ5dGVMZW5ndGgoYm9keSwgJ3V0ZjgnKTtcbn1cblxuY29uc3QgemxpYk9wdGlvbnMgPSB7XG4gIGZsdXNoOiB6bGliX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5jb25zdGFudHMuWl9TWU5DX0ZMVVNILFxuICBmaW5pc2hGbHVzaDogemxpYl9fZGVmYXVsdFtcImRlZmF1bHRcIl0uY29uc3RhbnRzLlpfU1lOQ19GTFVTSFxufTtcblxuY29uc3QgYnJvdGxpT3B0aW9ucyA9IHtcbiAgZmx1c2g6IHpsaWJfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmNvbnN0YW50cy5CUk9UTElfT1BFUkFUSU9OX0ZMVVNILFxuICBmaW5pc2hGbHVzaDogemxpYl9fZGVmYXVsdFtcImRlZmF1bHRcIl0uY29uc3RhbnRzLkJST1RMSV9PUEVSQVRJT05fRkxVU0hcbn07XG5cbmNvbnN0IGlzQnJvdGxpU3VwcG9ydGVkID0gdXRpbHMkMS5pc0Z1bmN0aW9uKHpsaWJfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmNyZWF0ZUJyb3RsaURlY29tcHJlc3MpO1xuXG5jb25zdCB7aHR0cDogaHR0cEZvbGxvdywgaHR0cHM6IGh0dHBzRm9sbG93fSA9IGZvbGxvd1JlZGlyZWN0c19fZGVmYXVsdFtcImRlZmF1bHRcIl07XG5cbmNvbnN0IGlzSHR0cHMgPSAvaHR0cHM6Py87XG5cbmNvbnN0IHN1cHBvcnRlZFByb3RvY29scyA9IHBsYXRmb3JtLnByb3RvY29scy5tYXAocHJvdG9jb2wgPT4ge1xuICByZXR1cm4gcHJvdG9jb2wgKyAnOic7XG59KTtcblxuXG5jb25zdCBmbHVzaE9uRmluaXNoID0gKHN0cmVhbSwgW3Rocm90dGxlZCwgZmx1c2hdKSA9PiB7XG4gIHN0cmVhbVxuICAgIC5vbignZW5kJywgZmx1c2gpXG4gICAgLm9uKCdlcnJvcicsIGZsdXNoKTtcblxuICByZXR1cm4gdGhyb3R0bGVkO1xufTtcblxuY2xhc3MgSHR0cDJTZXNzaW9ucyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuc2Vzc2lvbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB9XG5cbiAgZ2V0U2Vzc2lvbihhdXRob3JpdHksIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICBzZXNzaW9uVGltZW91dDogMTAwMFxuICAgIH0sIG9wdGlvbnMpO1xuXG4gICAgbGV0IGF1dGhvcml0eVNlc3Npb25zID0gdGhpcy5zZXNzaW9uc1thdXRob3JpdHldO1xuXG4gICAgaWYgKGF1dGhvcml0eVNlc3Npb25zKSB7XG4gICAgICBsZXQgbGVuID0gYXV0aG9yaXR5U2Vzc2lvbnMubGVuZ3RoO1xuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGNvbnN0IFtzZXNzaW9uSGFuZGxlLCBzZXNzaW9uT3B0aW9uc10gPSBhdXRob3JpdHlTZXNzaW9uc1tpXTtcbiAgICAgICAgaWYgKCFzZXNzaW9uSGFuZGxlLmRlc3Ryb3llZCAmJiAhc2Vzc2lvbkhhbmRsZS5jbG9zZWQgJiYgdXRpbF9fZGVmYXVsdFtcImRlZmF1bHRcIl0uaXNEZWVwU3RyaWN0RXF1YWwoc2Vzc2lvbk9wdGlvbnMsIG9wdGlvbnMpKSB7XG4gICAgICAgICAgcmV0dXJuIHNlc3Npb25IYW5kbGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBzZXNzaW9uID0gaHR0cDJfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmNvbm5lY3QoYXV0aG9yaXR5LCBvcHRpb25zKTtcblxuICAgIGxldCByZW1vdmVkO1xuXG4gICAgY29uc3QgcmVtb3ZlU2Vzc2lvbiA9ICgpID0+IHtcbiAgICAgIGlmIChyZW1vdmVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcmVtb3ZlZCA9IHRydWU7XG5cbiAgICAgIGxldCBlbnRyaWVzID0gYXV0aG9yaXR5U2Vzc2lvbnMsIGxlbiA9IGVudHJpZXMubGVuZ3RoLCBpID0gbGVuO1xuXG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIGlmIChlbnRyaWVzW2ldWzBdID09PSBzZXNzaW9uKSB7XG4gICAgICAgICAgaWYgKGxlbiA9PT0gMSkge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuc2Vzc2lvbnNbYXV0aG9yaXR5XTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZW50cmllcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCBvcmlnaW5hbFJlcXVlc3RGbiA9IHNlc3Npb24ucmVxdWVzdDtcblxuICAgIGNvbnN0IHtzZXNzaW9uVGltZW91dH0gPSBvcHRpb25zO1xuXG4gICAgaWYoc2Vzc2lvblRpbWVvdXQgIT0gbnVsbCkge1xuXG4gICAgICBsZXQgdGltZXI7XG4gICAgICBsZXQgc3RyZWFtc0NvdW50ID0gMDtcblxuICAgICAgc2Vzc2lvbi5yZXF1ZXN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zdCBzdHJlYW0gPSBvcmlnaW5hbFJlcXVlc3RGbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgICAgIHN0cmVhbXNDb3VudCsrO1xuXG4gICAgICAgIGlmICh0aW1lcikge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgICAgdGltZXIgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RyZWFtLm9uY2UoJ2Nsb3NlJywgKCkgPT4ge1xuICAgICAgICAgIGlmICghLS1zdHJlYW1zQ291bnQpIHtcbiAgICAgICAgICAgIHRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgIHRpbWVyID0gbnVsbDtcbiAgICAgICAgICAgICAgcmVtb3ZlU2Vzc2lvbigpO1xuICAgICAgICAgICAgfSwgc2Vzc2lvblRpbWVvdXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHN0cmVhbTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgc2Vzc2lvbi5vbmNlKCdjbG9zZScsIHJlbW92ZVNlc3Npb24pO1xuXG4gICAgbGV0IGVudHJ5ID0gW1xuICAgICAgICBzZXNzaW9uLFxuICAgICAgICBvcHRpb25zXG4gICAgICBdO1xuXG4gICAgYXV0aG9yaXR5U2Vzc2lvbnMgPyBhdXRob3JpdHlTZXNzaW9ucy5wdXNoKGVudHJ5KSA6IGF1dGhvcml0eVNlc3Npb25zID0gIHRoaXMuc2Vzc2lvbnNbYXV0aG9yaXR5XSA9IFtlbnRyeV07XG5cbiAgICByZXR1cm4gc2Vzc2lvbjtcbiAgfVxufVxuXG5jb25zdCBodHRwMlNlc3Npb25zID0gbmV3IEh0dHAyU2Vzc2lvbnMoKTtcblxuXG4vKipcbiAqIElmIHRoZSBwcm94eSBvciBjb25maWcgYmVmb3JlUmVkaXJlY3RzIGZ1bmN0aW9ucyBhcmUgZGVmaW5lZCwgY2FsbCB0aGVtIHdpdGggdGhlIG9wdGlvbnNcbiAqIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsIGFueT59IG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBvYmplY3QgdGhhdCB3YXMgcGFzc2VkIHRvIHRoZSByZXF1ZXN0LlxuICpcbiAqIEByZXR1cm5zIHtPYmplY3Q8c3RyaW5nLCBhbnk+fVxuICovXG5mdW5jdGlvbiBkaXNwYXRjaEJlZm9yZVJlZGlyZWN0KG9wdGlvbnMsIHJlc3BvbnNlRGV0YWlscykge1xuICBpZiAob3B0aW9ucy5iZWZvcmVSZWRpcmVjdHMucHJveHkpIHtcbiAgICBvcHRpb25zLmJlZm9yZVJlZGlyZWN0cy5wcm94eShvcHRpb25zKTtcbiAgfVxuICBpZiAob3B0aW9ucy5iZWZvcmVSZWRpcmVjdHMuY29uZmlnKSB7XG4gICAgb3B0aW9ucy5iZWZvcmVSZWRpcmVjdHMuY29uZmlnKG9wdGlvbnMsIHJlc3BvbnNlRGV0YWlscyk7XG4gIH1cbn1cblxuLyoqXG4gKiBJZiB0aGUgcHJveHkgb3IgY29uZmlnIGFmdGVyUmVkaXJlY3RzIGZ1bmN0aW9ucyBhcmUgZGVmaW5lZCwgY2FsbCB0aGVtIHdpdGggdGhlIG9wdGlvbnNcbiAqXG4gKiBAcGFyYW0ge2h0dHAuQ2xpZW50UmVxdWVzdEFyZ3N9IG9wdGlvbnNcbiAqIEBwYXJhbSB7QXhpb3NQcm94eUNvbmZpZ30gY29uZmlnUHJveHkgY29uZmlndXJhdGlvbiBmcm9tIEF4aW9zIG9wdGlvbnMgb2JqZWN0XG4gKiBAcGFyYW0ge3N0cmluZ30gbG9jYXRpb25cbiAqXG4gKiBAcmV0dXJucyB7aHR0cC5DbGllbnRSZXF1ZXN0QXJnc31cbiAqL1xuZnVuY3Rpb24gc2V0UHJveHkob3B0aW9ucywgY29uZmlnUHJveHksIGxvY2F0aW9uKSB7XG4gIGxldCBwcm94eSA9IGNvbmZpZ1Byb3h5O1xuICBpZiAoIXByb3h5ICYmIHByb3h5ICE9PSBmYWxzZSkge1xuICAgIGNvbnN0IHByb3h5VXJsID0gcHJveHlGcm9tRW52X19kZWZhdWx0W1wiZGVmYXVsdFwiXS5nZXRQcm94eUZvclVybChsb2NhdGlvbik7XG4gICAgaWYgKHByb3h5VXJsKSB7XG4gICAgICBwcm94eSA9IG5ldyBVUkwocHJveHlVcmwpO1xuICAgIH1cbiAgfVxuICBpZiAocHJveHkpIHtcbiAgICAvLyBCYXNpYyBwcm94eSBhdXRob3JpemF0aW9uXG4gICAgaWYgKHByb3h5LnVzZXJuYW1lKSB7XG4gICAgICBwcm94eS5hdXRoID0gKHByb3h5LnVzZXJuYW1lIHx8ICcnKSArICc6JyArIChwcm94eS5wYXNzd29yZCB8fCAnJyk7XG4gICAgfVxuXG4gICAgaWYgKHByb3h5LmF1dGgpIHtcbiAgICAgIC8vIFN1cHBvcnQgcHJveHkgYXV0aCBvYmplY3QgZm9ybVxuICAgICAgY29uc3QgdmFsaWRQcm94eUF1dGggPSBCb29sZWFuKHByb3h5LmF1dGgudXNlcm5hbWUgfHwgcHJveHkuYXV0aC5wYXNzd29yZCk7XG5cbiAgICAgIGlmICh2YWxpZFByb3h5QXV0aCkge1xuICAgICAgICBwcm94eS5hdXRoID0gKHByb3h5LmF1dGgudXNlcm5hbWUgfHwgJycpICsgJzonICsgKHByb3h5LmF1dGgucGFzc3dvcmQgfHwgJycpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcHJveHkuYXV0aCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEF4aW9zRXJyb3IkMSgnSW52YWxpZCBwcm94eSBhdXRob3JpemF0aW9uJywgQXhpb3NFcnJvciQxLkVSUl9CQURfT1BUSU9OLCB7IHByb3h5IH0pO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBiYXNlNjQgPSBCdWZmZXIuZnJvbShwcm94eS5hdXRoLCAndXRmOCcpLnRvU3RyaW5nKCdiYXNlNjQnKTtcblxuICAgICAgb3B0aW9ucy5oZWFkZXJzWydQcm94eS1BdXRob3JpemF0aW9uJ10gPSAnQmFzaWMgJyArIGJhc2U2NDtcbiAgICB9XG5cbiAgICBvcHRpb25zLmhlYWRlcnMuaG9zdCA9IG9wdGlvbnMuaG9zdG5hbWUgKyAob3B0aW9ucy5wb3J0ID8gJzonICsgb3B0aW9ucy5wb3J0IDogJycpO1xuICAgIGNvbnN0IHByb3h5SG9zdCA9IHByb3h5Lmhvc3RuYW1lIHx8IHByb3h5Lmhvc3Q7XG4gICAgb3B0aW9ucy5ob3N0bmFtZSA9IHByb3h5SG9zdDtcbiAgICAvLyBSZXBsYWNlICdob3N0JyBzaW5jZSBvcHRpb25zIGlzIG5vdCBhIFVSTCBvYmplY3RcbiAgICBvcHRpb25zLmhvc3QgPSBwcm94eUhvc3Q7XG4gICAgb3B0aW9ucy5wb3J0ID0gcHJveHkucG9ydDtcbiAgICBvcHRpb25zLnBhdGggPSBsb2NhdGlvbjtcbiAgICBpZiAocHJveHkucHJvdG9jb2wpIHtcbiAgICAgIG9wdGlvbnMucHJvdG9jb2wgPSBwcm94eS5wcm90b2NvbC5pbmNsdWRlcygnOicpID8gcHJveHkucHJvdG9jb2wgOiBgJHtwcm94eS5wcm90b2NvbH06YDtcbiAgICB9XG4gIH1cblxuICBvcHRpb25zLmJlZm9yZVJlZGlyZWN0cy5wcm94eSA9IGZ1bmN0aW9uIGJlZm9yZVJlZGlyZWN0KHJlZGlyZWN0T3B0aW9ucykge1xuICAgIC8vIENvbmZpZ3VyZSBwcm94eSBmb3IgcmVkaXJlY3RlZCByZXF1ZXN0LCBwYXNzaW5nIHRoZSBvcmlnaW5hbCBjb25maWcgcHJveHkgdG8gYXBwbHlcbiAgICAvLyB0aGUgZXhhY3Qgc2FtZSBsb2dpYyBhcyBpZiB0aGUgcmVkaXJlY3RlZCByZXF1ZXN0IHdhcyBwZXJmb3JtZWQgYnkgYXhpb3MgZGlyZWN0bHkuXG4gICAgc2V0UHJveHkocmVkaXJlY3RPcHRpb25zLCBjb25maWdQcm94eSwgcmVkaXJlY3RPcHRpb25zLmhyZWYpO1xuICB9O1xufVxuXG5jb25zdCBpc0h0dHBBZGFwdGVyU3VwcG9ydGVkID0gdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHV0aWxzJDEua2luZE9mKHByb2Nlc3MpID09PSAncHJvY2Vzcyc7XG5cbi8vIHRlbXBvcmFyeSBob3RmaXhcblxuY29uc3Qgd3JhcEFzeW5jID0gKGFzeW5jRXhlY3V0b3IpID0+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBsZXQgb25Eb25lO1xuICAgIGxldCBpc0RvbmU7XG5cbiAgICBjb25zdCBkb25lID0gKHZhbHVlLCBpc1JlamVjdGVkKSA9PiB7XG4gICAgICBpZiAoaXNEb25lKSByZXR1cm47XG4gICAgICBpc0RvbmUgPSB0cnVlO1xuICAgICAgb25Eb25lICYmIG9uRG9uZSh2YWx1ZSwgaXNSZWplY3RlZCk7XG4gICAgfTtcblxuICAgIGNvbnN0IF9yZXNvbHZlID0gKHZhbHVlKSA9PiB7XG4gICAgICBkb25lKHZhbHVlKTtcbiAgICAgIHJlc29sdmUodmFsdWUpO1xuICAgIH07XG5cbiAgICBjb25zdCBfcmVqZWN0ID0gKHJlYXNvbikgPT4ge1xuICAgICAgZG9uZShyZWFzb24sIHRydWUpO1xuICAgICAgcmVqZWN0KHJlYXNvbik7XG4gICAgfTtcblxuICAgIGFzeW5jRXhlY3V0b3IoX3Jlc29sdmUsIF9yZWplY3QsIChvbkRvbmVIYW5kbGVyKSA9PiAob25Eb25lID0gb25Eb25lSGFuZGxlcikpLmNhdGNoKF9yZWplY3QpO1xuICB9KVxufTtcblxuY29uc3QgcmVzb2x2ZUZhbWlseSA9ICh7YWRkcmVzcywgZmFtaWx5fSkgPT4ge1xuICBpZiAoIXV0aWxzJDEuaXNTdHJpbmcoYWRkcmVzcykpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2FkZHJlc3MgbXVzdCBiZSBhIHN0cmluZycpO1xuICB9XG4gIHJldHVybiAoe1xuICAgIGFkZHJlc3MsXG4gICAgZmFtaWx5OiBmYW1pbHkgfHwgKGFkZHJlc3MuaW5kZXhPZignLicpIDwgMCA/IDYgOiA0KVxuICB9KTtcbn07XG5cbmNvbnN0IGJ1aWxkQWRkcmVzc0VudHJ5ID0gKGFkZHJlc3MsIGZhbWlseSkgPT4gcmVzb2x2ZUZhbWlseSh1dGlscyQxLmlzT2JqZWN0KGFkZHJlc3MpID8gYWRkcmVzcyA6IHthZGRyZXNzLCBmYW1pbHl9KTtcblxuY29uc3QgaHR0cDJUcmFuc3BvcnQgPSB7XG4gIHJlcXVlc3Qob3B0aW9ucywgY2IpIHtcbiAgICAgIGNvbnN0IGF1dGhvcml0eSA9IG9wdGlvbnMucHJvdG9jb2wgKyAnLy8nICsgb3B0aW9ucy5ob3N0bmFtZSArICc6JyArIChvcHRpb25zLnBvcnQgfHwob3B0aW9ucy5wcm90b2NvbCA9PT0gJ2h0dHBzOicgPyA0NDMgOiA4MCkpO1xuXG5cbiAgICAgIGNvbnN0IHtodHRwMk9wdGlvbnMsIGhlYWRlcnN9ID0gb3B0aW9ucztcblxuICAgICAgY29uc3Qgc2Vzc2lvbiA9IGh0dHAyU2Vzc2lvbnMuZ2V0U2Vzc2lvbihhdXRob3JpdHksIGh0dHAyT3B0aW9ucyk7XG5cbiAgICAgIGNvbnN0IHtcbiAgICAgICAgSFRUUDJfSEVBREVSX1NDSEVNRSxcbiAgICAgICAgSFRUUDJfSEVBREVSX01FVEhPRCxcbiAgICAgICAgSFRUUDJfSEVBREVSX1BBVEgsXG4gICAgICAgIEhUVFAyX0hFQURFUl9TVEFUVVNcbiAgICAgIH0gPSBodHRwMl9fZGVmYXVsdFtcImRlZmF1bHRcIl0uY29uc3RhbnRzO1xuXG4gICAgICBjb25zdCBodHRwMkhlYWRlcnMgPSB7XG4gICAgICAgIFtIVFRQMl9IRUFERVJfU0NIRU1FXTogb3B0aW9ucy5wcm90b2NvbC5yZXBsYWNlKCc6JywgJycpLFxuICAgICAgICBbSFRUUDJfSEVBREVSX01FVEhPRF06IG9wdGlvbnMubWV0aG9kLFxuICAgICAgICBbSFRUUDJfSEVBREVSX1BBVEhdOiBvcHRpb25zLnBhdGgsXG4gICAgICB9O1xuXG4gICAgICB1dGlscyQxLmZvckVhY2goaGVhZGVycywgKGhlYWRlciwgbmFtZSkgPT4ge1xuICAgICAgICBuYW1lLmNoYXJBdCgwKSAhPT0gJzonICYmIChodHRwMkhlYWRlcnNbbmFtZV0gPSBoZWFkZXIpO1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlcSA9IHNlc3Npb24ucmVxdWVzdChodHRwMkhlYWRlcnMpO1xuXG4gICAgICByZXEub25jZSgncmVzcG9uc2UnLCAocmVzcG9uc2VIZWFkZXJzKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gcmVxOyAvL2R1cGxleFxuXG4gICAgICAgIHJlc3BvbnNlSGVhZGVycyA9IE9iamVjdC5hc3NpZ24oe30sIHJlc3BvbnNlSGVhZGVycyk7XG5cbiAgICAgICAgY29uc3Qgc3RhdHVzID0gcmVzcG9uc2VIZWFkZXJzW0hUVFAyX0hFQURFUl9TVEFUVVNdO1xuXG4gICAgICAgIGRlbGV0ZSByZXNwb25zZUhlYWRlcnNbSFRUUDJfSEVBREVSX1NUQVRVU107XG5cbiAgICAgICAgcmVzcG9uc2UuaGVhZGVycyA9IHJlc3BvbnNlSGVhZGVycztcblxuICAgICAgICByZXNwb25zZS5zdGF0dXNDb2RlID0gK3N0YXR1cztcblxuICAgICAgICBjYihyZXNwb25zZSk7XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHJlcTtcbiAgfVxufTtcblxuLyplc2xpbnQgY29uc2lzdGVudC1yZXR1cm46MCovXG5jb25zdCBodHRwQWRhcHRlciA9IGlzSHR0cEFkYXB0ZXJTdXBwb3J0ZWQgJiYgZnVuY3Rpb24gaHR0cEFkYXB0ZXIoY29uZmlnKSB7XG4gIHJldHVybiB3cmFwQXN5bmMoYXN5bmMgZnVuY3Rpb24gZGlzcGF0Y2hIdHRwUmVxdWVzdChyZXNvbHZlLCByZWplY3QsIG9uRG9uZSkge1xuICAgIGxldCB7ZGF0YSwgbG9va3VwLCBmYW1pbHksIGh0dHBWZXJzaW9uID0gMSwgaHR0cDJPcHRpb25zfSA9IGNvbmZpZztcbiAgICBjb25zdCB7cmVzcG9uc2VUeXBlLCByZXNwb25zZUVuY29kaW5nfSA9IGNvbmZpZztcbiAgICBjb25zdCBtZXRob2QgPSBjb25maWcubWV0aG9kLnRvVXBwZXJDYXNlKCk7XG4gICAgbGV0IGlzRG9uZTtcbiAgICBsZXQgcmVqZWN0ZWQgPSBmYWxzZTtcbiAgICBsZXQgcmVxO1xuXG4gICAgaHR0cFZlcnNpb24gPSAraHR0cFZlcnNpb247XG5cbiAgICBpZiAoTnVtYmVyLmlzTmFOKGh0dHBWZXJzaW9uKSkge1xuICAgICAgdGhyb3cgVHlwZUVycm9yKGBJbnZhbGlkIHByb3RvY29sIHZlcnNpb246ICcke2NvbmZpZy5odHRwVmVyc2lvbn0nIGlzIG5vdCBhIG51bWJlcmApO1xuICAgIH1cblxuICAgIGlmIChodHRwVmVyc2lvbiAhPT0gMSAmJiBodHRwVmVyc2lvbiAhPT0gMikge1xuICAgICAgdGhyb3cgVHlwZUVycm9yKGBVbnN1cHBvcnRlZCBwcm90b2NvbCB2ZXJzaW9uICcke2h0dHBWZXJzaW9ufSdgKTtcbiAgICB9XG5cbiAgICBjb25zdCBpc0h0dHAyID0gaHR0cFZlcnNpb24gPT09IDI7XG5cbiAgICBpZiAobG9va3VwKSB7XG4gICAgICBjb25zdCBfbG9va3VwID0gY2FsbGJhY2tpZnkkMShsb29rdXAsICh2YWx1ZSkgPT4gdXRpbHMkMS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogW3ZhbHVlXSk7XG4gICAgICAvLyBob3RmaXggdG8gc3VwcG9ydCBvcHQuYWxsIG9wdGlvbiB3aGljaCBpcyByZXF1aXJlZCBmb3Igbm9kZSAyMC54XG4gICAgICBsb29rdXAgPSAoaG9zdG5hbWUsIG9wdCwgY2IpID0+IHtcbiAgICAgICAgX2xvb2t1cChob3N0bmFtZSwgb3B0LCAoZXJyLCBhcmcwLCBhcmcxKSA9PiB7XG4gICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIGNiKGVycik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgYWRkcmVzc2VzID0gdXRpbHMkMS5pc0FycmF5KGFyZzApID8gYXJnMC5tYXAoYWRkciA9PiBidWlsZEFkZHJlc3NFbnRyeShhZGRyKSkgOiBbYnVpbGRBZGRyZXNzRW50cnkoYXJnMCwgYXJnMSldO1xuXG4gICAgICAgICAgb3B0LmFsbCA/IGNiKGVyciwgYWRkcmVzc2VzKSA6IGNiKGVyciwgYWRkcmVzc2VzWzBdLmFkZHJlc3MsIGFkZHJlc3Nlc1swXS5mYW1pbHkpO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgY29uc3QgYWJvcnRFbWl0dGVyID0gbmV3IGV2ZW50cy5FdmVudEVtaXR0ZXIoKTtcblxuICAgIGZ1bmN0aW9uIGFib3J0KHJlYXNvbikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgYWJvcnRFbWl0dGVyLmVtaXQoJ2Fib3J0JywgIXJlYXNvbiB8fCByZWFzb24udHlwZSA/IG5ldyBDYW5jZWxlZEVycm9yJDEobnVsbCwgY29uZmlnLCByZXEpIDogcmVhc29uKTtcbiAgICAgIH0gY2F0Y2goZXJyKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignZW1pdCBlcnJvcicsIGVycik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgYWJvcnRFbWl0dGVyLm9uY2UoJ2Fib3J0JywgcmVqZWN0KTtcblxuICAgIGNvbnN0IG9uRmluaXNoZWQgPSAoKSA9PiB7XG4gICAgICBpZiAoY29uZmlnLmNhbmNlbFRva2VuKSB7XG4gICAgICAgIGNvbmZpZy5jYW5jZWxUb2tlbi51bnN1YnNjcmliZShhYm9ydCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjb25maWcuc2lnbmFsKSB7XG4gICAgICAgIGNvbmZpZy5zaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBhYm9ydCk7XG4gICAgICB9XG5cbiAgICAgIGFib3J0RW1pdHRlci5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICB9O1xuXG4gICAgaWYgKGNvbmZpZy5jYW5jZWxUb2tlbiB8fCBjb25maWcuc2lnbmFsKSB7XG4gICAgICBjb25maWcuY2FuY2VsVG9rZW4gJiYgY29uZmlnLmNhbmNlbFRva2VuLnN1YnNjcmliZShhYm9ydCk7XG4gICAgICBpZiAoY29uZmlnLnNpZ25hbCkge1xuICAgICAgICBjb25maWcuc2lnbmFsLmFib3J0ZWQgPyBhYm9ydCgpIDogY29uZmlnLnNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsIGFib3J0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBvbkRvbmUoKHJlc3BvbnNlLCBpc1JlamVjdGVkKSA9PiB7XG4gICAgICBpc0RvbmUgPSB0cnVlO1xuXG4gICAgICBpZiAoaXNSZWplY3RlZCkge1xuICAgICAgICByZWplY3RlZCA9IHRydWU7XG4gICAgICAgIG9uRmluaXNoZWQoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB7ZGF0YX0gPSByZXNwb25zZTtcblxuICAgICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBzdHJlYW1fX2RlZmF1bHRbXCJkZWZhdWx0XCJdLlJlYWRhYmxlIHx8IGRhdGEgaW5zdGFuY2VvZiBzdHJlYW1fX2RlZmF1bHRbXCJkZWZhdWx0XCJdLkR1cGxleCkge1xuICAgICAgICBjb25zdCBvZmZMaXN0ZW5lcnMgPSBzdHJlYW1fX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmZpbmlzaGVkKGRhdGEsICgpID0+IHtcbiAgICAgICAgICBvZmZMaXN0ZW5lcnMoKTtcbiAgICAgICAgICBvbkZpbmlzaGVkKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb25GaW5pc2hlZCgpO1xuICAgICAgfVxuICAgIH0pO1xuXG5cblxuXG5cbiAgICAvLyBQYXJzZSB1cmxcbiAgICBjb25zdCBmdWxsUGF0aCA9IGJ1aWxkRnVsbFBhdGgoY29uZmlnLmJhc2VVUkwsIGNvbmZpZy51cmwsIGNvbmZpZy5hbGxvd0Fic29sdXRlVXJscyk7XG4gICAgY29uc3QgcGFyc2VkID0gbmV3IFVSTChmdWxsUGF0aCwgcGxhdGZvcm0uaGFzQnJvd3NlckVudiA/IHBsYXRmb3JtLm9yaWdpbiA6IHVuZGVmaW5lZCk7XG4gICAgY29uc3QgcHJvdG9jb2wgPSBwYXJzZWQucHJvdG9jb2wgfHwgc3VwcG9ydGVkUHJvdG9jb2xzWzBdO1xuXG4gICAgaWYgKHByb3RvY29sID09PSAnZGF0YTonKSB7XG4gICAgICAvLyBBcHBseSB0aGUgc2FtZSBzZW1hbnRpY3MgYXMgSFRUUDogb25seSBlbmZvcmNlIGlmIGEgZmluaXRlLCBub24tbmVnYXRpdmUgY2FwIGlzIHNldC5cbiAgICAgIGlmIChjb25maWcubWF4Q29udGVudExlbmd0aCA+IC0xKSB7XG4gICAgICAgIC8vIFVzZSB0aGUgZXhhY3Qgc3RyaW5nIHBhc3NlZCB0byBmcm9tRGF0YVVSSSAoY29uZmlnLnVybCk7IGZhbGwgYmFjayB0byBmdWxsUGF0aCBpZiBuZWVkZWQuXG4gICAgICAgIGNvbnN0IGRhdGFVcmwgPSBTdHJpbmcoY29uZmlnLnVybCB8fCBmdWxsUGF0aCB8fCAnJyk7XG4gICAgICAgIGNvbnN0IGVzdGltYXRlZCA9IGVzdGltYXRlRGF0YVVSTERlY29kZWRCeXRlcyhkYXRhVXJsKTtcblxuICAgICAgICBpZiAoZXN0aW1hdGVkID4gY29uZmlnLm1heENvbnRlbnRMZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBBeGlvc0Vycm9yJDEoXG4gICAgICAgICAgICAnbWF4Q29udGVudExlbmd0aCBzaXplIG9mICcgKyBjb25maWcubWF4Q29udGVudExlbmd0aCArICcgZXhjZWVkZWQnLFxuICAgICAgICAgICAgQXhpb3NFcnJvciQxLkVSUl9CQURfUkVTUE9OU0UsXG4gICAgICAgICAgICBjb25maWdcbiAgICAgICAgICApKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBsZXQgY29udmVydGVkRGF0YTtcblxuICAgICAgaWYgKG1ldGhvZCAhPT0gJ0dFVCcpIHtcbiAgICAgICAgcmV0dXJuIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHtcbiAgICAgICAgICBzdGF0dXM6IDQwNSxcbiAgICAgICAgICBzdGF0dXNUZXh0OiAnbWV0aG9kIG5vdCBhbGxvd2VkJyxcbiAgICAgICAgICBoZWFkZXJzOiB7fSxcbiAgICAgICAgICBjb25maWdcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnZlcnRlZERhdGEgPSBmcm9tRGF0YVVSSShjb25maWcudXJsLCByZXNwb25zZVR5cGUgPT09ICdibG9iJywge1xuICAgICAgICAgIEJsb2I6IGNvbmZpZy5lbnYgJiYgY29uZmlnLmVudi5CbG9iXG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHRocm93IEF4aW9zRXJyb3IkMS5mcm9tKGVyciwgQXhpb3NFcnJvciQxLkVSUl9CQURfUkVRVUVTVCwgY29uZmlnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlc3BvbnNlVHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgIGNvbnZlcnRlZERhdGEgPSBjb252ZXJ0ZWREYXRhLnRvU3RyaW5nKHJlc3BvbnNlRW5jb2RpbmcpO1xuXG4gICAgICAgIGlmICghcmVzcG9uc2VFbmNvZGluZyB8fCByZXNwb25zZUVuY29kaW5nID09PSAndXRmOCcpIHtcbiAgICAgICAgICBjb252ZXJ0ZWREYXRhID0gdXRpbHMkMS5zdHJpcEJPTShjb252ZXJ0ZWREYXRhKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChyZXNwb25zZVR5cGUgPT09ICdzdHJlYW0nKSB7XG4gICAgICAgIGNvbnZlcnRlZERhdGEgPSBzdHJlYW1fX2RlZmF1bHRbXCJkZWZhdWx0XCJdLlJlYWRhYmxlLmZyb20oY29udmVydGVkRGF0YSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCB7XG4gICAgICAgIGRhdGE6IGNvbnZlcnRlZERhdGEsXG4gICAgICAgIHN0YXR1czogMjAwLFxuICAgICAgICBzdGF0dXNUZXh0OiAnT0snLFxuICAgICAgICBoZWFkZXJzOiBuZXcgQXhpb3NIZWFkZXJzJDEoKSxcbiAgICAgICAgY29uZmlnXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoc3VwcG9ydGVkUHJvdG9jb2xzLmluZGV4T2YocHJvdG9jb2wpID09PSAtMSkge1xuICAgICAgcmV0dXJuIHJlamVjdChuZXcgQXhpb3NFcnJvciQxKFxuICAgICAgICAnVW5zdXBwb3J0ZWQgcHJvdG9jb2wgJyArIHByb3RvY29sLFxuICAgICAgICBBeGlvc0Vycm9yJDEuRVJSX0JBRF9SRVFVRVNULFxuICAgICAgICBjb25maWdcbiAgICAgICkpO1xuICAgIH1cblxuICAgIGNvbnN0IGhlYWRlcnMgPSBBeGlvc0hlYWRlcnMkMS5mcm9tKGNvbmZpZy5oZWFkZXJzKS5ub3JtYWxpemUoKTtcblxuICAgIC8vIFNldCBVc2VyLUFnZW50IChyZXF1aXJlZCBieSBzb21lIHNlcnZlcnMpXG4gICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9heGlvcy9heGlvcy9pc3N1ZXMvNjlcbiAgICAvLyBVc2VyLUFnZW50IGlzIHNwZWNpZmllZDsgaGFuZGxlIGNhc2Ugd2hlcmUgbm8gVUEgaGVhZGVyIGlzIGRlc2lyZWRcbiAgICAvLyBPbmx5IHNldCBoZWFkZXIgaWYgaXQgaGFzbid0IGJlZW4gc2V0IGluIGNvbmZpZ1xuICAgIGhlYWRlcnMuc2V0KCdVc2VyLUFnZW50JywgJ2F4aW9zLycgKyBWRVJTSU9OLCBmYWxzZSk7XG5cbiAgICBjb25zdCB7b25VcGxvYWRQcm9ncmVzcywgb25Eb3dubG9hZFByb2dyZXNzfSA9IGNvbmZpZztcbiAgICBjb25zdCBtYXhSYXRlID0gY29uZmlnLm1heFJhdGU7XG4gICAgbGV0IG1heFVwbG9hZFJhdGUgPSB1bmRlZmluZWQ7XG4gICAgbGV0IG1heERvd25sb2FkUmF0ZSA9IHVuZGVmaW5lZDtcblxuICAgIC8vIHN1cHBvcnQgZm9yIHNwZWMgY29tcGxpYW50IEZvcm1EYXRhIG9iamVjdHNcbiAgICBpZiAodXRpbHMkMS5pc1NwZWNDb21wbGlhbnRGb3JtKGRhdGEpKSB7XG4gICAgICBjb25zdCB1c2VyQm91bmRhcnkgPSBoZWFkZXJzLmdldENvbnRlbnRUeXBlKC9ib3VuZGFyeT0oWy1fXFx3XFxkXXsxMCw3MH0pL2kpO1xuXG4gICAgICBkYXRhID0gZm9ybURhdGFUb1N0cmVhbSQxKGRhdGEsIChmb3JtSGVhZGVycykgPT4ge1xuICAgICAgICBoZWFkZXJzLnNldChmb3JtSGVhZGVycyk7XG4gICAgICB9LCB7XG4gICAgICAgIHRhZzogYGF4aW9zLSR7VkVSU0lPTn0tYm91bmRhcnlgLFxuICAgICAgICBib3VuZGFyeTogdXNlckJvdW5kYXJ5ICYmIHVzZXJCb3VuZGFyeVsxXSB8fCB1bmRlZmluZWRcbiAgICAgIH0pO1xuICAgICAgLy8gc3VwcG9ydCBmb3IgaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvZm9ybS1kYXRhIGFwaVxuICAgIH0gZWxzZSBpZiAodXRpbHMkMS5pc0Zvcm1EYXRhKGRhdGEpICYmIHV0aWxzJDEuaXNGdW5jdGlvbihkYXRhLmdldEhlYWRlcnMpKSB7XG4gICAgICBoZWFkZXJzLnNldChkYXRhLmdldEhlYWRlcnMoKSk7XG5cbiAgICAgIGlmICghaGVhZGVycy5oYXNDb250ZW50TGVuZ3RoKCkpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBrbm93bkxlbmd0aCA9IGF3YWl0IHV0aWxfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLnByb21pc2lmeShkYXRhLmdldExlbmd0aCkuY2FsbChkYXRhKTtcbiAgICAgICAgICBOdW1iZXIuaXNGaW5pdGUoa25vd25MZW5ndGgpICYmIGtub3duTGVuZ3RoID49IDAgJiYgaGVhZGVycy5zZXRDb250ZW50TGVuZ3RoKGtub3duTGVuZ3RoKTtcbiAgICAgICAgICAvKmVzbGludCBuby1lbXB0eTowKi9cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh1dGlscyQxLmlzQmxvYihkYXRhKSB8fCB1dGlscyQxLmlzRmlsZShkYXRhKSkge1xuICAgICAgZGF0YS5zaXplICYmIGhlYWRlcnMuc2V0Q29udGVudFR5cGUoZGF0YS50eXBlIHx8ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nKTtcbiAgICAgIGhlYWRlcnMuc2V0Q29udGVudExlbmd0aChkYXRhLnNpemUgfHwgMCk7XG4gICAgICBkYXRhID0gc3RyZWFtX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5SZWFkYWJsZS5mcm9tKHJlYWRCbG9iJDEoZGF0YSkpO1xuICAgIH0gZWxzZSBpZiAoZGF0YSAmJiAhdXRpbHMkMS5pc1N0cmVhbShkYXRhKSkge1xuICAgICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihkYXRhKSkgOyBlbHNlIGlmICh1dGlscyQxLmlzQXJyYXlCdWZmZXIoZGF0YSkpIHtcbiAgICAgICAgZGF0YSA9IEJ1ZmZlci5mcm9tKG5ldyBVaW50OEFycmF5KGRhdGEpKTtcbiAgICAgIH0gZWxzZSBpZiAodXRpbHMkMS5pc1N0cmluZyhkYXRhKSkge1xuICAgICAgICBkYXRhID0gQnVmZmVyLmZyb20oZGF0YSwgJ3V0Zi04Jyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBBeGlvc0Vycm9yJDEoXG4gICAgICAgICAgJ0RhdGEgYWZ0ZXIgdHJhbnNmb3JtYXRpb24gbXVzdCBiZSBhIHN0cmluZywgYW4gQXJyYXlCdWZmZXIsIGEgQnVmZmVyLCBvciBhIFN0cmVhbScsXG4gICAgICAgICAgQXhpb3NFcnJvciQxLkVSUl9CQURfUkVRVUVTVCxcbiAgICAgICAgICBjb25maWdcbiAgICAgICAgKSk7XG4gICAgICB9XG5cbiAgICAgIC8vIEFkZCBDb250ZW50LUxlbmd0aCBoZWFkZXIgaWYgZGF0YSBleGlzdHNcbiAgICAgIGhlYWRlcnMuc2V0Q29udGVudExlbmd0aChkYXRhLmxlbmd0aCwgZmFsc2UpO1xuXG4gICAgICBpZiAoY29uZmlnLm1heEJvZHlMZW5ndGggPiAtMSAmJiBkYXRhLmxlbmd0aCA+IGNvbmZpZy5tYXhCb2R5TGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiByZWplY3QobmV3IEF4aW9zRXJyb3IkMShcbiAgICAgICAgICAnUmVxdWVzdCBib2R5IGxhcmdlciB0aGFuIG1heEJvZHlMZW5ndGggbGltaXQnLFxuICAgICAgICAgIEF4aW9zRXJyb3IkMS5FUlJfQkFEX1JFUVVFU1QsXG4gICAgICAgICAgY29uZmlnXG4gICAgICAgICkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGNvbnRlbnRMZW5ndGggPSB1dGlscyQxLnRvRmluaXRlTnVtYmVyKGhlYWRlcnMuZ2V0Q29udGVudExlbmd0aCgpKTtcblxuICAgIGlmICh1dGlscyQxLmlzQXJyYXkobWF4UmF0ZSkpIHtcbiAgICAgIG1heFVwbG9hZFJhdGUgPSBtYXhSYXRlWzBdO1xuICAgICAgbWF4RG93bmxvYWRSYXRlID0gbWF4UmF0ZVsxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWF4VXBsb2FkUmF0ZSA9IG1heERvd25sb2FkUmF0ZSA9IG1heFJhdGU7XG4gICAgfVxuXG4gICAgaWYgKGRhdGEgJiYgKG9uVXBsb2FkUHJvZ3Jlc3MgfHwgbWF4VXBsb2FkUmF0ZSkpIHtcbiAgICAgIGlmICghdXRpbHMkMS5pc1N0cmVhbShkYXRhKSkge1xuICAgICAgICBkYXRhID0gc3RyZWFtX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5SZWFkYWJsZS5mcm9tKGRhdGEsIHtvYmplY3RNb2RlOiBmYWxzZX0pO1xuICAgICAgfVxuXG4gICAgICBkYXRhID0gc3RyZWFtX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5waXBlbGluZShbZGF0YSwgbmV3IEF4aW9zVHJhbnNmb3JtU3RyZWFtJDEoe1xuICAgICAgICBtYXhSYXRlOiB1dGlscyQxLnRvRmluaXRlTnVtYmVyKG1heFVwbG9hZFJhdGUpXG4gICAgICB9KV0sIHV0aWxzJDEubm9vcCk7XG5cbiAgICAgIG9uVXBsb2FkUHJvZ3Jlc3MgJiYgZGF0YS5vbigncHJvZ3Jlc3MnLCBmbHVzaE9uRmluaXNoKFxuICAgICAgICBkYXRhLFxuICAgICAgICBwcm9ncmVzc0V2ZW50RGVjb3JhdG9yKFxuICAgICAgICAgIGNvbnRlbnRMZW5ndGgsXG4gICAgICAgICAgcHJvZ3Jlc3NFdmVudFJlZHVjZXIoYXN5bmNEZWNvcmF0b3Iob25VcGxvYWRQcm9ncmVzcyksIGZhbHNlLCAzKVxuICAgICAgICApXG4gICAgICApKTtcbiAgICB9XG5cbiAgICAvLyBIVFRQIGJhc2ljIGF1dGhlbnRpY2F0aW9uXG4gICAgbGV0IGF1dGggPSB1bmRlZmluZWQ7XG4gICAgaWYgKGNvbmZpZy5hdXRoKSB7XG4gICAgICBjb25zdCB1c2VybmFtZSA9IGNvbmZpZy5hdXRoLnVzZXJuYW1lIHx8ICcnO1xuICAgICAgY29uc3QgcGFzc3dvcmQgPSBjb25maWcuYXV0aC5wYXNzd29yZCB8fCAnJztcbiAgICAgIGF1dGggPSB1c2VybmFtZSArICc6JyArIHBhc3N3b3JkO1xuICAgIH1cblxuICAgIGlmICghYXV0aCAmJiBwYXJzZWQudXNlcm5hbWUpIHtcbiAgICAgIGNvbnN0IHVybFVzZXJuYW1lID0gcGFyc2VkLnVzZXJuYW1lO1xuICAgICAgY29uc3QgdXJsUGFzc3dvcmQgPSBwYXJzZWQucGFzc3dvcmQ7XG4gICAgICBhdXRoID0gdXJsVXNlcm5hbWUgKyAnOicgKyB1cmxQYXNzd29yZDtcbiAgICB9XG5cbiAgICBhdXRoICYmIGhlYWRlcnMuZGVsZXRlKCdhdXRob3JpemF0aW9uJyk7XG5cbiAgICBsZXQgcGF0aDtcblxuICAgIHRyeSB7XG4gICAgICBwYXRoID0gYnVpbGRVUkwoXG4gICAgICAgIHBhcnNlZC5wYXRobmFtZSArIHBhcnNlZC5zZWFyY2gsXG4gICAgICAgIGNvbmZpZy5wYXJhbXMsXG4gICAgICAgIGNvbmZpZy5wYXJhbXNTZXJpYWxpemVyXG4gICAgICApLnJlcGxhY2UoL15cXD8vLCAnJyk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zdCBjdXN0b21FcnIgPSBuZXcgRXJyb3IoZXJyLm1lc3NhZ2UpO1xuICAgICAgY3VzdG9tRXJyLmNvbmZpZyA9IGNvbmZpZztcbiAgICAgIGN1c3RvbUVyci51cmwgPSBjb25maWcudXJsO1xuICAgICAgY3VzdG9tRXJyLmV4aXN0cyA9IHRydWU7XG4gICAgICByZXR1cm4gcmVqZWN0KGN1c3RvbUVycik7XG4gICAgfVxuXG4gICAgaGVhZGVycy5zZXQoXG4gICAgICAnQWNjZXB0LUVuY29kaW5nJyxcbiAgICAgICdnemlwLCBjb21wcmVzcywgZGVmbGF0ZScgKyAoaXNCcm90bGlTdXBwb3J0ZWQgPyAnLCBicicgOiAnJyksIGZhbHNlXG4gICAgICApO1xuXG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgIHBhdGgsXG4gICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgIGhlYWRlcnM6IGhlYWRlcnMudG9KU09OKCksXG4gICAgICBhZ2VudHM6IHsgaHR0cDogY29uZmlnLmh0dHBBZ2VudCwgaHR0cHM6IGNvbmZpZy5odHRwc0FnZW50IH0sXG4gICAgICBhdXRoLFxuICAgICAgcHJvdG9jb2wsXG4gICAgICBmYW1pbHksXG4gICAgICBiZWZvcmVSZWRpcmVjdDogZGlzcGF0Y2hCZWZvcmVSZWRpcmVjdCxcbiAgICAgIGJlZm9yZVJlZGlyZWN0czoge30sXG4gICAgICBodHRwMk9wdGlvbnNcbiAgICB9O1xuXG4gICAgLy8gY2FjaGVhYmxlLWxvb2t1cCBpbnRlZ3JhdGlvbiBob3RmaXhcbiAgICAhdXRpbHMkMS5pc1VuZGVmaW5lZChsb29rdXApICYmIChvcHRpb25zLmxvb2t1cCA9IGxvb2t1cCk7XG5cbiAgICBpZiAoY29uZmlnLnNvY2tldFBhdGgpIHtcbiAgICAgIG9wdGlvbnMuc29ja2V0UGF0aCA9IGNvbmZpZy5zb2NrZXRQYXRoO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcHRpb25zLmhvc3RuYW1lID0gcGFyc2VkLmhvc3RuYW1lLnN0YXJ0c1dpdGgoXCJbXCIpID8gcGFyc2VkLmhvc3RuYW1lLnNsaWNlKDEsIC0xKSA6IHBhcnNlZC5ob3N0bmFtZTtcbiAgICAgIG9wdGlvbnMucG9ydCA9IHBhcnNlZC5wb3J0O1xuICAgICAgc2V0UHJveHkob3B0aW9ucywgY29uZmlnLnByb3h5LCBwcm90b2NvbCArICcvLycgKyBwYXJzZWQuaG9zdG5hbWUgKyAocGFyc2VkLnBvcnQgPyAnOicgKyBwYXJzZWQucG9ydCA6ICcnKSArIG9wdGlvbnMucGF0aCk7XG4gICAgfVxuXG4gICAgbGV0IHRyYW5zcG9ydDtcbiAgICBjb25zdCBpc0h0dHBzUmVxdWVzdCA9IGlzSHR0cHMudGVzdChvcHRpb25zLnByb3RvY29sKTtcbiAgICBvcHRpb25zLmFnZW50ID0gaXNIdHRwc1JlcXVlc3QgPyBjb25maWcuaHR0cHNBZ2VudCA6IGNvbmZpZy5odHRwQWdlbnQ7XG5cbiAgICBpZiAoaXNIdHRwMikge1xuICAgICAgIHRyYW5zcG9ydCA9IGh0dHAyVHJhbnNwb3J0O1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoY29uZmlnLnRyYW5zcG9ydCkge1xuICAgICAgICB0cmFuc3BvcnQgPSBjb25maWcudHJhbnNwb3J0O1xuICAgICAgfSBlbHNlIGlmIChjb25maWcubWF4UmVkaXJlY3RzID09PSAwKSB7XG4gICAgICAgIHRyYW5zcG9ydCA9IGlzSHR0cHNSZXF1ZXN0ID8gaHR0cHNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdIDogaHR0cF9fZGVmYXVsdFtcImRlZmF1bHRcIl07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoY29uZmlnLm1heFJlZGlyZWN0cykge1xuICAgICAgICAgIG9wdGlvbnMubWF4UmVkaXJlY3RzID0gY29uZmlnLm1heFJlZGlyZWN0cztcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uZmlnLmJlZm9yZVJlZGlyZWN0KSB7XG4gICAgICAgICAgb3B0aW9ucy5iZWZvcmVSZWRpcmVjdHMuY29uZmlnID0gY29uZmlnLmJlZm9yZVJlZGlyZWN0O1xuICAgICAgICB9XG4gICAgICAgIHRyYW5zcG9ydCA9IGlzSHR0cHNSZXF1ZXN0ID8gaHR0cHNGb2xsb3cgOiBodHRwRm9sbG93O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb25maWcubWF4Qm9keUxlbmd0aCA+IC0xKSB7XG4gICAgICBvcHRpb25zLm1heEJvZHlMZW5ndGggPSBjb25maWcubWF4Qm9keUxlbmd0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZm9sbG93LXJlZGlyZWN0cyBkb2VzIG5vdCBza2lwIGNvbXBhcmlzb24sIHNvIGl0IHNob3VsZCBhbHdheXMgc3VjY2VlZCBmb3IgYXhpb3MgLTEgdW5saW1pdGVkXG4gICAgICBvcHRpb25zLm1heEJvZHlMZW5ndGggPSBJbmZpbml0eTtcbiAgICB9XG5cbiAgICBpZiAoY29uZmlnLmluc2VjdXJlSFRUUFBhcnNlcikge1xuICAgICAgb3B0aW9ucy5pbnNlY3VyZUhUVFBQYXJzZXIgPSBjb25maWcuaW5zZWN1cmVIVFRQUGFyc2VyO1xuICAgIH1cblxuICAgIC8vIENyZWF0ZSB0aGUgcmVxdWVzdFxuICAgIHJlcSA9IHRyYW5zcG9ydC5yZXF1ZXN0KG9wdGlvbnMsIGZ1bmN0aW9uIGhhbmRsZVJlc3BvbnNlKHJlcykge1xuICAgICAgaWYgKHJlcS5kZXN0cm95ZWQpIHJldHVybjtcblxuICAgICAgY29uc3Qgc3RyZWFtcyA9IFtyZXNdO1xuXG4gICAgICBjb25zdCByZXNwb25zZUxlbmd0aCA9IHV0aWxzJDEudG9GaW5pdGVOdW1iZXIocmVzLmhlYWRlcnNbJ2NvbnRlbnQtbGVuZ3RoJ10pO1xuXG4gICAgICBpZiAob25Eb3dubG9hZFByb2dyZXNzIHx8IG1heERvd25sb2FkUmF0ZSkge1xuICAgICAgICBjb25zdCB0cmFuc2Zvcm1TdHJlYW0gPSBuZXcgQXhpb3NUcmFuc2Zvcm1TdHJlYW0kMSh7XG4gICAgICAgICAgbWF4UmF0ZTogdXRpbHMkMS50b0Zpbml0ZU51bWJlcihtYXhEb3dubG9hZFJhdGUpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIG9uRG93bmxvYWRQcm9ncmVzcyAmJiB0cmFuc2Zvcm1TdHJlYW0ub24oJ3Byb2dyZXNzJywgZmx1c2hPbkZpbmlzaChcbiAgICAgICAgICB0cmFuc2Zvcm1TdHJlYW0sXG4gICAgICAgICAgcHJvZ3Jlc3NFdmVudERlY29yYXRvcihcbiAgICAgICAgICAgIHJlc3BvbnNlTGVuZ3RoLFxuICAgICAgICAgICAgcHJvZ3Jlc3NFdmVudFJlZHVjZXIoYXN5bmNEZWNvcmF0b3Iob25Eb3dubG9hZFByb2dyZXNzKSwgdHJ1ZSwgMylcbiAgICAgICAgICApXG4gICAgICAgICkpO1xuXG4gICAgICAgIHN0cmVhbXMucHVzaCh0cmFuc2Zvcm1TdHJlYW0pO1xuICAgICAgfVxuXG4gICAgICAvLyBkZWNvbXByZXNzIHRoZSByZXNwb25zZSBib2R5IHRyYW5zcGFyZW50bHkgaWYgcmVxdWlyZWRcbiAgICAgIGxldCByZXNwb25zZVN0cmVhbSA9IHJlcztcblxuICAgICAgLy8gcmV0dXJuIHRoZSBsYXN0IHJlcXVlc3QgaW4gY2FzZSBvZiByZWRpcmVjdHNcbiAgICAgIGNvbnN0IGxhc3RSZXF1ZXN0ID0gcmVzLnJlcSB8fCByZXE7XG5cbiAgICAgIC8vIGlmIGRlY29tcHJlc3MgZGlzYWJsZWQgd2Ugc2hvdWxkIG5vdCBkZWNvbXByZXNzXG4gICAgICBpZiAoY29uZmlnLmRlY29tcHJlc3MgIT09IGZhbHNlICYmIHJlcy5oZWFkZXJzWydjb250ZW50LWVuY29kaW5nJ10pIHtcbiAgICAgICAgLy8gaWYgbm8gY29udGVudCwgYnV0IGhlYWRlcnMgc3RpbGwgc2F5IHRoYXQgaXQgaXMgZW5jb2RlZCxcbiAgICAgICAgLy8gcmVtb3ZlIHRoZSBoZWFkZXIgbm90IGNvbmZ1c2UgZG93bnN0cmVhbSBvcGVyYXRpb25zXG4gICAgICAgIGlmIChtZXRob2QgPT09ICdIRUFEJyB8fCByZXMuc3RhdHVzQ29kZSA9PT0gMjA0KSB7XG4gICAgICAgICAgZGVsZXRlIHJlcy5oZWFkZXJzWydjb250ZW50LWVuY29kaW5nJ107XG4gICAgICAgIH1cblxuICAgICAgICBzd2l0Y2ggKChyZXMuaGVhZGVyc1snY29udGVudC1lbmNvZGluZyddIHx8ICcnKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgIC8qZXNsaW50IGRlZmF1bHQtY2FzZTowKi9cbiAgICAgICAgY2FzZSAnZ3ppcCc6XG4gICAgICAgIGNhc2UgJ3gtZ3ppcCc6XG4gICAgICAgIGNhc2UgJ2NvbXByZXNzJzpcbiAgICAgICAgY2FzZSAneC1jb21wcmVzcyc6XG4gICAgICAgICAgLy8gYWRkIHRoZSB1bnppcHBlciB0byB0aGUgYm9keSBzdHJlYW0gcHJvY2Vzc2luZyBwaXBlbGluZVxuICAgICAgICAgIHN0cmVhbXMucHVzaCh6bGliX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5jcmVhdGVVbnppcCh6bGliT3B0aW9ucykpO1xuXG4gICAgICAgICAgLy8gcmVtb3ZlIHRoZSBjb250ZW50LWVuY29kaW5nIGluIG9yZGVyIHRvIG5vdCBjb25mdXNlIGRvd25zdHJlYW0gb3BlcmF0aW9uc1xuICAgICAgICAgIGRlbGV0ZSByZXMuaGVhZGVyc1snY29udGVudC1lbmNvZGluZyddO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdkZWZsYXRlJzpcbiAgICAgICAgICBzdHJlYW1zLnB1c2gobmV3IFpsaWJIZWFkZXJUcmFuc2Zvcm1TdHJlYW0kMSgpKTtcblxuICAgICAgICAgIC8vIGFkZCB0aGUgdW56aXBwZXIgdG8gdGhlIGJvZHkgc3RyZWFtIHByb2Nlc3NpbmcgcGlwZWxpbmVcbiAgICAgICAgICBzdHJlYW1zLnB1c2goemxpYl9fZGVmYXVsdFtcImRlZmF1bHRcIl0uY3JlYXRlVW56aXAoemxpYk9wdGlvbnMpKTtcblxuICAgICAgICAgIC8vIHJlbW92ZSB0aGUgY29udGVudC1lbmNvZGluZyBpbiBvcmRlciB0byBub3QgY29uZnVzZSBkb3duc3RyZWFtIG9wZXJhdGlvbnNcbiAgICAgICAgICBkZWxldGUgcmVzLmhlYWRlcnNbJ2NvbnRlbnQtZW5jb2RpbmcnXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnYnInOlxuICAgICAgICAgIGlmIChpc0Jyb3RsaVN1cHBvcnRlZCkge1xuICAgICAgICAgICAgc3RyZWFtcy5wdXNoKHpsaWJfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmNyZWF0ZUJyb3RsaURlY29tcHJlc3MoYnJvdGxpT3B0aW9ucykpO1xuICAgICAgICAgICAgZGVsZXRlIHJlcy5oZWFkZXJzWydjb250ZW50LWVuY29kaW5nJ107XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJlc3BvbnNlU3RyZWFtID0gc3RyZWFtcy5sZW5ndGggPiAxID8gc3RyZWFtX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5waXBlbGluZShzdHJlYW1zLCB1dGlscyQxLm5vb3ApIDogc3RyZWFtc1swXTtcblxuXG5cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0ge1xuICAgICAgICBzdGF0dXM6IHJlcy5zdGF0dXNDb2RlLFxuICAgICAgICBzdGF0dXNUZXh0OiByZXMuc3RhdHVzTWVzc2FnZSxcbiAgICAgICAgaGVhZGVyczogbmV3IEF4aW9zSGVhZGVycyQxKHJlcy5oZWFkZXJzKSxcbiAgICAgICAgY29uZmlnLFxuICAgICAgICByZXF1ZXN0OiBsYXN0UmVxdWVzdFxuICAgICAgfTtcblxuICAgICAgaWYgKHJlc3BvbnNlVHlwZSA9PT0gJ3N0cmVhbScpIHtcbiAgICAgICAgcmVzcG9uc2UuZGF0YSA9IHJlc3BvbnNlU3RyZWFtO1xuICAgICAgICBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCByZXNwb25zZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCByZXNwb25zZUJ1ZmZlciA9IFtdO1xuICAgICAgICBsZXQgdG90YWxSZXNwb25zZUJ5dGVzID0gMDtcblxuICAgICAgICByZXNwb25zZVN0cmVhbS5vbignZGF0YScsIGZ1bmN0aW9uIGhhbmRsZVN0cmVhbURhdGEoY2h1bmspIHtcbiAgICAgICAgICByZXNwb25zZUJ1ZmZlci5wdXNoKGNodW5rKTtcbiAgICAgICAgICB0b3RhbFJlc3BvbnNlQnl0ZXMgKz0gY2h1bmsubGVuZ3RoO1xuXG4gICAgICAgICAgLy8gbWFrZSBzdXJlIHRoZSBjb250ZW50IGxlbmd0aCBpcyBub3Qgb3ZlciB0aGUgbWF4Q29udGVudExlbmd0aCBpZiBzcGVjaWZpZWRcbiAgICAgICAgICBpZiAoY29uZmlnLm1heENvbnRlbnRMZW5ndGggPiAtMSAmJiB0b3RhbFJlc3BvbnNlQnl0ZXMgPiBjb25maWcubWF4Q29udGVudExlbmd0aCkge1xuICAgICAgICAgICAgLy8gc3RyZWFtLmRlc3Ryb3koKSBlbWl0IGFib3J0ZWQgZXZlbnQgYmVmb3JlIGNhbGxpbmcgcmVqZWN0KCkgb24gTm9kZS5qcyB2MTZcbiAgICAgICAgICAgIHJlamVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHJlc3BvbnNlU3RyZWFtLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIGFib3J0KG5ldyBBeGlvc0Vycm9yJDEoJ21heENvbnRlbnRMZW5ndGggc2l6ZSBvZiAnICsgY29uZmlnLm1heENvbnRlbnRMZW5ndGggKyAnIGV4Y2VlZGVkJyxcbiAgICAgICAgICAgICAgQXhpb3NFcnJvciQxLkVSUl9CQURfUkVTUE9OU0UsIGNvbmZpZywgbGFzdFJlcXVlc3QpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJlc3BvbnNlU3RyZWFtLm9uKCdhYm9ydGVkJywgZnVuY3Rpb24gaGFuZGxlclN0cmVhbUFib3J0ZWQoKSB7XG4gICAgICAgICAgaWYgKHJlamVjdGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgZXJyID0gbmV3IEF4aW9zRXJyb3IkMShcbiAgICAgICAgICAgICdzdHJlYW0gaGFzIGJlZW4gYWJvcnRlZCcsXG4gICAgICAgICAgICBBeGlvc0Vycm9yJDEuRVJSX0JBRF9SRVNQT05TRSxcbiAgICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgICAgIGxhc3RSZXF1ZXN0XG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXNwb25zZVN0cmVhbS5kZXN0cm95KGVycik7XG4gICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJlc3BvbnNlU3RyZWFtLm9uKCdlcnJvcicsIGZ1bmN0aW9uIGhhbmRsZVN0cmVhbUVycm9yKGVycikge1xuICAgICAgICAgIGlmIChyZXEuZGVzdHJveWVkKSByZXR1cm47XG4gICAgICAgICAgcmVqZWN0KEF4aW9zRXJyb3IkMS5mcm9tKGVyciwgbnVsbCwgY29uZmlnLCBsYXN0UmVxdWVzdCkpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXNwb25zZVN0cmVhbS5vbignZW5kJywgZnVuY3Rpb24gaGFuZGxlU3RyZWFtRW5kKCkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsZXQgcmVzcG9uc2VEYXRhID0gcmVzcG9uc2VCdWZmZXIubGVuZ3RoID09PSAxID8gcmVzcG9uc2VCdWZmZXJbMF0gOiBCdWZmZXIuY29uY2F0KHJlc3BvbnNlQnVmZmVyKTtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZVR5cGUgIT09ICdhcnJheWJ1ZmZlcicpIHtcbiAgICAgICAgICAgICAgcmVzcG9uc2VEYXRhID0gcmVzcG9uc2VEYXRhLnRvU3RyaW5nKHJlc3BvbnNlRW5jb2RpbmcpO1xuICAgICAgICAgICAgICBpZiAoIXJlc3BvbnNlRW5jb2RpbmcgfHwgcmVzcG9uc2VFbmNvZGluZyA9PT0gJ3V0ZjgnKSB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2VEYXRhID0gdXRpbHMkMS5zdHJpcEJPTShyZXNwb25zZURhdGEpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXNwb25zZS5kYXRhID0gcmVzcG9uc2VEYXRhO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIHJlamVjdChBeGlvc0Vycm9yJDEuZnJvbShlcnIsIG51bGwsIGNvbmZpZywgcmVzcG9uc2UucmVxdWVzdCwgcmVzcG9uc2UpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgcmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgYWJvcnRFbWl0dGVyLm9uY2UoJ2Fib3J0JywgZXJyID0+IHtcbiAgICAgICAgaWYgKCFyZXNwb25zZVN0cmVhbS5kZXN0cm95ZWQpIHtcbiAgICAgICAgICByZXNwb25zZVN0cmVhbS5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgICAgICAgcmVzcG9uc2VTdHJlYW0uZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGFib3J0RW1pdHRlci5vbmNlKCdhYm9ydCcsIGVyciA9PiB7XG4gICAgICBpZiAocmVxLmNsb3NlKSB7XG4gICAgICAgIHJlcS5jbG9zZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVxLmRlc3Ryb3koZXJyKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIEhhbmRsZSBlcnJvcnNcbiAgICByZXEub24oJ2Vycm9yJywgZnVuY3Rpb24gaGFuZGxlUmVxdWVzdEVycm9yKGVycikge1xuICAgICAgcmVqZWN0KEF4aW9zRXJyb3IkMS5mcm9tKGVyciwgbnVsbCwgY29uZmlnLCByZXEpKTtcbiAgICB9KTtcblxuICAgIC8vIHNldCB0Y3Aga2VlcCBhbGl2ZSB0byBwcmV2ZW50IGRyb3AgY29ubmVjdGlvbiBieSBwZWVyXG4gICAgcmVxLm9uKCdzb2NrZXQnLCBmdW5jdGlvbiBoYW5kbGVSZXF1ZXN0U29ja2V0KHNvY2tldCkge1xuICAgICAgLy8gZGVmYXVsdCBpbnRlcnZhbCBvZiBzZW5kaW5nIGFjayBwYWNrZXQgaXMgMSBtaW51dGVcbiAgICAgIHNvY2tldC5zZXRLZWVwQWxpdmUodHJ1ZSwgMTAwMCAqIDYwKTtcbiAgICB9KTtcblxuICAgIC8vIEhhbmRsZSByZXF1ZXN0IHRpbWVvdXRcbiAgICBpZiAoY29uZmlnLnRpbWVvdXQpIHtcbiAgICAgIC8vIFRoaXMgaXMgZm9yY2luZyBhIGludCB0aW1lb3V0IHRvIGF2b2lkIHByb2JsZW1zIGlmIHRoZSBgcmVxYCBpbnRlcmZhY2UgZG9lc24ndCBoYW5kbGUgb3RoZXIgdHlwZXMuXG4gICAgICBjb25zdCB0aW1lb3V0ID0gcGFyc2VJbnQoY29uZmlnLnRpbWVvdXQsIDEwKTtcblxuICAgICAgaWYgKE51bWJlci5pc05hTih0aW1lb3V0KSkge1xuICAgICAgICBhYm9ydChuZXcgQXhpb3NFcnJvciQxKFxuICAgICAgICAgICdlcnJvciB0cnlpbmcgdG8gcGFyc2UgYGNvbmZpZy50aW1lb3V0YCB0byBpbnQnLFxuICAgICAgICAgIEF4aW9zRXJyb3IkMS5FUlJfQkFEX09QVElPTl9WQUxVRSxcbiAgICAgICAgICBjb25maWcsXG4gICAgICAgICAgcmVxXG4gICAgICAgICkpO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gU29tZXRpbWUsIHRoZSByZXNwb25zZSB3aWxsIGJlIHZlcnkgc2xvdywgYW5kIGRvZXMgbm90IHJlc3BvbmQsIHRoZSBjb25uZWN0IGV2ZW50IHdpbGwgYmUgYmxvY2sgYnkgZXZlbnQgbG9vcCBzeXN0ZW0uXG4gICAgICAvLyBBbmQgdGltZXIgY2FsbGJhY2sgd2lsbCBiZSBmaXJlZCwgYW5kIGFib3J0KCkgd2lsbCBiZSBpbnZva2VkIGJlZm9yZSBjb25uZWN0aW9uLCB0aGVuIGdldCBcInNvY2tldCBoYW5nIHVwXCIgYW5kIGNvZGUgRUNPTk5SRVNFVC5cbiAgICAgIC8vIEF0IHRoaXMgdGltZSwgaWYgd2UgaGF2ZSBhIGxhcmdlIG51bWJlciBvZiByZXF1ZXN0LCBub2RlanMgd2lsbCBoYW5nIHVwIHNvbWUgc29ja2V0IG9uIGJhY2tncm91bmQuIGFuZCB0aGUgbnVtYmVyIHdpbGwgdXAgYW5kIHVwLlxuICAgICAgLy8gQW5kIHRoZW4gdGhlc2Ugc29ja2V0IHdoaWNoIGJlIGhhbmcgdXAgd2lsbCBkZXZvdXJpbmcgQ1BVIGxpdHRsZSBieSBsaXR0bGUuXG4gICAgICAvLyBDbGllbnRSZXF1ZXN0LnNldFRpbWVvdXQgd2lsbCBiZSBmaXJlZCBvbiB0aGUgc3BlY2lmeSBtaWxsaXNlY29uZHMsIGFuZCBjYW4gbWFrZSBzdXJlIHRoYXQgYWJvcnQoKSB3aWxsIGJlIGZpcmVkIGFmdGVyIGNvbm5lY3QuXG4gICAgICByZXEuc2V0VGltZW91dCh0aW1lb3V0LCBmdW5jdGlvbiBoYW5kbGVSZXF1ZXN0VGltZW91dCgpIHtcbiAgICAgICAgaWYgKGlzRG9uZSkgcmV0dXJuO1xuICAgICAgICBsZXQgdGltZW91dEVycm9yTWVzc2FnZSA9IGNvbmZpZy50aW1lb3V0ID8gJ3RpbWVvdXQgb2YgJyArIGNvbmZpZy50aW1lb3V0ICsgJ21zIGV4Y2VlZGVkJyA6ICd0aW1lb3V0IGV4Y2VlZGVkJztcbiAgICAgICAgY29uc3QgdHJhbnNpdGlvbmFsID0gY29uZmlnLnRyYW5zaXRpb25hbCB8fCB0cmFuc2l0aW9uYWxEZWZhdWx0cztcbiAgICAgICAgaWYgKGNvbmZpZy50aW1lb3V0RXJyb3JNZXNzYWdlKSB7XG4gICAgICAgICAgdGltZW91dEVycm9yTWVzc2FnZSA9IGNvbmZpZy50aW1lb3V0RXJyb3JNZXNzYWdlO1xuICAgICAgICB9XG4gICAgICAgIGFib3J0KG5ldyBBeGlvc0Vycm9yJDEoXG4gICAgICAgICAgdGltZW91dEVycm9yTWVzc2FnZSxcbiAgICAgICAgICB0cmFuc2l0aW9uYWwuY2xhcmlmeVRpbWVvdXRFcnJvciA/IEF4aW9zRXJyb3IkMS5FVElNRURPVVQgOiBBeGlvc0Vycm9yJDEuRUNPTk5BQk9SVEVELFxuICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgICByZXFcbiAgICAgICAgKSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZXhwbGljaXRseSByZXNldCB0aGUgc29ja2V0IHRpbWVvdXQgdmFsdWUgZm9yIGEgcG9zc2libGUgYGtlZXAtYWxpdmVgIHJlcXVlc3RcbiAgICAgIHJlcS5zZXRUaW1lb3V0KDApO1xuICAgIH1cblxuXG4gICAgLy8gU2VuZCB0aGUgcmVxdWVzdFxuICAgIGlmICh1dGlscyQxLmlzU3RyZWFtKGRhdGEpKSB7XG4gICAgICBsZXQgZW5kZWQgPSBmYWxzZTtcbiAgICAgIGxldCBlcnJvcmVkID0gZmFsc2U7XG5cbiAgICAgIGRhdGEub24oJ2VuZCcsICgpID0+IHtcbiAgICAgICAgZW5kZWQgPSB0cnVlO1xuICAgICAgfSk7XG5cbiAgICAgIGRhdGEub25jZSgnZXJyb3InLCBlcnIgPT4ge1xuICAgICAgICBlcnJvcmVkID0gdHJ1ZTtcbiAgICAgICAgcmVxLmRlc3Ryb3koZXJyKTtcbiAgICAgIH0pO1xuXG4gICAgICBkYXRhLm9uKCdjbG9zZScsICgpID0+IHtcbiAgICAgICAgaWYgKCFlbmRlZCAmJiAhZXJyb3JlZCkge1xuICAgICAgICAgIGFib3J0KG5ldyBDYW5jZWxlZEVycm9yJDEoJ1JlcXVlc3Qgc3RyZWFtIGhhcyBiZWVuIGFib3J0ZWQnLCBjb25maWcsIHJlcSkpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgZGF0YS5waXBlKHJlcSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRhdGEgJiYgcmVxLndyaXRlKGRhdGEpO1xuICAgICAgcmVxLmVuZCgpO1xuICAgIH1cbiAgfSk7XG59O1xuXG5jb25zdCBpc1VSTFNhbWVPcmlnaW4gPSBwbGF0Zm9ybS5oYXNTdGFuZGFyZEJyb3dzZXJFbnYgPyAoKG9yaWdpbiwgaXNNU0lFKSA9PiAodXJsKSA9PiB7XG4gIHVybCA9IG5ldyBVUkwodXJsLCBwbGF0Zm9ybS5vcmlnaW4pO1xuXG4gIHJldHVybiAoXG4gICAgb3JpZ2luLnByb3RvY29sID09PSB1cmwucHJvdG9jb2wgJiZcbiAgICBvcmlnaW4uaG9zdCA9PT0gdXJsLmhvc3QgJiZcbiAgICAoaXNNU0lFIHx8IG9yaWdpbi5wb3J0ID09PSB1cmwucG9ydClcbiAgKTtcbn0pKFxuICBuZXcgVVJMKHBsYXRmb3JtLm9yaWdpbiksXG4gIHBsYXRmb3JtLm5hdmlnYXRvciAmJiAvKG1zaWV8dHJpZGVudCkvaS50ZXN0KHBsYXRmb3JtLm5hdmlnYXRvci51c2VyQWdlbnQpXG4pIDogKCkgPT4gdHJ1ZTtcblxuY29uc3QgY29va2llcyA9IHBsYXRmb3JtLmhhc1N0YW5kYXJkQnJvd3NlckVudiA/XG5cbiAgLy8gU3RhbmRhcmQgYnJvd3NlciBlbnZzIHN1cHBvcnQgZG9jdW1lbnQuY29va2llXG4gIHtcbiAgICB3cml0ZShuYW1lLCB2YWx1ZSwgZXhwaXJlcywgcGF0aCwgZG9tYWluLCBzZWN1cmUsIHNhbWVTaXRlKSB7XG4gICAgICBpZiAodHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJykgcmV0dXJuO1xuXG4gICAgICBjb25zdCBjb29raWUgPSBbYCR7bmFtZX09JHtlbmNvZGVVUklDb21wb25lbnQodmFsdWUpfWBdO1xuXG4gICAgICBpZiAodXRpbHMkMS5pc051bWJlcihleHBpcmVzKSkge1xuICAgICAgICBjb29raWUucHVzaChgZXhwaXJlcz0ke25ldyBEYXRlKGV4cGlyZXMpLnRvVVRDU3RyaW5nKCl9YCk7XG4gICAgICB9XG4gICAgICBpZiAodXRpbHMkMS5pc1N0cmluZyhwYXRoKSkge1xuICAgICAgICBjb29raWUucHVzaChgcGF0aD0ke3BhdGh9YCk7XG4gICAgICB9XG4gICAgICBpZiAodXRpbHMkMS5pc1N0cmluZyhkb21haW4pKSB7XG4gICAgICAgIGNvb2tpZS5wdXNoKGBkb21haW49JHtkb21haW59YCk7XG4gICAgICB9XG4gICAgICBpZiAoc2VjdXJlID09PSB0cnVlKSB7XG4gICAgICAgIGNvb2tpZS5wdXNoKCdzZWN1cmUnKTtcbiAgICAgIH1cbiAgICAgIGlmICh1dGlscyQxLmlzU3RyaW5nKHNhbWVTaXRlKSkge1xuICAgICAgICBjb29raWUucHVzaChgU2FtZVNpdGU9JHtzYW1lU2l0ZX1gKTtcbiAgICAgIH1cblxuICAgICAgZG9jdW1lbnQuY29va2llID0gY29va2llLmpvaW4oJzsgJyk7XG4gICAgfSxcblxuICAgIHJlYWQobmFtZSkge1xuICAgICAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybiBudWxsO1xuICAgICAgY29uc3QgbWF0Y2ggPSBkb2N1bWVudC5jb29raWUubWF0Y2gobmV3IFJlZ0V4cCgnKD86Xnw7ICknICsgbmFtZSArICc9KFteO10qKScpKTtcbiAgICAgIHJldHVybiBtYXRjaCA/IGRlY29kZVVSSUNvbXBvbmVudChtYXRjaFsxXSkgOiBudWxsO1xuICAgIH0sXG5cbiAgICByZW1vdmUobmFtZSkge1xuICAgICAgdGhpcy53cml0ZShuYW1lLCAnJywgRGF0ZS5ub3coKSAtIDg2NDAwMDAwLCAnLycpO1xuICAgIH1cbiAgfVxuXG4gIDpcblxuICAvLyBOb24tc3RhbmRhcmQgYnJvd3NlciBlbnYgKHdlYiB3b3JrZXJzLCByZWFjdC1uYXRpdmUpIGxhY2sgbmVlZGVkIHN1cHBvcnQuXG4gIHtcbiAgICB3cml0ZSgpIHt9LFxuICAgIHJlYWQoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuICAgIHJlbW92ZSgpIHt9XG4gIH07XG5cbmNvbnN0IGhlYWRlcnNUb09iamVjdCA9ICh0aGluZykgPT4gdGhpbmcgaW5zdGFuY2VvZiBBeGlvc0hlYWRlcnMkMSA/IHsgLi4udGhpbmcgfSA6IHRoaW5nO1xuXG4vKipcbiAqIENvbmZpZy1zcGVjaWZpYyBtZXJnZS1mdW5jdGlvbiB3aGljaCBjcmVhdGVzIGEgbmV3IGNvbmZpZy1vYmplY3RcbiAqIGJ5IG1lcmdpbmcgdHdvIGNvbmZpZ3VyYXRpb24gb2JqZWN0cyB0b2dldGhlci5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnMVxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZzJcbiAqXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBOZXcgb2JqZWN0IHJlc3VsdGluZyBmcm9tIG1lcmdpbmcgY29uZmlnMiB0byBjb25maWcxXG4gKi9cbmZ1bmN0aW9uIG1lcmdlQ29uZmlnKGNvbmZpZzEsIGNvbmZpZzIpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gIGNvbmZpZzIgPSBjb25maWcyIHx8IHt9O1xuICBjb25zdCBjb25maWcgPSB7fTtcblxuICBmdW5jdGlvbiBnZXRNZXJnZWRWYWx1ZSh0YXJnZXQsIHNvdXJjZSwgcHJvcCwgY2FzZWxlc3MpIHtcbiAgICBpZiAodXRpbHMkMS5pc1BsYWluT2JqZWN0KHRhcmdldCkgJiYgdXRpbHMkMS5pc1BsYWluT2JqZWN0KHNvdXJjZSkpIHtcbiAgICAgIHJldHVybiB1dGlscyQxLm1lcmdlLmNhbGwoeyBjYXNlbGVzcyB9LCB0YXJnZXQsIHNvdXJjZSk7XG4gICAgfSBlbHNlIGlmICh1dGlscyQxLmlzUGxhaW5PYmplY3Qoc291cmNlKSkge1xuICAgICAgcmV0dXJuIHV0aWxzJDEubWVyZ2Uoe30sIHNvdXJjZSk7XG4gICAgfSBlbHNlIGlmICh1dGlscyQxLmlzQXJyYXkoc291cmNlKSkge1xuICAgICAgcmV0dXJuIHNvdXJjZS5zbGljZSgpO1xuICAgIH1cbiAgICByZXR1cm4gc291cmNlO1xuICB9XG5cbiAgZnVuY3Rpb24gbWVyZ2VEZWVwUHJvcGVydGllcyhhLCBiLCBwcm9wLCBjYXNlbGVzcykge1xuICAgIGlmICghdXRpbHMkMS5pc1VuZGVmaW5lZChiKSkge1xuICAgICAgcmV0dXJuIGdldE1lcmdlZFZhbHVlKGEsIGIsIHByb3AsIGNhc2VsZXNzKTtcbiAgICB9IGVsc2UgaWYgKCF1dGlscyQxLmlzVW5kZWZpbmVkKGEpKSB7XG4gICAgICByZXR1cm4gZ2V0TWVyZ2VkVmFsdWUodW5kZWZpbmVkLCBhLCBwcm9wLCBjYXNlbGVzcyk7XG4gICAgfVxuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbnNpc3RlbnQtcmV0dXJuXG4gIGZ1bmN0aW9uIHZhbHVlRnJvbUNvbmZpZzIoYSwgYikge1xuICAgIGlmICghdXRpbHMkMS5pc1VuZGVmaW5lZChiKSkge1xuICAgICAgcmV0dXJuIGdldE1lcmdlZFZhbHVlKHVuZGVmaW5lZCwgYik7XG4gICAgfVxuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbnNpc3RlbnQtcmV0dXJuXG4gIGZ1bmN0aW9uIGRlZmF1bHRUb0NvbmZpZzIoYSwgYikge1xuICAgIGlmICghdXRpbHMkMS5pc1VuZGVmaW5lZChiKSkge1xuICAgICAgcmV0dXJuIGdldE1lcmdlZFZhbHVlKHVuZGVmaW5lZCwgYik7XG4gICAgfSBlbHNlIGlmICghdXRpbHMkMS5pc1VuZGVmaW5lZChhKSkge1xuICAgICAgcmV0dXJuIGdldE1lcmdlZFZhbHVlKHVuZGVmaW5lZCwgYSk7XG4gICAgfVxuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbnNpc3RlbnQtcmV0dXJuXG4gIGZ1bmN0aW9uIG1lcmdlRGlyZWN0S2V5cyhhLCBiLCBwcm9wKSB7XG4gICAgaWYgKHByb3AgaW4gY29uZmlnMikge1xuICAgICAgcmV0dXJuIGdldE1lcmdlZFZhbHVlKGEsIGIpO1xuICAgIH0gZWxzZSBpZiAocHJvcCBpbiBjb25maWcxKSB7XG4gICAgICByZXR1cm4gZ2V0TWVyZ2VkVmFsdWUodW5kZWZpbmVkLCBhKTtcbiAgICB9XG4gIH1cblxuICBjb25zdCBtZXJnZU1hcCA9IHtcbiAgICB1cmw6IHZhbHVlRnJvbUNvbmZpZzIsXG4gICAgbWV0aG9kOiB2YWx1ZUZyb21Db25maWcyLFxuICAgIGRhdGE6IHZhbHVlRnJvbUNvbmZpZzIsXG4gICAgYmFzZVVSTDogZGVmYXVsdFRvQ29uZmlnMixcbiAgICB0cmFuc2Zvcm1SZXF1ZXN0OiBkZWZhdWx0VG9Db25maWcyLFxuICAgIHRyYW5zZm9ybVJlc3BvbnNlOiBkZWZhdWx0VG9Db25maWcyLFxuICAgIHBhcmFtc1NlcmlhbGl6ZXI6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgdGltZW91dDogZGVmYXVsdFRvQ29uZmlnMixcbiAgICB0aW1lb3V0TWVzc2FnZTogZGVmYXVsdFRvQ29uZmlnMixcbiAgICB3aXRoQ3JlZGVudGlhbHM6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgd2l0aFhTUkZUb2tlbjogZGVmYXVsdFRvQ29uZmlnMixcbiAgICBhZGFwdGVyOiBkZWZhdWx0VG9Db25maWcyLFxuICAgIHJlc3BvbnNlVHlwZTogZGVmYXVsdFRvQ29uZmlnMixcbiAgICB4c3JmQ29va2llTmFtZTogZGVmYXVsdFRvQ29uZmlnMixcbiAgICB4c3JmSGVhZGVyTmFtZTogZGVmYXVsdFRvQ29uZmlnMixcbiAgICBvblVwbG9hZFByb2dyZXNzOiBkZWZhdWx0VG9Db25maWcyLFxuICAgIG9uRG93bmxvYWRQcm9ncmVzczogZGVmYXVsdFRvQ29uZmlnMixcbiAgICBkZWNvbXByZXNzOiBkZWZhdWx0VG9Db25maWcyLFxuICAgIG1heENvbnRlbnRMZW5ndGg6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgbWF4Qm9keUxlbmd0aDogZGVmYXVsdFRvQ29uZmlnMixcbiAgICBiZWZvcmVSZWRpcmVjdDogZGVmYXVsdFRvQ29uZmlnMixcbiAgICB0cmFuc3BvcnQ6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgaHR0cEFnZW50OiBkZWZhdWx0VG9Db25maWcyLFxuICAgIGh0dHBzQWdlbnQ6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgY2FuY2VsVG9rZW46IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgc29ja2V0UGF0aDogZGVmYXVsdFRvQ29uZmlnMixcbiAgICByZXNwb25zZUVuY29kaW5nOiBkZWZhdWx0VG9Db25maWcyLFxuICAgIHZhbGlkYXRlU3RhdHVzOiBtZXJnZURpcmVjdEtleXMsXG4gICAgaGVhZGVyczogKGEsIGIsIHByb3ApID0+IG1lcmdlRGVlcFByb3BlcnRpZXMoaGVhZGVyc1RvT2JqZWN0KGEpLCBoZWFkZXJzVG9PYmplY3QoYiksIHByb3AsIHRydWUpXG4gIH07XG5cbiAgdXRpbHMkMS5mb3JFYWNoKE9iamVjdC5rZXlzKHsgLi4uY29uZmlnMSwgLi4uY29uZmlnMiB9KSwgZnVuY3Rpb24gY29tcHV0ZUNvbmZpZ1ZhbHVlKHByb3ApIHtcbiAgICBjb25zdCBtZXJnZSA9IG1lcmdlTWFwW3Byb3BdIHx8IG1lcmdlRGVlcFByb3BlcnRpZXM7XG4gICAgY29uc3QgY29uZmlnVmFsdWUgPSBtZXJnZShjb25maWcxW3Byb3BdLCBjb25maWcyW3Byb3BdLCBwcm9wKTtcbiAgICAodXRpbHMkMS5pc1VuZGVmaW5lZChjb25maWdWYWx1ZSkgJiYgbWVyZ2UgIT09IG1lcmdlRGlyZWN0S2V5cykgfHwgKGNvbmZpZ1twcm9wXSA9IGNvbmZpZ1ZhbHVlKTtcbiAgfSk7XG5cbiAgcmV0dXJuIGNvbmZpZztcbn1cblxuY29uc3QgcmVzb2x2ZUNvbmZpZyA9IChjb25maWcpID0+IHtcbiAgY29uc3QgbmV3Q29uZmlnID0gbWVyZ2VDb25maWcoe30sIGNvbmZpZyk7XG5cbiAgbGV0IHsgZGF0YSwgd2l0aFhTUkZUb2tlbiwgeHNyZkhlYWRlck5hbWUsIHhzcmZDb29raWVOYW1lLCBoZWFkZXJzLCBhdXRoIH0gPSBuZXdDb25maWc7XG5cbiAgbmV3Q29uZmlnLmhlYWRlcnMgPSBoZWFkZXJzID0gQXhpb3NIZWFkZXJzJDEuZnJvbShoZWFkZXJzKTtcblxuICBuZXdDb25maWcudXJsID0gYnVpbGRVUkwoYnVpbGRGdWxsUGF0aChuZXdDb25maWcuYmFzZVVSTCwgbmV3Q29uZmlnLnVybCwgbmV3Q29uZmlnLmFsbG93QWJzb2x1dGVVcmxzKSwgY29uZmlnLnBhcmFtcywgY29uZmlnLnBhcmFtc1NlcmlhbGl6ZXIpO1xuXG4gIC8vIEhUVFAgYmFzaWMgYXV0aGVudGljYXRpb25cbiAgaWYgKGF1dGgpIHtcbiAgICBoZWFkZXJzLnNldCgnQXV0aG9yaXphdGlvbicsICdCYXNpYyAnICtcbiAgICAgIGJ0b2EoKGF1dGgudXNlcm5hbWUgfHwgJycpICsgJzonICsgKGF1dGgucGFzc3dvcmQgPyB1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoYXV0aC5wYXNzd29yZCkpIDogJycpKVxuICAgICk7XG4gIH1cblxuICBpZiAodXRpbHMkMS5pc0Zvcm1EYXRhKGRhdGEpKSB7XG4gICAgaWYgKHBsYXRmb3JtLmhhc1N0YW5kYXJkQnJvd3NlckVudiB8fCBwbGF0Zm9ybS5oYXNTdGFuZGFyZEJyb3dzZXJXZWJXb3JrZXJFbnYpIHtcbiAgICAgIGhlYWRlcnMuc2V0Q29udGVudFR5cGUodW5kZWZpbmVkKTsgLy8gYnJvd3NlciBoYW5kbGVzIGl0XG4gICAgfSBlbHNlIGlmICh1dGlscyQxLmlzRnVuY3Rpb24oZGF0YS5nZXRIZWFkZXJzKSkge1xuICAgICAgLy8gTm9kZS5qcyBGb3JtRGF0YSAobGlrZSBmb3JtLWRhdGEgcGFja2FnZSlcbiAgICAgIGNvbnN0IGZvcm1IZWFkZXJzID0gZGF0YS5nZXRIZWFkZXJzKCk7XG4gICAgICAvLyBPbmx5IHNldCBzYWZlIGhlYWRlcnMgdG8gYXZvaWQgb3ZlcndyaXRpbmcgc2VjdXJpdHkgaGVhZGVyc1xuICAgICAgY29uc3QgYWxsb3dlZEhlYWRlcnMgPSBbJ2NvbnRlbnQtdHlwZScsICdjb250ZW50LWxlbmd0aCddO1xuICAgICAgT2JqZWN0LmVudHJpZXMoZm9ybUhlYWRlcnMpLmZvckVhY2goKFtrZXksIHZhbF0pID0+IHtcbiAgICAgICAgaWYgKGFsbG93ZWRIZWFkZXJzLmluY2x1ZGVzKGtleS50b0xvd2VyQ2FzZSgpKSkge1xuICAgICAgICAgIGhlYWRlcnMuc2V0KGtleSwgdmFsKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9ICBcblxuICAvLyBBZGQgeHNyZiBoZWFkZXJcbiAgLy8gVGhpcyBpcyBvbmx5IGRvbmUgaWYgcnVubmluZyBpbiBhIHN0YW5kYXJkIGJyb3dzZXIgZW52aXJvbm1lbnQuXG4gIC8vIFNwZWNpZmljYWxseSBub3QgaWYgd2UncmUgaW4gYSB3ZWIgd29ya2VyLCBvciByZWFjdC1uYXRpdmUuXG5cbiAgaWYgKHBsYXRmb3JtLmhhc1N0YW5kYXJkQnJvd3NlckVudikge1xuICAgIHdpdGhYU1JGVG9rZW4gJiYgdXRpbHMkMS5pc0Z1bmN0aW9uKHdpdGhYU1JGVG9rZW4pICYmICh3aXRoWFNSRlRva2VuID0gd2l0aFhTUkZUb2tlbihuZXdDb25maWcpKTtcblxuICAgIGlmICh3aXRoWFNSRlRva2VuIHx8ICh3aXRoWFNSRlRva2VuICE9PSBmYWxzZSAmJiBpc1VSTFNhbWVPcmlnaW4obmV3Q29uZmlnLnVybCkpKSB7XG4gICAgICAvLyBBZGQgeHNyZiBoZWFkZXJcbiAgICAgIGNvbnN0IHhzcmZWYWx1ZSA9IHhzcmZIZWFkZXJOYW1lICYmIHhzcmZDb29raWVOYW1lICYmIGNvb2tpZXMucmVhZCh4c3JmQ29va2llTmFtZSk7XG5cbiAgICAgIGlmICh4c3JmVmFsdWUpIHtcbiAgICAgICAgaGVhZGVycy5zZXQoeHNyZkhlYWRlck5hbWUsIHhzcmZWYWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ld0NvbmZpZztcbn07XG5cbmNvbnN0IGlzWEhSQWRhcHRlclN1cHBvcnRlZCA9IHR5cGVvZiBYTUxIdHRwUmVxdWVzdCAhPT0gJ3VuZGVmaW5lZCc7XG5cbmNvbnN0IHhockFkYXB0ZXIgPSBpc1hIUkFkYXB0ZXJTdXBwb3J0ZWQgJiYgZnVuY3Rpb24gKGNvbmZpZykge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gZGlzcGF0Y2hYaHJSZXF1ZXN0KHJlc29sdmUsIHJlamVjdCkge1xuICAgIGNvbnN0IF9jb25maWcgPSByZXNvbHZlQ29uZmlnKGNvbmZpZyk7XG4gICAgbGV0IHJlcXVlc3REYXRhID0gX2NvbmZpZy5kYXRhO1xuICAgIGNvbnN0IHJlcXVlc3RIZWFkZXJzID0gQXhpb3NIZWFkZXJzJDEuZnJvbShfY29uZmlnLmhlYWRlcnMpLm5vcm1hbGl6ZSgpO1xuICAgIGxldCB7cmVzcG9uc2VUeXBlLCBvblVwbG9hZFByb2dyZXNzLCBvbkRvd25sb2FkUHJvZ3Jlc3N9ID0gX2NvbmZpZztcbiAgICBsZXQgb25DYW5jZWxlZDtcbiAgICBsZXQgdXBsb2FkVGhyb3R0bGVkLCBkb3dubG9hZFRocm90dGxlZDtcbiAgICBsZXQgZmx1c2hVcGxvYWQsIGZsdXNoRG93bmxvYWQ7XG5cbiAgICBmdW5jdGlvbiBkb25lKCkge1xuICAgICAgZmx1c2hVcGxvYWQgJiYgZmx1c2hVcGxvYWQoKTsgLy8gZmx1c2ggZXZlbnRzXG4gICAgICBmbHVzaERvd25sb2FkICYmIGZsdXNoRG93bmxvYWQoKTsgLy8gZmx1c2ggZXZlbnRzXG5cbiAgICAgIF9jb25maWcuY2FuY2VsVG9rZW4gJiYgX2NvbmZpZy5jYW5jZWxUb2tlbi51bnN1YnNjcmliZShvbkNhbmNlbGVkKTtcblxuICAgICAgX2NvbmZpZy5zaWduYWwgJiYgX2NvbmZpZy5zaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBvbkNhbmNlbGVkKTtcbiAgICB9XG5cbiAgICBsZXQgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXG4gICAgcmVxdWVzdC5vcGVuKF9jb25maWcubWV0aG9kLnRvVXBwZXJDYXNlKCksIF9jb25maWcudXJsLCB0cnVlKTtcblxuICAgIC8vIFNldCB0aGUgcmVxdWVzdCB0aW1lb3V0IGluIE1TXG4gICAgcmVxdWVzdC50aW1lb3V0ID0gX2NvbmZpZy50aW1lb3V0O1xuXG4gICAgZnVuY3Rpb24gb25sb2FkZW5kKCkge1xuICAgICAgaWYgKCFyZXF1ZXN0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIFByZXBhcmUgdGhlIHJlc3BvbnNlXG4gICAgICBjb25zdCByZXNwb25zZUhlYWRlcnMgPSBBeGlvc0hlYWRlcnMkMS5mcm9tKFxuICAgICAgICAnZ2V0QWxsUmVzcG9uc2VIZWFkZXJzJyBpbiByZXF1ZXN0ICYmIHJlcXVlc3QuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKClcbiAgICAgICk7XG4gICAgICBjb25zdCByZXNwb25zZURhdGEgPSAhcmVzcG9uc2VUeXBlIHx8IHJlc3BvbnNlVHlwZSA9PT0gJ3RleHQnIHx8IHJlc3BvbnNlVHlwZSA9PT0gJ2pzb24nID9cbiAgICAgICAgcmVxdWVzdC5yZXNwb25zZVRleHQgOiByZXF1ZXN0LnJlc3BvbnNlO1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSB7XG4gICAgICAgIGRhdGE6IHJlc3BvbnNlRGF0YSxcbiAgICAgICAgc3RhdHVzOiByZXF1ZXN0LnN0YXR1cyxcbiAgICAgICAgc3RhdHVzVGV4dDogcmVxdWVzdC5zdGF0dXNUZXh0LFxuICAgICAgICBoZWFkZXJzOiByZXNwb25zZUhlYWRlcnMsXG4gICAgICAgIGNvbmZpZyxcbiAgICAgICAgcmVxdWVzdFxuICAgICAgfTtcblxuICAgICAgc2V0dGxlKGZ1bmN0aW9uIF9yZXNvbHZlKHZhbHVlKSB7XG4gICAgICAgIHJlc29sdmUodmFsdWUpO1xuICAgICAgICBkb25lKCk7XG4gICAgICB9LCBmdW5jdGlvbiBfcmVqZWN0KGVycikge1xuICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgZG9uZSgpO1xuICAgICAgfSwgcmVzcG9uc2UpO1xuXG4gICAgICAvLyBDbGVhbiB1cCByZXF1ZXN0XG4gICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoJ29ubG9hZGVuZCcgaW4gcmVxdWVzdCkge1xuICAgICAgLy8gVXNlIG9ubG9hZGVuZCBpZiBhdmFpbGFibGVcbiAgICAgIHJlcXVlc3Qub25sb2FkZW5kID0gb25sb2FkZW5kO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBMaXN0ZW4gZm9yIHJlYWR5IHN0YXRlIHRvIGVtdWxhdGUgb25sb2FkZW5kXG4gICAgICByZXF1ZXN0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uIGhhbmRsZUxvYWQoKSB7XG4gICAgICAgIGlmICghcmVxdWVzdCB8fCByZXF1ZXN0LnJlYWR5U3RhdGUgIT09IDQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGUgcmVxdWVzdCBlcnJvcmVkIG91dCBhbmQgd2UgZGlkbid0IGdldCBhIHJlc3BvbnNlLCB0aGlzIHdpbGwgYmVcbiAgICAgICAgLy8gaGFuZGxlZCBieSBvbmVycm9yIGluc3RlYWRcbiAgICAgICAgLy8gV2l0aCBvbmUgZXhjZXB0aW9uOiByZXF1ZXN0IHRoYXQgdXNpbmcgZmlsZTogcHJvdG9jb2wsIG1vc3QgYnJvd3NlcnNcbiAgICAgICAgLy8gd2lsbCByZXR1cm4gc3RhdHVzIGFzIDAgZXZlbiB0aG91Z2ggaXQncyBhIHN1Y2Nlc3NmdWwgcmVxdWVzdFxuICAgICAgICBpZiAocmVxdWVzdC5zdGF0dXMgPT09IDAgJiYgIShyZXF1ZXN0LnJlc3BvbnNlVVJMICYmIHJlcXVlc3QucmVzcG9uc2VVUkwuaW5kZXhPZignZmlsZTonKSA9PT0gMCkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVhZHlzdGF0ZSBoYW5kbGVyIGlzIGNhbGxpbmcgYmVmb3JlIG9uZXJyb3Igb3Igb250aW1lb3V0IGhhbmRsZXJzLFxuICAgICAgICAvLyBzbyB3ZSBzaG91bGQgY2FsbCBvbmxvYWRlbmQgb24gdGhlIG5leHQgJ3RpY2snXG4gICAgICAgIHNldFRpbWVvdXQob25sb2FkZW5kKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIGJyb3dzZXIgcmVxdWVzdCBjYW5jZWxsYXRpb24gKGFzIG9wcG9zZWQgdG8gYSBtYW51YWwgY2FuY2VsbGF0aW9uKVxuICAgIHJlcXVlc3Qub25hYm9ydCA9IGZ1bmN0aW9uIGhhbmRsZUFib3J0KCkge1xuICAgICAgaWYgKCFyZXF1ZXN0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcmVqZWN0KG5ldyBBeGlvc0Vycm9yJDEoJ1JlcXVlc3QgYWJvcnRlZCcsIEF4aW9zRXJyb3IkMS5FQ09OTkFCT1JURUQsIGNvbmZpZywgcmVxdWVzdCkpO1xuXG4gICAgICAvLyBDbGVhbiB1cCByZXF1ZXN0XG4gICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLy8gSGFuZGxlIGxvdyBsZXZlbCBuZXR3b3JrIGVycm9yc1xuICByZXF1ZXN0Lm9uZXJyb3IgPSBmdW5jdGlvbiBoYW5kbGVFcnJvcihldmVudCkge1xuICAgICAgIC8vIEJyb3dzZXJzIGRlbGl2ZXIgYSBQcm9ncmVzc0V2ZW50IGluIFhIUiBvbmVycm9yXG4gICAgICAgLy8gKG1lc3NhZ2UgbWF5IGJlIGVtcHR5OyB3aGVuIHByZXNlbnQsIHN1cmZhY2UgaXQpXG4gICAgICAgLy8gU2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9YTUxIdHRwUmVxdWVzdC9lcnJvcl9ldmVudFxuICAgICAgIGNvbnN0IG1zZyA9IGV2ZW50ICYmIGV2ZW50Lm1lc3NhZ2UgPyBldmVudC5tZXNzYWdlIDogJ05ldHdvcmsgRXJyb3InO1xuICAgICAgIGNvbnN0IGVyciA9IG5ldyBBeGlvc0Vycm9yJDEobXNnLCBBeGlvc0Vycm9yJDEuRVJSX05FVFdPUkssIGNvbmZpZywgcmVxdWVzdCk7XG4gICAgICAgLy8gYXR0YWNoIHRoZSB1bmRlcmx5aW5nIGV2ZW50IGZvciBjb25zdW1lcnMgd2hvIHdhbnQgZGV0YWlsc1xuICAgICAgIGVyci5ldmVudCA9IGV2ZW50IHx8IG51bGw7XG4gICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgfTtcbiAgICBcbiAgICAvLyBIYW5kbGUgdGltZW91dFxuICAgIHJlcXVlc3Qub250aW1lb3V0ID0gZnVuY3Rpb24gaGFuZGxlVGltZW91dCgpIHtcbiAgICAgIGxldCB0aW1lb3V0RXJyb3JNZXNzYWdlID0gX2NvbmZpZy50aW1lb3V0ID8gJ3RpbWVvdXQgb2YgJyArIF9jb25maWcudGltZW91dCArICdtcyBleGNlZWRlZCcgOiAndGltZW91dCBleGNlZWRlZCc7XG4gICAgICBjb25zdCB0cmFuc2l0aW9uYWwgPSBfY29uZmlnLnRyYW5zaXRpb25hbCB8fCB0cmFuc2l0aW9uYWxEZWZhdWx0cztcbiAgICAgIGlmIChfY29uZmlnLnRpbWVvdXRFcnJvck1lc3NhZ2UpIHtcbiAgICAgICAgdGltZW91dEVycm9yTWVzc2FnZSA9IF9jb25maWcudGltZW91dEVycm9yTWVzc2FnZTtcbiAgICAgIH1cbiAgICAgIHJlamVjdChuZXcgQXhpb3NFcnJvciQxKFxuICAgICAgICB0aW1lb3V0RXJyb3JNZXNzYWdlLFxuICAgICAgICB0cmFuc2l0aW9uYWwuY2xhcmlmeVRpbWVvdXRFcnJvciA/IEF4aW9zRXJyb3IkMS5FVElNRURPVVQgOiBBeGlvc0Vycm9yJDEuRUNPTk5BQk9SVEVELFxuICAgICAgICBjb25maWcsXG4gICAgICAgIHJlcXVlc3QpKTtcblxuICAgICAgLy8gQ2xlYW4gdXAgcmVxdWVzdFxuICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgfTtcblxuICAgIC8vIFJlbW92ZSBDb250ZW50LVR5cGUgaWYgZGF0YSBpcyB1bmRlZmluZWRcbiAgICByZXF1ZXN0RGF0YSA9PT0gdW5kZWZpbmVkICYmIHJlcXVlc3RIZWFkZXJzLnNldENvbnRlbnRUeXBlKG51bGwpO1xuXG4gICAgLy8gQWRkIGhlYWRlcnMgdG8gdGhlIHJlcXVlc3RcbiAgICBpZiAoJ3NldFJlcXVlc3RIZWFkZXInIGluIHJlcXVlc3QpIHtcbiAgICAgIHV0aWxzJDEuZm9yRWFjaChyZXF1ZXN0SGVhZGVycy50b0pTT04oKSwgZnVuY3Rpb24gc2V0UmVxdWVzdEhlYWRlcih2YWwsIGtleSkge1xuICAgICAgICByZXF1ZXN0LnNldFJlcXVlc3RIZWFkZXIoa2V5LCB2YWwpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gQWRkIHdpdGhDcmVkZW50aWFscyB0byByZXF1ZXN0IGlmIG5lZWRlZFxuICAgIGlmICghdXRpbHMkMS5pc1VuZGVmaW5lZChfY29uZmlnLndpdGhDcmVkZW50aWFscykpIHtcbiAgICAgIHJlcXVlc3Qud2l0aENyZWRlbnRpYWxzID0gISFfY29uZmlnLndpdGhDcmVkZW50aWFscztcbiAgICB9XG5cbiAgICAvLyBBZGQgcmVzcG9uc2VUeXBlIHRvIHJlcXVlc3QgaWYgbmVlZGVkXG4gICAgaWYgKHJlc3BvbnNlVHlwZSAmJiByZXNwb25zZVR5cGUgIT09ICdqc29uJykge1xuICAgICAgcmVxdWVzdC5yZXNwb25zZVR5cGUgPSBfY29uZmlnLnJlc3BvbnNlVHlwZTtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgcHJvZ3Jlc3MgaWYgbmVlZGVkXG4gICAgaWYgKG9uRG93bmxvYWRQcm9ncmVzcykge1xuICAgICAgKFtkb3dubG9hZFRocm90dGxlZCwgZmx1c2hEb3dubG9hZF0gPSBwcm9ncmVzc0V2ZW50UmVkdWNlcihvbkRvd25sb2FkUHJvZ3Jlc3MsIHRydWUpKTtcbiAgICAgIHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCBkb3dubG9hZFRocm90dGxlZCk7XG4gICAgfVxuXG4gICAgLy8gTm90IGFsbCBicm93c2VycyBzdXBwb3J0IHVwbG9hZCBldmVudHNcbiAgICBpZiAob25VcGxvYWRQcm9ncmVzcyAmJiByZXF1ZXN0LnVwbG9hZCkge1xuICAgICAgKFt1cGxvYWRUaHJvdHRsZWQsIGZsdXNoVXBsb2FkXSA9IHByb2dyZXNzRXZlbnRSZWR1Y2VyKG9uVXBsb2FkUHJvZ3Jlc3MpKTtcblxuICAgICAgcmVxdWVzdC51cGxvYWQuYWRkRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCB1cGxvYWRUaHJvdHRsZWQpO1xuXG4gICAgICByZXF1ZXN0LnVwbG9hZC5hZGRFdmVudExpc3RlbmVyKCdsb2FkZW5kJywgZmx1c2hVcGxvYWQpO1xuICAgIH1cblxuICAgIGlmIChfY29uZmlnLmNhbmNlbFRva2VuIHx8IF9jb25maWcuc2lnbmFsKSB7XG4gICAgICAvLyBIYW5kbGUgY2FuY2VsbGF0aW9uXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xuICAgICAgb25DYW5jZWxlZCA9IGNhbmNlbCA9PiB7XG4gICAgICAgIGlmICghcmVxdWVzdCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZWplY3QoIWNhbmNlbCB8fCBjYW5jZWwudHlwZSA/IG5ldyBDYW5jZWxlZEVycm9yJDEobnVsbCwgY29uZmlnLCByZXF1ZXN0KSA6IGNhbmNlbCk7XG4gICAgICAgIHJlcXVlc3QuYWJvcnQoKTtcbiAgICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgICB9O1xuXG4gICAgICBfY29uZmlnLmNhbmNlbFRva2VuICYmIF9jb25maWcuY2FuY2VsVG9rZW4uc3Vic2NyaWJlKG9uQ2FuY2VsZWQpO1xuICAgICAgaWYgKF9jb25maWcuc2lnbmFsKSB7XG4gICAgICAgIF9jb25maWcuc2lnbmFsLmFib3J0ZWQgPyBvbkNhbmNlbGVkKCkgOiBfY29uZmlnLnNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsIG9uQ2FuY2VsZWQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHByb3RvY29sID0gcGFyc2VQcm90b2NvbChfY29uZmlnLnVybCk7XG5cbiAgICBpZiAocHJvdG9jb2wgJiYgcGxhdGZvcm0ucHJvdG9jb2xzLmluZGV4T2YocHJvdG9jb2wpID09PSAtMSkge1xuICAgICAgcmVqZWN0KG5ldyBBeGlvc0Vycm9yJDEoJ1Vuc3VwcG9ydGVkIHByb3RvY29sICcgKyBwcm90b2NvbCArICc6JywgQXhpb3NFcnJvciQxLkVSUl9CQURfUkVRVUVTVCwgY29uZmlnKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG5cbiAgICAvLyBTZW5kIHRoZSByZXF1ZXN0XG4gICAgcmVxdWVzdC5zZW5kKHJlcXVlc3REYXRhIHx8IG51bGwpO1xuICB9KTtcbn07XG5cbmNvbnN0IGNvbXBvc2VTaWduYWxzID0gKHNpZ25hbHMsIHRpbWVvdXQpID0+IHtcbiAgY29uc3Qge2xlbmd0aH0gPSAoc2lnbmFscyA9IHNpZ25hbHMgPyBzaWduYWxzLmZpbHRlcihCb29sZWFuKSA6IFtdKTtcblxuICBpZiAodGltZW91dCB8fCBsZW5ndGgpIHtcbiAgICBsZXQgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcblxuICAgIGxldCBhYm9ydGVkO1xuXG4gICAgY29uc3Qgb25hYm9ydCA9IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgIGlmICghYWJvcnRlZCkge1xuICAgICAgICBhYm9ydGVkID0gdHJ1ZTtcbiAgICAgICAgdW5zdWJzY3JpYmUoKTtcbiAgICAgICAgY29uc3QgZXJyID0gcmVhc29uIGluc3RhbmNlb2YgRXJyb3IgPyByZWFzb24gOiB0aGlzLnJlYXNvbjtcbiAgICAgICAgY29udHJvbGxlci5hYm9ydChlcnIgaW5zdGFuY2VvZiBBeGlvc0Vycm9yJDEgPyBlcnIgOiBuZXcgQ2FuY2VsZWRFcnJvciQxKGVyciBpbnN0YW5jZW9mIEVycm9yID8gZXJyLm1lc3NhZ2UgOiBlcnIpKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgbGV0IHRpbWVyID0gdGltZW91dCAmJiBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRpbWVyID0gbnVsbDtcbiAgICAgIG9uYWJvcnQobmV3IEF4aW9zRXJyb3IkMShgdGltZW91dCBvZiAke3RpbWVvdXR9bXMgZXhjZWVkZWRgLCBBeGlvc0Vycm9yJDEuRVRJTUVET1VUKSk7XG4gICAgfSwgdGltZW91dCk7XG5cbiAgICBjb25zdCB1bnN1YnNjcmliZSA9ICgpID0+IHtcbiAgICAgIGlmIChzaWduYWxzKSB7XG4gICAgICAgIHRpbWVyICYmIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgIHRpbWVyID0gbnVsbDtcbiAgICAgICAgc2lnbmFscy5mb3JFYWNoKHNpZ25hbCA9PiB7XG4gICAgICAgICAgc2lnbmFsLnVuc3Vic2NyaWJlID8gc2lnbmFsLnVuc3Vic2NyaWJlKG9uYWJvcnQpIDogc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Fib3J0Jywgb25hYm9ydCk7XG4gICAgICAgIH0pO1xuICAgICAgICBzaWduYWxzID0gbnVsbDtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgc2lnbmFscy5mb3JFYWNoKChzaWduYWwpID0+IHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsIG9uYWJvcnQpKTtcblxuICAgIGNvbnN0IHtzaWduYWx9ID0gY29udHJvbGxlcjtcblxuICAgIHNpZ25hbC51bnN1YnNjcmliZSA9ICgpID0+IHV0aWxzJDEuYXNhcCh1bnN1YnNjcmliZSk7XG5cbiAgICByZXR1cm4gc2lnbmFsO1xuICB9XG59O1xuXG5jb25zdCBjb21wb3NlU2lnbmFscyQxID0gY29tcG9zZVNpZ25hbHM7XG5cbmNvbnN0IHN0cmVhbUNodW5rID0gZnVuY3Rpb24qIChjaHVuaywgY2h1bmtTaXplKSB7XG4gIGxldCBsZW4gPSBjaHVuay5ieXRlTGVuZ3RoO1xuXG4gIGlmICghY2h1bmtTaXplIHx8IGxlbiA8IGNodW5rU2l6ZSkge1xuICAgIHlpZWxkIGNodW5rO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGxldCBwb3MgPSAwO1xuICBsZXQgZW5kO1xuXG4gIHdoaWxlIChwb3MgPCBsZW4pIHtcbiAgICBlbmQgPSBwb3MgKyBjaHVua1NpemU7XG4gICAgeWllbGQgY2h1bmsuc2xpY2UocG9zLCBlbmQpO1xuICAgIHBvcyA9IGVuZDtcbiAgfVxufTtcblxuY29uc3QgcmVhZEJ5dGVzID0gYXN5bmMgZnVuY3Rpb24qIChpdGVyYWJsZSwgY2h1bmtTaXplKSB7XG4gIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgcmVhZFN0cmVhbShpdGVyYWJsZSkpIHtcbiAgICB5aWVsZCogc3RyZWFtQ2h1bmsoY2h1bmssIGNodW5rU2l6ZSk7XG4gIH1cbn07XG5cbmNvbnN0IHJlYWRTdHJlYW0gPSBhc3luYyBmdW5jdGlvbiogKHN0cmVhbSkge1xuICBpZiAoc3RyZWFtW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSkge1xuICAgIHlpZWxkKiBzdHJlYW07XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgcmVhZGVyID0gc3RyZWFtLmdldFJlYWRlcigpO1xuICB0cnkge1xuICAgIGZvciAoOzspIHtcbiAgICAgIGNvbnN0IHtkb25lLCB2YWx1ZX0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICB5aWVsZCB2YWx1ZTtcbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgYXdhaXQgcmVhZGVyLmNhbmNlbCgpO1xuICB9XG59O1xuXG5jb25zdCB0cmFja1N0cmVhbSA9IChzdHJlYW0sIGNodW5rU2l6ZSwgb25Qcm9ncmVzcywgb25GaW5pc2gpID0+IHtcbiAgY29uc3QgaXRlcmF0b3IgPSByZWFkQnl0ZXMoc3RyZWFtLCBjaHVua1NpemUpO1xuXG4gIGxldCBieXRlcyA9IDA7XG4gIGxldCBkb25lO1xuICBsZXQgX29uRmluaXNoID0gKGUpID0+IHtcbiAgICBpZiAoIWRvbmUpIHtcbiAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgb25GaW5pc2ggJiYgb25GaW5pc2goZSk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgIGFzeW5jIHB1bGwoY29udHJvbGxlcikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3Qge2RvbmUsIHZhbHVlfSA9IGF3YWl0IGl0ZXJhdG9yLm5leHQoKTtcblxuICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgX29uRmluaXNoKCk7XG4gICAgICAgICAgY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBsZW4gPSB2YWx1ZS5ieXRlTGVuZ3RoO1xuICAgICAgICBpZiAob25Qcm9ncmVzcykge1xuICAgICAgICAgIGxldCBsb2FkZWRCeXRlcyA9IGJ5dGVzICs9IGxlbjtcbiAgICAgICAgICBvblByb2dyZXNzKGxvYWRlZEJ5dGVzKTtcbiAgICAgICAgfVxuICAgICAgICBjb250cm9sbGVyLmVucXVldWUobmV3IFVpbnQ4QXJyYXkodmFsdWUpKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfb25GaW5pc2goZXJyKTtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgIH0sXG4gICAgY2FuY2VsKHJlYXNvbikge1xuICAgICAgX29uRmluaXNoKHJlYXNvbik7XG4gICAgICByZXR1cm4gaXRlcmF0b3IucmV0dXJuKCk7XG4gICAgfVxuICB9LCB7XG4gICAgaGlnaFdhdGVyTWFyazogMlxuICB9KVxufTtcblxuY29uc3QgREVGQVVMVF9DSFVOS19TSVpFID0gNjQgKiAxMDI0O1xuXG5jb25zdCB7aXNGdW5jdGlvbn0gPSB1dGlscyQxO1xuXG5jb25zdCBnbG9iYWxGZXRjaEFQSSA9ICgoe1JlcXVlc3QsIFJlc3BvbnNlfSkgPT4gKHtcbiAgUmVxdWVzdCwgUmVzcG9uc2Vcbn0pKSh1dGlscyQxLmdsb2JhbCk7XG5cbmNvbnN0IHtcbiAgUmVhZGFibGVTdHJlYW06IFJlYWRhYmxlU3RyZWFtJDEsIFRleHRFbmNvZGVyOiBUZXh0RW5jb2RlciQxXG59ID0gdXRpbHMkMS5nbG9iYWw7XG5cblxuY29uc3QgdGVzdCA9IChmbiwgLi4uYXJncykgPT4ge1xuICB0cnkge1xuICAgIHJldHVybiAhIWZuKC4uLmFyZ3MpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn07XG5cbmNvbnN0IGZhY3RvcnkgPSAoZW52KSA9PiB7XG4gIGVudiA9IHV0aWxzJDEubWVyZ2UuY2FsbCh7XG4gICAgc2tpcFVuZGVmaW5lZDogdHJ1ZVxuICB9LCBnbG9iYWxGZXRjaEFQSSwgZW52KTtcblxuICBjb25zdCB7ZmV0Y2g6IGVudkZldGNoLCBSZXF1ZXN0LCBSZXNwb25zZX0gPSBlbnY7XG4gIGNvbnN0IGlzRmV0Y2hTdXBwb3J0ZWQgPSBlbnZGZXRjaCA/IGlzRnVuY3Rpb24oZW52RmV0Y2gpIDogdHlwZW9mIGZldGNoID09PSAnZnVuY3Rpb24nO1xuICBjb25zdCBpc1JlcXVlc3RTdXBwb3J0ZWQgPSBpc0Z1bmN0aW9uKFJlcXVlc3QpO1xuICBjb25zdCBpc1Jlc3BvbnNlU3VwcG9ydGVkID0gaXNGdW5jdGlvbihSZXNwb25zZSk7XG5cbiAgaWYgKCFpc0ZldGNoU3VwcG9ydGVkKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY29uc3QgaXNSZWFkYWJsZVN0cmVhbVN1cHBvcnRlZCA9IGlzRmV0Y2hTdXBwb3J0ZWQgJiYgaXNGdW5jdGlvbihSZWFkYWJsZVN0cmVhbSQxKTtcblxuICBjb25zdCBlbmNvZGVUZXh0ID0gaXNGZXRjaFN1cHBvcnRlZCAmJiAodHlwZW9mIFRleHRFbmNvZGVyJDEgPT09ICdmdW5jdGlvbicgP1xuICAgICAgKChlbmNvZGVyKSA9PiAoc3RyKSA9PiBlbmNvZGVyLmVuY29kZShzdHIpKShuZXcgVGV4dEVuY29kZXIkMSgpKSA6XG4gICAgICBhc3luYyAoc3RyKSA9PiBuZXcgVWludDhBcnJheShhd2FpdCBuZXcgUmVxdWVzdChzdHIpLmFycmF5QnVmZmVyKCkpXG4gICk7XG5cbiAgY29uc3Qgc3VwcG9ydHNSZXF1ZXN0U3RyZWFtID0gaXNSZXF1ZXN0U3VwcG9ydGVkICYmIGlzUmVhZGFibGVTdHJlYW1TdXBwb3J0ZWQgJiYgdGVzdCgoKSA9PiB7XG4gICAgbGV0IGR1cGxleEFjY2Vzc2VkID0gZmFsc2U7XG5cbiAgICBjb25zdCBoYXNDb250ZW50VHlwZSA9IG5ldyBSZXF1ZXN0KHBsYXRmb3JtLm9yaWdpbiwge1xuICAgICAgYm9keTogbmV3IFJlYWRhYmxlU3RyZWFtJDEoKSxcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgZ2V0IGR1cGxleCgpIHtcbiAgICAgICAgZHVwbGV4QWNjZXNzZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gJ2hhbGYnO1xuICAgICAgfSxcbiAgICB9KS5oZWFkZXJzLmhhcygnQ29udGVudC1UeXBlJyk7XG5cbiAgICByZXR1cm4gZHVwbGV4QWNjZXNzZWQgJiYgIWhhc0NvbnRlbnRUeXBlO1xuICB9KTtcblxuICBjb25zdCBzdXBwb3J0c1Jlc3BvbnNlU3RyZWFtID0gaXNSZXNwb25zZVN1cHBvcnRlZCAmJiBpc1JlYWRhYmxlU3RyZWFtU3VwcG9ydGVkICYmXG4gICAgdGVzdCgoKSA9PiB1dGlscyQxLmlzUmVhZGFibGVTdHJlYW0obmV3IFJlc3BvbnNlKCcnKS5ib2R5KSk7XG5cbiAgY29uc3QgcmVzb2x2ZXJzID0ge1xuICAgIHN0cmVhbTogc3VwcG9ydHNSZXNwb25zZVN0cmVhbSAmJiAoKHJlcykgPT4gcmVzLmJvZHkpXG4gIH07XG5cbiAgaXNGZXRjaFN1cHBvcnRlZCAmJiAoKCgpID0+IHtcbiAgICBbJ3RleHQnLCAnYXJyYXlCdWZmZXInLCAnYmxvYicsICdmb3JtRGF0YScsICdzdHJlYW0nXS5mb3JFYWNoKHR5cGUgPT4ge1xuICAgICAgIXJlc29sdmVyc1t0eXBlXSAmJiAocmVzb2x2ZXJzW3R5cGVdID0gKHJlcywgY29uZmlnKSA9PiB7XG4gICAgICAgIGxldCBtZXRob2QgPSByZXMgJiYgcmVzW3R5cGVdO1xuXG4gICAgICAgIGlmIChtZXRob2QpIHtcbiAgICAgICAgICByZXR1cm4gbWV0aG9kLmNhbGwocmVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRocm93IG5ldyBBeGlvc0Vycm9yJDEoYFJlc3BvbnNlIHR5cGUgJyR7dHlwZX0nIGlzIG5vdCBzdXBwb3J0ZWRgLCBBeGlvc0Vycm9yJDEuRVJSX05PVF9TVVBQT1JULCBjb25maWcpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pKCkpO1xuXG4gIGNvbnN0IGdldEJvZHlMZW5ndGggPSBhc3luYyAoYm9keSkgPT4ge1xuICAgIGlmIChib2R5ID09IG51bGwpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIGlmICh1dGlscyQxLmlzQmxvYihib2R5KSkge1xuICAgICAgcmV0dXJuIGJvZHkuc2l6ZTtcbiAgICB9XG5cbiAgICBpZiAodXRpbHMkMS5pc1NwZWNDb21wbGlhbnRGb3JtKGJvZHkpKSB7XG4gICAgICBjb25zdCBfcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KHBsYXRmb3JtLm9yaWdpbiwge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgYm9keSxcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIChhd2FpdCBfcmVxdWVzdC5hcnJheUJ1ZmZlcigpKS5ieXRlTGVuZ3RoO1xuICAgIH1cblxuICAgIGlmICh1dGlscyQxLmlzQXJyYXlCdWZmZXJWaWV3KGJvZHkpIHx8IHV0aWxzJDEuaXNBcnJheUJ1ZmZlcihib2R5KSkge1xuICAgICAgcmV0dXJuIGJvZHkuYnl0ZUxlbmd0aDtcbiAgICB9XG5cbiAgICBpZiAodXRpbHMkMS5pc1VSTFNlYXJjaFBhcmFtcyhib2R5KSkge1xuICAgICAgYm9keSA9IGJvZHkgKyAnJztcbiAgICB9XG5cbiAgICBpZiAodXRpbHMkMS5pc1N0cmluZyhib2R5KSkge1xuICAgICAgcmV0dXJuIChhd2FpdCBlbmNvZGVUZXh0KGJvZHkpKS5ieXRlTGVuZ3RoO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCByZXNvbHZlQm9keUxlbmd0aCA9IGFzeW5jIChoZWFkZXJzLCBib2R5KSA9PiB7XG4gICAgY29uc3QgbGVuZ3RoID0gdXRpbHMkMS50b0Zpbml0ZU51bWJlcihoZWFkZXJzLmdldENvbnRlbnRMZW5ndGgoKSk7XG5cbiAgICByZXR1cm4gbGVuZ3RoID09IG51bGwgPyBnZXRCb2R5TGVuZ3RoKGJvZHkpIDogbGVuZ3RoO1xuICB9O1xuXG4gIHJldHVybiBhc3luYyAoY29uZmlnKSA9PiB7XG4gICAgbGV0IHtcbiAgICAgIHVybCxcbiAgICAgIG1ldGhvZCxcbiAgICAgIGRhdGEsXG4gICAgICBzaWduYWwsXG4gICAgICBjYW5jZWxUb2tlbixcbiAgICAgIHRpbWVvdXQsXG4gICAgICBvbkRvd25sb2FkUHJvZ3Jlc3MsXG4gICAgICBvblVwbG9hZFByb2dyZXNzLFxuICAgICAgcmVzcG9uc2VUeXBlLFxuICAgICAgaGVhZGVycyxcbiAgICAgIHdpdGhDcmVkZW50aWFscyA9ICdzYW1lLW9yaWdpbicsXG4gICAgICBmZXRjaE9wdGlvbnNcbiAgICB9ID0gcmVzb2x2ZUNvbmZpZyhjb25maWcpO1xuXG4gICAgbGV0IF9mZXRjaCA9IGVudkZldGNoIHx8IGZldGNoO1xuXG4gICAgcmVzcG9uc2VUeXBlID0gcmVzcG9uc2VUeXBlID8gKHJlc3BvbnNlVHlwZSArICcnKS50b0xvd2VyQ2FzZSgpIDogJ3RleHQnO1xuXG4gICAgbGV0IGNvbXBvc2VkU2lnbmFsID0gY29tcG9zZVNpZ25hbHMkMShbc2lnbmFsLCBjYW5jZWxUb2tlbiAmJiBjYW5jZWxUb2tlbi50b0Fib3J0U2lnbmFsKCldLCB0aW1lb3V0KTtcblxuICAgIGxldCByZXF1ZXN0ID0gbnVsbDtcblxuICAgIGNvbnN0IHVuc3Vic2NyaWJlID0gY29tcG9zZWRTaWduYWwgJiYgY29tcG9zZWRTaWduYWwudW5zdWJzY3JpYmUgJiYgKCgpID0+IHtcbiAgICAgIGNvbXBvc2VkU2lnbmFsLnVuc3Vic2NyaWJlKCk7XG4gICAgfSk7XG5cbiAgICBsZXQgcmVxdWVzdENvbnRlbnRMZW5ndGg7XG5cbiAgICB0cnkge1xuICAgICAgaWYgKFxuICAgICAgICBvblVwbG9hZFByb2dyZXNzICYmIHN1cHBvcnRzUmVxdWVzdFN0cmVhbSAmJiBtZXRob2QgIT09ICdnZXQnICYmIG1ldGhvZCAhPT0gJ2hlYWQnICYmXG4gICAgICAgIChyZXF1ZXN0Q29udGVudExlbmd0aCA9IGF3YWl0IHJlc29sdmVCb2R5TGVuZ3RoKGhlYWRlcnMsIGRhdGEpKSAhPT0gMFxuICAgICAgKSB7XG4gICAgICAgIGxldCBfcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KHVybCwge1xuICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgIGJvZHk6IGRhdGEsXG4gICAgICAgICAgZHVwbGV4OiBcImhhbGZcIlxuICAgICAgICB9KTtcblxuICAgICAgICBsZXQgY29udGVudFR5cGVIZWFkZXI7XG5cbiAgICAgICAgaWYgKHV0aWxzJDEuaXNGb3JtRGF0YShkYXRhKSAmJiAoY29udGVudFR5cGVIZWFkZXIgPSBfcmVxdWVzdC5oZWFkZXJzLmdldCgnY29udGVudC10eXBlJykpKSB7XG4gICAgICAgICAgaGVhZGVycy5zZXRDb250ZW50VHlwZShjb250ZW50VHlwZUhlYWRlcik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoX3JlcXVlc3QuYm9keSkge1xuICAgICAgICAgIGNvbnN0IFtvblByb2dyZXNzLCBmbHVzaF0gPSBwcm9ncmVzc0V2ZW50RGVjb3JhdG9yKFxuICAgICAgICAgICAgcmVxdWVzdENvbnRlbnRMZW5ndGgsXG4gICAgICAgICAgICBwcm9ncmVzc0V2ZW50UmVkdWNlcihhc3luY0RlY29yYXRvcihvblVwbG9hZFByb2dyZXNzKSlcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgZGF0YSA9IHRyYWNrU3RyZWFtKF9yZXF1ZXN0LmJvZHksIERFRkFVTFRfQ0hVTktfU0laRSwgb25Qcm9ncmVzcywgZmx1c2gpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghdXRpbHMkMS5pc1N0cmluZyh3aXRoQ3JlZGVudGlhbHMpKSB7XG4gICAgICAgIHdpdGhDcmVkZW50aWFscyA9IHdpdGhDcmVkZW50aWFscyA/ICdpbmNsdWRlJyA6ICdvbWl0JztcbiAgICAgIH1cblxuICAgICAgLy8gQ2xvdWRmbGFyZSBXb3JrZXJzIHRocm93cyB3aGVuIGNyZWRlbnRpYWxzIGFyZSBkZWZpbmVkXG4gICAgICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2Nsb3VkZmxhcmUvd29ya2VyZC9pc3N1ZXMvOTAyXG4gICAgICBjb25zdCBpc0NyZWRlbnRpYWxzU3VwcG9ydGVkID0gaXNSZXF1ZXN0U3VwcG9ydGVkICYmIFwiY3JlZGVudGlhbHNcIiBpbiBSZXF1ZXN0LnByb3RvdHlwZTtcblxuICAgICAgY29uc3QgcmVzb2x2ZWRPcHRpb25zID0ge1xuICAgICAgICAuLi5mZXRjaE9wdGlvbnMsXG4gICAgICAgIHNpZ25hbDogY29tcG9zZWRTaWduYWwsXG4gICAgICAgIG1ldGhvZDogbWV0aG9kLnRvVXBwZXJDYXNlKCksXG4gICAgICAgIGhlYWRlcnM6IGhlYWRlcnMubm9ybWFsaXplKCkudG9KU09OKCksXG4gICAgICAgIGJvZHk6IGRhdGEsXG4gICAgICAgIGR1cGxleDogXCJoYWxmXCIsXG4gICAgICAgIGNyZWRlbnRpYWxzOiBpc0NyZWRlbnRpYWxzU3VwcG9ydGVkID8gd2l0aENyZWRlbnRpYWxzIDogdW5kZWZpbmVkXG4gICAgICB9O1xuXG4gICAgICByZXF1ZXN0ID0gaXNSZXF1ZXN0U3VwcG9ydGVkICYmIG5ldyBSZXF1ZXN0KHVybCwgcmVzb2x2ZWRPcHRpb25zKTtcblxuICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgKGlzUmVxdWVzdFN1cHBvcnRlZCA/IF9mZXRjaChyZXF1ZXN0LCBmZXRjaE9wdGlvbnMpIDogX2ZldGNoKHVybCwgcmVzb2x2ZWRPcHRpb25zKSk7XG5cbiAgICAgIGNvbnN0IGlzU3RyZWFtUmVzcG9uc2UgPSBzdXBwb3J0c1Jlc3BvbnNlU3RyZWFtICYmIChyZXNwb25zZVR5cGUgPT09ICdzdHJlYW0nIHx8IHJlc3BvbnNlVHlwZSA9PT0gJ3Jlc3BvbnNlJyk7XG5cbiAgICAgIGlmIChzdXBwb3J0c1Jlc3BvbnNlU3RyZWFtICYmIChvbkRvd25sb2FkUHJvZ3Jlc3MgfHwgKGlzU3RyZWFtUmVzcG9uc2UgJiYgdW5zdWJzY3JpYmUpKSkge1xuICAgICAgICBjb25zdCBvcHRpb25zID0ge307XG5cbiAgICAgICAgWydzdGF0dXMnLCAnc3RhdHVzVGV4dCcsICdoZWFkZXJzJ10uZm9yRWFjaChwcm9wID0+IHtcbiAgICAgICAgICBvcHRpb25zW3Byb3BdID0gcmVzcG9uc2VbcHJvcF07XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlQ29udGVudExlbmd0aCA9IHV0aWxzJDEudG9GaW5pdGVOdW1iZXIocmVzcG9uc2UuaGVhZGVycy5nZXQoJ2NvbnRlbnQtbGVuZ3RoJykpO1xuXG4gICAgICAgIGNvbnN0IFtvblByb2dyZXNzLCBmbHVzaF0gPSBvbkRvd25sb2FkUHJvZ3Jlc3MgJiYgcHJvZ3Jlc3NFdmVudERlY29yYXRvcihcbiAgICAgICAgICByZXNwb25zZUNvbnRlbnRMZW5ndGgsXG4gICAgICAgICAgcHJvZ3Jlc3NFdmVudFJlZHVjZXIoYXN5bmNEZWNvcmF0b3Iob25Eb3dubG9hZFByb2dyZXNzKSwgdHJ1ZSlcbiAgICAgICAgKSB8fCBbXTtcblxuICAgICAgICByZXNwb25zZSA9IG5ldyBSZXNwb25zZShcbiAgICAgICAgICB0cmFja1N0cmVhbShyZXNwb25zZS5ib2R5LCBERUZBVUxUX0NIVU5LX1NJWkUsIG9uUHJvZ3Jlc3MsICgpID0+IHtcbiAgICAgICAgICAgIGZsdXNoICYmIGZsdXNoKCk7XG4gICAgICAgICAgICB1bnN1YnNjcmliZSAmJiB1bnN1YnNjcmliZSgpO1xuICAgICAgICAgIH0pLFxuICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgcmVzcG9uc2VUeXBlID0gcmVzcG9uc2VUeXBlIHx8ICd0ZXh0JztcblxuICAgICAgbGV0IHJlc3BvbnNlRGF0YSA9IGF3YWl0IHJlc29sdmVyc1t1dGlscyQxLmZpbmRLZXkocmVzb2x2ZXJzLCByZXNwb25zZVR5cGUpIHx8ICd0ZXh0J10ocmVzcG9uc2UsIGNvbmZpZyk7XG5cbiAgICAgICFpc1N0cmVhbVJlc3BvbnNlICYmIHVuc3Vic2NyaWJlICYmIHVuc3Vic2NyaWJlKCk7XG5cbiAgICAgIHJldHVybiBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHtcbiAgICAgICAgICBkYXRhOiByZXNwb25zZURhdGEsXG4gICAgICAgICAgaGVhZGVyczogQXhpb3NIZWFkZXJzJDEuZnJvbShyZXNwb25zZS5oZWFkZXJzKSxcbiAgICAgICAgICBzdGF0dXM6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgICBzdGF0dXNUZXh0OiByZXNwb25zZS5zdGF0dXNUZXh0LFxuICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgICByZXF1ZXN0XG4gICAgICAgIH0pO1xuICAgICAgfSlcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHVuc3Vic2NyaWJlICYmIHVuc3Vic2NyaWJlKCk7XG5cbiAgICAgIGlmIChlcnIgJiYgZXJyLm5hbWUgPT09ICdUeXBlRXJyb3InICYmIC9Mb2FkIGZhaWxlZHxmZXRjaC9pLnRlc3QoZXJyLm1lc3NhZ2UpKSB7XG4gICAgICAgIHRocm93IE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAgbmV3IEF4aW9zRXJyb3IkMSgnTmV0d29yayBFcnJvcicsIEF4aW9zRXJyb3IkMS5FUlJfTkVUV09SSywgY29uZmlnLCByZXF1ZXN0KSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjYXVzZTogZXJyLmNhdXNlIHx8IGVyclxuICAgICAgICAgIH1cbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICB0aHJvdyBBeGlvc0Vycm9yJDEuZnJvbShlcnIsIGVyciAmJiBlcnIuY29kZSwgY29uZmlnLCByZXF1ZXN0KTtcbiAgICB9XG4gIH1cbn07XG5cbmNvbnN0IHNlZWRDYWNoZSA9IG5ldyBNYXAoKTtcblxuY29uc3QgZ2V0RmV0Y2ggPSAoY29uZmlnKSA9PiB7XG4gIGxldCBlbnYgPSAoY29uZmlnICYmIGNvbmZpZy5lbnYpIHx8IHt9O1xuICBjb25zdCB7ZmV0Y2gsIFJlcXVlc3QsIFJlc3BvbnNlfSA9IGVudjtcbiAgY29uc3Qgc2VlZHMgPSBbXG4gICAgUmVxdWVzdCwgUmVzcG9uc2UsIGZldGNoXG4gIF07XG5cbiAgbGV0IGxlbiA9IHNlZWRzLmxlbmd0aCwgaSA9IGxlbixcbiAgICBzZWVkLCB0YXJnZXQsIG1hcCA9IHNlZWRDYWNoZTtcblxuICB3aGlsZSAoaS0tKSB7XG4gICAgc2VlZCA9IHNlZWRzW2ldO1xuICAgIHRhcmdldCA9IG1hcC5nZXQoc2VlZCk7XG5cbiAgICB0YXJnZXQgPT09IHVuZGVmaW5lZCAmJiBtYXAuc2V0KHNlZWQsIHRhcmdldCA9IChpID8gbmV3IE1hcCgpIDogZmFjdG9yeShlbnYpKSk7XG5cbiAgICBtYXAgPSB0YXJnZXQ7XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufTtcblxuZ2V0RmV0Y2goKTtcblxuLyoqXG4gKiBLbm93biBhZGFwdGVycyBtYXBwaW5nLlxuICogUHJvdmlkZXMgZW52aXJvbm1lbnQtc3BlY2lmaWMgYWRhcHRlcnMgZm9yIEF4aW9zOlxuICogLSBgaHR0cGAgZm9yIE5vZGUuanNcbiAqIC0gYHhocmAgZm9yIGJyb3dzZXJzXG4gKiAtIGBmZXRjaGAgZm9yIGZldGNoIEFQSS1iYXNlZCByZXF1ZXN0c1xuICogXG4gKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgRnVuY3Rpb258T2JqZWN0Pn1cbiAqL1xuY29uc3Qga25vd25BZGFwdGVycyA9IHtcbiAgaHR0cDogaHR0cEFkYXB0ZXIsXG4gIHhocjogeGhyQWRhcHRlcixcbiAgZmV0Y2g6IHtcbiAgICBnZXQ6IGdldEZldGNoLFxuICB9XG59O1xuXG4vLyBBc3NpZ24gYWRhcHRlciBuYW1lcyBmb3IgZWFzaWVyIGRlYnVnZ2luZyBhbmQgaWRlbnRpZmljYXRpb25cbnV0aWxzJDEuZm9yRWFjaChrbm93bkFkYXB0ZXJzLCAoZm4sIHZhbHVlKSA9PiB7XG4gIGlmIChmbikge1xuICAgIHRyeSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZm4sICduYW1lJywgeyB2YWx1ZSB9KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZW1wdHlcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGZuLCAnYWRhcHRlck5hbWUnLCB7IHZhbHVlIH0pO1xuICB9XG59KTtcblxuLyoqXG4gKiBSZW5kZXIgYSByZWplY3Rpb24gcmVhc29uIHN0cmluZyBmb3IgdW5rbm93biBvciB1bnN1cHBvcnRlZCBhZGFwdGVyc1xuICogXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVhc29uXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5jb25zdCByZW5kZXJSZWFzb24gPSAocmVhc29uKSA9PiBgLSAke3JlYXNvbn1gO1xuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBhZGFwdGVyIGlzIHJlc29sdmVkIChmdW5jdGlvbiwgbnVsbCwgb3IgZmFsc2UpXG4gKiBcbiAqIEBwYXJhbSB7RnVuY3Rpb258bnVsbHxmYWxzZX0gYWRhcHRlclxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmNvbnN0IGlzUmVzb2x2ZWRIYW5kbGUgPSAoYWRhcHRlcikgPT4gdXRpbHMkMS5pc0Z1bmN0aW9uKGFkYXB0ZXIpIHx8IGFkYXB0ZXIgPT09IG51bGwgfHwgYWRhcHRlciA9PT0gZmFsc2U7XG5cbi8qKlxuICogR2V0IHRoZSBmaXJzdCBzdWl0YWJsZSBhZGFwdGVyIGZyb20gdGhlIHByb3ZpZGVkIGxpc3QuXG4gKiBUcmllcyBlYWNoIGFkYXB0ZXIgaW4gb3JkZXIgdW50aWwgYSBzdXBwb3J0ZWQgb25lIGlzIGZvdW5kLlxuICogVGhyb3dzIGFuIEF4aW9zRXJyb3IgaWYgbm8gYWRhcHRlciBpcyBzdWl0YWJsZS5cbiAqIFxuICogQHBhcmFtIHtBcnJheTxzdHJpbmd8RnVuY3Rpb24+fHN0cmluZ3xGdW5jdGlvbn0gYWRhcHRlcnMgLSBBZGFwdGVyKHMpIGJ5IG5hbWUgb3IgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIC0gQXhpb3MgcmVxdWVzdCBjb25maWd1cmF0aW9uXG4gKiBAdGhyb3dzIHtBeGlvc0Vycm9yfSBJZiBubyBzdWl0YWJsZSBhZGFwdGVyIGlzIGF2YWlsYWJsZVxuICogQHJldHVybnMge0Z1bmN0aW9ufSBUaGUgcmVzb2x2ZWQgYWRhcHRlciBmdW5jdGlvblxuICovXG5mdW5jdGlvbiBnZXRBZGFwdGVyKGFkYXB0ZXJzLCBjb25maWcpIHtcbiAgYWRhcHRlcnMgPSB1dGlscyQxLmlzQXJyYXkoYWRhcHRlcnMpID8gYWRhcHRlcnMgOiBbYWRhcHRlcnNdO1xuXG4gIGNvbnN0IHsgbGVuZ3RoIH0gPSBhZGFwdGVycztcbiAgbGV0IG5hbWVPckFkYXB0ZXI7XG4gIGxldCBhZGFwdGVyO1xuXG4gIGNvbnN0IHJlamVjdGVkUmVhc29ucyA9IHt9O1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBuYW1lT3JBZGFwdGVyID0gYWRhcHRlcnNbaV07XG4gICAgbGV0IGlkO1xuXG4gICAgYWRhcHRlciA9IG5hbWVPckFkYXB0ZXI7XG5cbiAgICBpZiAoIWlzUmVzb2x2ZWRIYW5kbGUobmFtZU9yQWRhcHRlcikpIHtcbiAgICAgIGFkYXB0ZXIgPSBrbm93bkFkYXB0ZXJzWyhpZCA9IFN0cmluZyhuYW1lT3JBZGFwdGVyKSkudG9Mb3dlckNhc2UoKV07XG5cbiAgICAgIGlmIChhZGFwdGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEF4aW9zRXJyb3IkMShgVW5rbm93biBhZGFwdGVyICcke2lkfSdgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYWRhcHRlciAmJiAodXRpbHMkMS5pc0Z1bmN0aW9uKGFkYXB0ZXIpIHx8IChhZGFwdGVyID0gYWRhcHRlci5nZXQoY29uZmlnKSkpKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICByZWplY3RlZFJlYXNvbnNbaWQgfHwgJyMnICsgaV0gPSBhZGFwdGVyO1xuICB9XG5cbiAgaWYgKCFhZGFwdGVyKSB7XG4gICAgY29uc3QgcmVhc29ucyA9IE9iamVjdC5lbnRyaWVzKHJlamVjdGVkUmVhc29ucylcbiAgICAgIC5tYXAoKFtpZCwgc3RhdGVdKSA9PiBgYWRhcHRlciAke2lkfSBgICtcbiAgICAgICAgKHN0YXRlID09PSBmYWxzZSA/ICdpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoZSBlbnZpcm9ubWVudCcgOiAnaXMgbm90IGF2YWlsYWJsZSBpbiB0aGUgYnVpbGQnKVxuICAgICAgKTtcblxuICAgIGxldCBzID0gbGVuZ3RoID9cbiAgICAgIChyZWFzb25zLmxlbmd0aCA+IDEgPyAnc2luY2UgOlxcbicgKyByZWFzb25zLm1hcChyZW5kZXJSZWFzb24pLmpvaW4oJ1xcbicpIDogJyAnICsgcmVuZGVyUmVhc29uKHJlYXNvbnNbMF0pKSA6XG4gICAgICAnYXMgbm8gYWRhcHRlciBzcGVjaWZpZWQnO1xuXG4gICAgdGhyb3cgbmV3IEF4aW9zRXJyb3IkMShcbiAgICAgIGBUaGVyZSBpcyBubyBzdWl0YWJsZSBhZGFwdGVyIHRvIGRpc3BhdGNoIHRoZSByZXF1ZXN0IGAgKyBzLFxuICAgICAgJ0VSUl9OT1RfU1VQUE9SVCdcbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIGFkYXB0ZXI7XG59XG5cbi8qKlxuICogRXhwb3J0cyBBeGlvcyBhZGFwdGVycyBhbmQgdXRpbGl0eSB0byByZXNvbHZlIGFuIGFkYXB0ZXJcbiAqL1xuY29uc3QgYWRhcHRlcnMgPSB7XG4gIC8qKlxuICAgKiBSZXNvbHZlIGFuIGFkYXB0ZXIgZnJvbSBhIGxpc3Qgb2YgYWRhcHRlciBuYW1lcyBvciBmdW5jdGlvbnMuXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICovXG4gIGdldEFkYXB0ZXIsXG5cbiAgLyoqXG4gICAqIEV4cG9zZXMgYWxsIGtub3duIGFkYXB0ZXJzXG4gICAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBGdW5jdGlvbnxPYmplY3Q+fVxuICAgKi9cbiAgYWRhcHRlcnM6IGtub3duQWRhcHRlcnNcbn07XG5cbi8qKlxuICogVGhyb3dzIGEgYENhbmNlbGVkRXJyb3JgIGlmIGNhbmNlbGxhdGlvbiBoYXMgYmVlbiByZXF1ZXN0ZWQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBUaGUgY29uZmlnIHRoYXQgaXMgdG8gYmUgdXNlZCBmb3IgdGhlIHJlcXVlc3RcbiAqXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZnVuY3Rpb24gdGhyb3dJZkNhbmNlbGxhdGlvblJlcXVlc3RlZChjb25maWcpIHtcbiAgaWYgKGNvbmZpZy5jYW5jZWxUb2tlbikge1xuICAgIGNvbmZpZy5jYW5jZWxUb2tlbi50aHJvd0lmUmVxdWVzdGVkKCk7XG4gIH1cblxuICBpZiAoY29uZmlnLnNpZ25hbCAmJiBjb25maWcuc2lnbmFsLmFib3J0ZWQpIHtcbiAgICB0aHJvdyBuZXcgQ2FuY2VsZWRFcnJvciQxKG51bGwsIGNvbmZpZyk7XG4gIH1cbn1cblxuLyoqXG4gKiBEaXNwYXRjaCBhIHJlcXVlc3QgdG8gdGhlIHNlcnZlciB1c2luZyB0aGUgY29uZmlndXJlZCBhZGFwdGVyLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZyB0aGF0IGlzIHRvIGJlIHVzZWQgZm9yIHRoZSByZXF1ZXN0XG4gKlxuICogQHJldHVybnMge1Byb21pc2V9IFRoZSBQcm9taXNlIHRvIGJlIGZ1bGZpbGxlZFxuICovXG5mdW5jdGlvbiBkaXNwYXRjaFJlcXVlc3QoY29uZmlnKSB7XG4gIHRocm93SWZDYW5jZWxsYXRpb25SZXF1ZXN0ZWQoY29uZmlnKTtcblxuICBjb25maWcuaGVhZGVycyA9IEF4aW9zSGVhZGVycyQxLmZyb20oY29uZmlnLmhlYWRlcnMpO1xuXG4gIC8vIFRyYW5zZm9ybSByZXF1ZXN0IGRhdGFcbiAgY29uZmlnLmRhdGEgPSB0cmFuc2Zvcm1EYXRhLmNhbGwoXG4gICAgY29uZmlnLFxuICAgIGNvbmZpZy50cmFuc2Zvcm1SZXF1ZXN0XG4gICk7XG5cbiAgaWYgKFsncG9zdCcsICdwdXQnLCAncGF0Y2gnXS5pbmRleE9mKGNvbmZpZy5tZXRob2QpICE9PSAtMSkge1xuICAgIGNvbmZpZy5oZWFkZXJzLnNldENvbnRlbnRUeXBlKCdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnLCBmYWxzZSk7XG4gIH1cblxuICBjb25zdCBhZGFwdGVyID0gYWRhcHRlcnMuZ2V0QWRhcHRlcihjb25maWcuYWRhcHRlciB8fCBkZWZhdWx0cyQxLmFkYXB0ZXIsIGNvbmZpZyk7XG5cbiAgcmV0dXJuIGFkYXB0ZXIoY29uZmlnKS50aGVuKGZ1bmN0aW9uIG9uQWRhcHRlclJlc29sdXRpb24ocmVzcG9uc2UpIHtcbiAgICB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZyk7XG5cbiAgICAvLyBUcmFuc2Zvcm0gcmVzcG9uc2UgZGF0YVxuICAgIHJlc3BvbnNlLmRhdGEgPSB0cmFuc2Zvcm1EYXRhLmNhbGwoXG4gICAgICBjb25maWcsXG4gICAgICBjb25maWcudHJhbnNmb3JtUmVzcG9uc2UsXG4gICAgICByZXNwb25zZVxuICAgICk7XG5cbiAgICByZXNwb25zZS5oZWFkZXJzID0gQXhpb3NIZWFkZXJzJDEuZnJvbShyZXNwb25zZS5oZWFkZXJzKTtcblxuICAgIHJldHVybiByZXNwb25zZTtcbiAgfSwgZnVuY3Rpb24gb25BZGFwdGVyUmVqZWN0aW9uKHJlYXNvbikge1xuICAgIGlmICghaXNDYW5jZWwocmVhc29uKSkge1xuICAgICAgdGhyb3dJZkNhbmNlbGxhdGlvblJlcXVlc3RlZChjb25maWcpO1xuXG4gICAgICAvLyBUcmFuc2Zvcm0gcmVzcG9uc2UgZGF0YVxuICAgICAgaWYgKHJlYXNvbiAmJiByZWFzb24ucmVzcG9uc2UpIHtcbiAgICAgICAgcmVhc29uLnJlc3BvbnNlLmRhdGEgPSB0cmFuc2Zvcm1EYXRhLmNhbGwoXG4gICAgICAgICAgY29uZmlnLFxuICAgICAgICAgIGNvbmZpZy50cmFuc2Zvcm1SZXNwb25zZSxcbiAgICAgICAgICByZWFzb24ucmVzcG9uc2VcbiAgICAgICAgKTtcbiAgICAgICAgcmVhc29uLnJlc3BvbnNlLmhlYWRlcnMgPSBBeGlvc0hlYWRlcnMkMS5mcm9tKHJlYXNvbi5yZXNwb25zZS5oZWFkZXJzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QocmVhc29uKTtcbiAgfSk7XG59XG5cbmNvbnN0IHZhbGlkYXRvcnMkMSA9IHt9O1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xuWydvYmplY3QnLCAnYm9vbGVhbicsICdudW1iZXInLCAnZnVuY3Rpb24nLCAnc3RyaW5nJywgJ3N5bWJvbCddLmZvckVhY2goKHR5cGUsIGkpID0+IHtcbiAgdmFsaWRhdG9ycyQxW3R5cGVdID0gZnVuY3Rpb24gdmFsaWRhdG9yKHRoaW5nKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB0aGluZyA9PT0gdHlwZSB8fCAnYScgKyAoaSA8IDEgPyAnbiAnIDogJyAnKSArIHR5cGU7XG4gIH07XG59KTtcblxuY29uc3QgZGVwcmVjYXRlZFdhcm5pbmdzID0ge307XG5cbi8qKlxuICogVHJhbnNpdGlvbmFsIG9wdGlvbiB2YWxpZGF0b3JcbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufGJvb2xlYW4/fSB2YWxpZGF0b3IgLSBzZXQgdG8gZmFsc2UgaWYgdGhlIHRyYW5zaXRpb25hbCBvcHRpb24gaGFzIGJlZW4gcmVtb3ZlZFxuICogQHBhcmFtIHtzdHJpbmc/fSB2ZXJzaW9uIC0gZGVwcmVjYXRlZCB2ZXJzaW9uIC8gcmVtb3ZlZCBzaW5jZSB2ZXJzaW9uXG4gKiBAcGFyYW0ge3N0cmluZz99IG1lc3NhZ2UgLSBzb21lIG1lc3NhZ2Ugd2l0aCBhZGRpdGlvbmFsIGluZm9cbiAqXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb259XG4gKi9cbnZhbGlkYXRvcnMkMS50cmFuc2l0aW9uYWwgPSBmdW5jdGlvbiB0cmFuc2l0aW9uYWwodmFsaWRhdG9yLCB2ZXJzaW9uLCBtZXNzYWdlKSB7XG4gIGZ1bmN0aW9uIGZvcm1hdE1lc3NhZ2Uob3B0LCBkZXNjKSB7XG4gICAgcmV0dXJuICdbQXhpb3MgdicgKyBWRVJTSU9OICsgJ10gVHJhbnNpdGlvbmFsIG9wdGlvbiBcXCcnICsgb3B0ICsgJ1xcJycgKyBkZXNjICsgKG1lc3NhZ2UgPyAnLiAnICsgbWVzc2FnZSA6ICcnKTtcbiAgfVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG4gIHJldHVybiAodmFsdWUsIG9wdCwgb3B0cykgPT4ge1xuICAgIGlmICh2YWxpZGF0b3IgPT09IGZhbHNlKSB7XG4gICAgICB0aHJvdyBuZXcgQXhpb3NFcnJvciQxKFxuICAgICAgICBmb3JtYXRNZXNzYWdlKG9wdCwgJyBoYXMgYmVlbiByZW1vdmVkJyArICh2ZXJzaW9uID8gJyBpbiAnICsgdmVyc2lvbiA6ICcnKSksXG4gICAgICAgIEF4aW9zRXJyb3IkMS5FUlJfREVQUkVDQVRFRFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAodmVyc2lvbiAmJiAhZGVwcmVjYXRlZFdhcm5pbmdzW29wdF0pIHtcbiAgICAgIGRlcHJlY2F0ZWRXYXJuaW5nc1tvcHRdID0gdHJ1ZTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIGZvcm1hdE1lc3NhZ2UoXG4gICAgICAgICAgb3B0LFxuICAgICAgICAgICcgaGFzIGJlZW4gZGVwcmVjYXRlZCBzaW5jZSB2JyArIHZlcnNpb24gKyAnIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5lYXIgZnV0dXJlJ1xuICAgICAgICApXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiB2YWxpZGF0b3IgPyB2YWxpZGF0b3IodmFsdWUsIG9wdCwgb3B0cykgOiB0cnVlO1xuICB9O1xufTtcblxudmFsaWRhdG9ycyQxLnNwZWxsaW5nID0gZnVuY3Rpb24gc3BlbGxpbmcoY29ycmVjdFNwZWxsaW5nKSB7XG4gIHJldHVybiAodmFsdWUsIG9wdCkgPT4ge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgY29uc29sZS53YXJuKGAke29wdH0gaXMgbGlrZWx5IGEgbWlzc3BlbGxpbmcgb2YgJHtjb3JyZWN0U3BlbGxpbmd9YCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG5cbi8qKlxuICogQXNzZXJ0IG9iamVjdCdzIHByb3BlcnRpZXMgdHlwZVxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge29iamVjdH0gc2NoZW1hXG4gKiBAcGFyYW0ge2Jvb2xlYW4/fSBhbGxvd1Vua25vd25cbiAqXG4gKiBAcmV0dXJucyB7b2JqZWN0fVxuICovXG5cbmZ1bmN0aW9uIGFzc2VydE9wdGlvbnMob3B0aW9ucywgc2NoZW1hLCBhbGxvd1Vua25vd24pIHtcbiAgaWYgKHR5cGVvZiBvcHRpb25zICE9PSAnb2JqZWN0Jykge1xuICAgIHRocm93IG5ldyBBeGlvc0Vycm9yJDEoJ29wdGlvbnMgbXVzdCBiZSBhbiBvYmplY3QnLCBBeGlvc0Vycm9yJDEuRVJSX0JBRF9PUFRJT05fVkFMVUUpO1xuICB9XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhvcHRpb25zKTtcbiAgbGV0IGkgPSBrZXlzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSA+IDApIHtcbiAgICBjb25zdCBvcHQgPSBrZXlzW2ldO1xuICAgIGNvbnN0IHZhbGlkYXRvciA9IHNjaGVtYVtvcHRdO1xuICAgIGlmICh2YWxpZGF0b3IpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gb3B0aW9uc1tvcHRdO1xuICAgICAgY29uc3QgcmVzdWx0ID0gdmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWxpZGF0b3IodmFsdWUsIG9wdCwgb3B0aW9ucyk7XG4gICAgICBpZiAocmVzdWx0ICE9PSB0cnVlKSB7XG4gICAgICAgIHRocm93IG5ldyBBeGlvc0Vycm9yJDEoJ29wdGlvbiAnICsgb3B0ICsgJyBtdXN0IGJlICcgKyByZXN1bHQsIEF4aW9zRXJyb3IkMS5FUlJfQkFEX09QVElPTl9WQUxVRSk7XG4gICAgICB9XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGFsbG93VW5rbm93biAhPT0gdHJ1ZSkge1xuICAgICAgdGhyb3cgbmV3IEF4aW9zRXJyb3IkMSgnVW5rbm93biBvcHRpb24gJyArIG9wdCwgQXhpb3NFcnJvciQxLkVSUl9CQURfT1BUSU9OKTtcbiAgICB9XG4gIH1cbn1cblxuY29uc3QgdmFsaWRhdG9yID0ge1xuICBhc3NlcnRPcHRpb25zLFxuICB2YWxpZGF0b3JzOiB2YWxpZGF0b3JzJDFcbn07XG5cbmNvbnN0IHZhbGlkYXRvcnMgPSB2YWxpZGF0b3IudmFsaWRhdG9ycztcblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2YgQXhpb3NcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gaW5zdGFuY2VDb25maWcgVGhlIGRlZmF1bHQgY29uZmlnIGZvciB0aGUgaW5zdGFuY2VcbiAqXG4gKiBAcmV0dXJuIHtBeGlvc30gQSBuZXcgaW5zdGFuY2Ugb2YgQXhpb3NcbiAqL1xuY2xhc3MgQXhpb3Mge1xuICBjb25zdHJ1Y3RvcihpbnN0YW5jZUNvbmZpZykge1xuICAgIHRoaXMuZGVmYXVsdHMgPSBpbnN0YW5jZUNvbmZpZyB8fCB7fTtcbiAgICB0aGlzLmludGVyY2VwdG9ycyA9IHtcbiAgICAgIHJlcXVlc3Q6IG5ldyBJbnRlcmNlcHRvck1hbmFnZXIkMSgpLFxuICAgICAgcmVzcG9uc2U6IG5ldyBJbnRlcmNlcHRvck1hbmFnZXIkMSgpXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNwYXRjaCBhIHJlcXVlc3RcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBjb25maWdPclVybCBUaGUgY29uZmlnIHNwZWNpZmljIGZvciB0aGlzIHJlcXVlc3QgKG1lcmdlZCB3aXRoIHRoaXMuZGVmYXVsdHMpXG4gICAqIEBwYXJhbSB7P09iamVjdH0gY29uZmlnXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgUHJvbWlzZSB0byBiZSBmdWxmaWxsZWRcbiAgICovXG4gIGFzeW5jIHJlcXVlc3QoY29uZmlnT3JVcmwsIGNvbmZpZykge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5fcmVxdWVzdChjb25maWdPclVybCwgY29uZmlnKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICBsZXQgZHVtbXkgPSB7fTtcblxuICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSA/IEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKGR1bW15KSA6IChkdW1teSA9IG5ldyBFcnJvcigpKTtcblxuICAgICAgICAvLyBzbGljZSBvZmYgdGhlIEVycm9yOiAuLi4gbGluZVxuICAgICAgICBjb25zdCBzdGFjayA9IGR1bW15LnN0YWNrID8gZHVtbXkuc3RhY2sucmVwbGFjZSgvXi4rXFxuLywgJycpIDogJyc7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKCFlcnIuc3RhY2spIHtcbiAgICAgICAgICAgIGVyci5zdGFjayA9IHN0YWNrO1xuICAgICAgICAgICAgLy8gbWF0Y2ggd2l0aG91dCB0aGUgMiB0b3Agc3RhY2sgbGluZXNcbiAgICAgICAgICB9IGVsc2UgaWYgKHN0YWNrICYmICFTdHJpbmcoZXJyLnN0YWNrKS5lbmRzV2l0aChzdGFjay5yZXBsYWNlKC9eLitcXG4uK1xcbi8sICcnKSkpIHtcbiAgICAgICAgICAgIGVyci5zdGFjayArPSAnXFxuJyArIHN0YWNrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIC8vIGlnbm9yZSB0aGUgY2FzZSB3aGVyZSBcInN0YWNrXCIgaXMgYW4gdW4td3JpdGFibGUgcHJvcGVydHlcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICB9XG5cbiAgX3JlcXVlc3QoY29uZmlnT3JVcmwsIGNvbmZpZykge1xuICAgIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICAgIC8vIEFsbG93IGZvciBheGlvcygnZXhhbXBsZS91cmwnWywgY29uZmlnXSkgYSBsYSBmZXRjaCBBUElcbiAgICBpZiAodHlwZW9mIGNvbmZpZ09yVXJsID09PSAnc3RyaW5nJykge1xuICAgICAgY29uZmlnID0gY29uZmlnIHx8IHt9O1xuICAgICAgY29uZmlnLnVybCA9IGNvbmZpZ09yVXJsO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25maWcgPSBjb25maWdPclVybCB8fCB7fTtcbiAgICB9XG5cbiAgICBjb25maWcgPSBtZXJnZUNvbmZpZyh0aGlzLmRlZmF1bHRzLCBjb25maWcpO1xuXG4gICAgY29uc3Qge3RyYW5zaXRpb25hbCwgcGFyYW1zU2VyaWFsaXplciwgaGVhZGVyc30gPSBjb25maWc7XG5cbiAgICBpZiAodHJhbnNpdGlvbmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhbGlkYXRvci5hc3NlcnRPcHRpb25zKHRyYW5zaXRpb25hbCwge1xuICAgICAgICBzaWxlbnRKU09OUGFyc2luZzogdmFsaWRhdG9ycy50cmFuc2l0aW9uYWwodmFsaWRhdG9ycy5ib29sZWFuKSxcbiAgICAgICAgZm9yY2VkSlNPTlBhcnNpbmc6IHZhbGlkYXRvcnMudHJhbnNpdGlvbmFsKHZhbGlkYXRvcnMuYm9vbGVhbiksXG4gICAgICAgIGNsYXJpZnlUaW1lb3V0RXJyb3I6IHZhbGlkYXRvcnMudHJhbnNpdGlvbmFsKHZhbGlkYXRvcnMuYm9vbGVhbilcbiAgICAgIH0sIGZhbHNlKTtcbiAgICB9XG5cbiAgICBpZiAocGFyYW1zU2VyaWFsaXplciAhPSBudWxsKSB7XG4gICAgICBpZiAodXRpbHMkMS5pc0Z1bmN0aW9uKHBhcmFtc1NlcmlhbGl6ZXIpKSB7XG4gICAgICAgIGNvbmZpZy5wYXJhbXNTZXJpYWxpemVyID0ge1xuICAgICAgICAgIHNlcmlhbGl6ZTogcGFyYW1zU2VyaWFsaXplclxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsaWRhdG9yLmFzc2VydE9wdGlvbnMocGFyYW1zU2VyaWFsaXplciwge1xuICAgICAgICAgIGVuY29kZTogdmFsaWRhdG9ycy5mdW5jdGlvbixcbiAgICAgICAgICBzZXJpYWxpemU6IHZhbGlkYXRvcnMuZnVuY3Rpb25cbiAgICAgICAgfSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gU2V0IGNvbmZpZy5hbGxvd0Fic29sdXRlVXJsc1xuICAgIGlmIChjb25maWcuYWxsb3dBYnNvbHV0ZVVybHMgIT09IHVuZGVmaW5lZCkgOyBlbHNlIGlmICh0aGlzLmRlZmF1bHRzLmFsbG93QWJzb2x1dGVVcmxzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbmZpZy5hbGxvd0Fic29sdXRlVXJscyA9IHRoaXMuZGVmYXVsdHMuYWxsb3dBYnNvbHV0ZVVybHM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbmZpZy5hbGxvd0Fic29sdXRlVXJscyA9IHRydWU7XG4gICAgfVxuXG4gICAgdmFsaWRhdG9yLmFzc2VydE9wdGlvbnMoY29uZmlnLCB7XG4gICAgICBiYXNlVXJsOiB2YWxpZGF0b3JzLnNwZWxsaW5nKCdiYXNlVVJMJyksXG4gICAgICB3aXRoWHNyZlRva2VuOiB2YWxpZGF0b3JzLnNwZWxsaW5nKCd3aXRoWFNSRlRva2VuJylcbiAgICB9LCB0cnVlKTtcblxuICAgIC8vIFNldCBjb25maWcubWV0aG9kXG4gICAgY29uZmlnLm1ldGhvZCA9IChjb25maWcubWV0aG9kIHx8IHRoaXMuZGVmYXVsdHMubWV0aG9kIHx8ICdnZXQnKS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgLy8gRmxhdHRlbiBoZWFkZXJzXG4gICAgbGV0IGNvbnRleHRIZWFkZXJzID0gaGVhZGVycyAmJiB1dGlscyQxLm1lcmdlKFxuICAgICAgaGVhZGVycy5jb21tb24sXG4gICAgICBoZWFkZXJzW2NvbmZpZy5tZXRob2RdXG4gICAgKTtcblxuICAgIGhlYWRlcnMgJiYgdXRpbHMkMS5mb3JFYWNoKFxuICAgICAgWydkZWxldGUnLCAnZ2V0JywgJ2hlYWQnLCAncG9zdCcsICdwdXQnLCAncGF0Y2gnLCAnY29tbW9uJ10sXG4gICAgICAobWV0aG9kKSA9PiB7XG4gICAgICAgIGRlbGV0ZSBoZWFkZXJzW21ldGhvZF07XG4gICAgICB9XG4gICAgKTtcblxuICAgIGNvbmZpZy5oZWFkZXJzID0gQXhpb3NIZWFkZXJzJDEuY29uY2F0KGNvbnRleHRIZWFkZXJzLCBoZWFkZXJzKTtcblxuICAgIC8vIGZpbHRlciBvdXQgc2tpcHBlZCBpbnRlcmNlcHRvcnNcbiAgICBjb25zdCByZXF1ZXN0SW50ZXJjZXB0b3JDaGFpbiA9IFtdO1xuICAgIGxldCBzeW5jaHJvbm91c1JlcXVlc3RJbnRlcmNlcHRvcnMgPSB0cnVlO1xuICAgIHRoaXMuaW50ZXJjZXB0b3JzLnJlcXVlc3QuZm9yRWFjaChmdW5jdGlvbiB1bnNoaWZ0UmVxdWVzdEludGVyY2VwdG9ycyhpbnRlcmNlcHRvcikge1xuICAgICAgaWYgKHR5cGVvZiBpbnRlcmNlcHRvci5ydW5XaGVuID09PSAnZnVuY3Rpb24nICYmIGludGVyY2VwdG9yLnJ1bldoZW4oY29uZmlnKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBzeW5jaHJvbm91c1JlcXVlc3RJbnRlcmNlcHRvcnMgPSBzeW5jaHJvbm91c1JlcXVlc3RJbnRlcmNlcHRvcnMgJiYgaW50ZXJjZXB0b3Iuc3luY2hyb25vdXM7XG5cbiAgICAgIHJlcXVlc3RJbnRlcmNlcHRvckNoYWluLnVuc2hpZnQoaW50ZXJjZXB0b3IuZnVsZmlsbGVkLCBpbnRlcmNlcHRvci5yZWplY3RlZCk7XG4gICAgfSk7XG5cbiAgICBjb25zdCByZXNwb25zZUludGVyY2VwdG9yQ2hhaW4gPSBbXTtcbiAgICB0aGlzLmludGVyY2VwdG9ycy5yZXNwb25zZS5mb3JFYWNoKGZ1bmN0aW9uIHB1c2hSZXNwb25zZUludGVyY2VwdG9ycyhpbnRlcmNlcHRvcikge1xuICAgICAgcmVzcG9uc2VJbnRlcmNlcHRvckNoYWluLnB1c2goaW50ZXJjZXB0b3IuZnVsZmlsbGVkLCBpbnRlcmNlcHRvci5yZWplY3RlZCk7XG4gICAgfSk7XG5cbiAgICBsZXQgcHJvbWlzZTtcbiAgICBsZXQgaSA9IDA7XG4gICAgbGV0IGxlbjtcblxuICAgIGlmICghc3luY2hyb25vdXNSZXF1ZXN0SW50ZXJjZXB0b3JzKSB7XG4gICAgICBjb25zdCBjaGFpbiA9IFtkaXNwYXRjaFJlcXVlc3QuYmluZCh0aGlzKSwgdW5kZWZpbmVkXTtcbiAgICAgIGNoYWluLnVuc2hpZnQoLi4ucmVxdWVzdEludGVyY2VwdG9yQ2hhaW4pO1xuICAgICAgY2hhaW4ucHVzaCguLi5yZXNwb25zZUludGVyY2VwdG9yQ2hhaW4pO1xuICAgICAgbGVuID0gY2hhaW4ubGVuZ3RoO1xuXG4gICAgICBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKGNvbmZpZyk7XG5cbiAgICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oY2hhaW5baSsrXSwgY2hhaW5baSsrXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cblxuICAgIGxlbiA9IHJlcXVlc3RJbnRlcmNlcHRvckNoYWluLmxlbmd0aDtcblxuICAgIGxldCBuZXdDb25maWcgPSBjb25maWc7XG5cbiAgICB3aGlsZSAoaSA8IGxlbikge1xuICAgICAgY29uc3Qgb25GdWxmaWxsZWQgPSByZXF1ZXN0SW50ZXJjZXB0b3JDaGFpbltpKytdO1xuICAgICAgY29uc3Qgb25SZWplY3RlZCA9IHJlcXVlc3RJbnRlcmNlcHRvckNoYWluW2krK107XG4gICAgICB0cnkge1xuICAgICAgICBuZXdDb25maWcgPSBvbkZ1bGZpbGxlZChuZXdDb25maWcpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgb25SZWplY3RlZC5jYWxsKHRoaXMsIGVycm9yKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHByb21pc2UgPSBkaXNwYXRjaFJlcXVlc3QuY2FsbCh0aGlzLCBuZXdDb25maWcpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgIH1cblxuICAgIGkgPSAwO1xuICAgIGxlbiA9IHJlc3BvbnNlSW50ZXJjZXB0b3JDaGFpbi5sZW5ndGg7XG5cbiAgICB3aGlsZSAoaSA8IGxlbikge1xuICAgICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihyZXNwb25zZUludGVyY2VwdG9yQ2hhaW5baSsrXSwgcmVzcG9uc2VJbnRlcmNlcHRvckNoYWluW2krK10pO1xuICAgIH1cblxuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG5cbiAgZ2V0VXJpKGNvbmZpZykge1xuICAgIGNvbmZpZyA9IG1lcmdlQ29uZmlnKHRoaXMuZGVmYXVsdHMsIGNvbmZpZyk7XG4gICAgY29uc3QgZnVsbFBhdGggPSBidWlsZEZ1bGxQYXRoKGNvbmZpZy5iYXNlVVJMLCBjb25maWcudXJsLCBjb25maWcuYWxsb3dBYnNvbHV0ZVVybHMpO1xuICAgIHJldHVybiBidWlsZFVSTChmdWxsUGF0aCwgY29uZmlnLnBhcmFtcywgY29uZmlnLnBhcmFtc1NlcmlhbGl6ZXIpO1xuICB9XG59XG5cbi8vIFByb3ZpZGUgYWxpYXNlcyBmb3Igc3VwcG9ydGVkIHJlcXVlc3QgbWV0aG9kc1xudXRpbHMkMS5mb3JFYWNoKFsnZGVsZXRlJywgJ2dldCcsICdoZWFkJywgJ29wdGlvbnMnXSwgZnVuY3Rpb24gZm9yRWFjaE1ldGhvZE5vRGF0YShtZXRob2QpIHtcbiAgLyplc2xpbnQgZnVuYy1uYW1lczowKi9cbiAgQXhpb3MucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbih1cmwsIGNvbmZpZykge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3QobWVyZ2VDb25maWcoY29uZmlnIHx8IHt9LCB7XG4gICAgICBtZXRob2QsXG4gICAgICB1cmwsXG4gICAgICBkYXRhOiAoY29uZmlnIHx8IHt9KS5kYXRhXG4gICAgfSkpO1xuICB9O1xufSk7XG5cbnV0aWxzJDEuZm9yRWFjaChbJ3Bvc3QnLCAncHV0JywgJ3BhdGNoJ10sIGZ1bmN0aW9uIGZvckVhY2hNZXRob2RXaXRoRGF0YShtZXRob2QpIHtcbiAgLyplc2xpbnQgZnVuYy1uYW1lczowKi9cblxuICBmdW5jdGlvbiBnZW5lcmF0ZUhUVFBNZXRob2QoaXNGb3JtKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGh0dHBNZXRob2QodXJsLCBkYXRhLCBjb25maWcpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QobWVyZ2VDb25maWcoY29uZmlnIHx8IHt9LCB7XG4gICAgICAgIG1ldGhvZCxcbiAgICAgICAgaGVhZGVyczogaXNGb3JtID8ge1xuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnbXVsdGlwYXJ0L2Zvcm0tZGF0YSdcbiAgICAgICAgfSA6IHt9LFxuICAgICAgICB1cmwsXG4gICAgICAgIGRhdGFcbiAgICAgIH0pKTtcbiAgICB9O1xuICB9XG5cbiAgQXhpb3MucHJvdG90eXBlW21ldGhvZF0gPSBnZW5lcmF0ZUhUVFBNZXRob2QoKTtcblxuICBBeGlvcy5wcm90b3R5cGVbbWV0aG9kICsgJ0Zvcm0nXSA9IGdlbmVyYXRlSFRUUE1ldGhvZCh0cnVlKTtcbn0pO1xuXG5jb25zdCBBeGlvcyQxID0gQXhpb3M7XG5cbi8qKlxuICogQSBgQ2FuY2VsVG9rZW5gIGlzIGFuIG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIHRvIHJlcXVlc3QgY2FuY2VsbGF0aW9uIG9mIGFuIG9wZXJhdGlvbi5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBleGVjdXRvciBUaGUgZXhlY3V0b3IgZnVuY3Rpb24uXG4gKlxuICogQHJldHVybnMge0NhbmNlbFRva2VufVxuICovXG5jbGFzcyBDYW5jZWxUb2tlbiB7XG4gIGNvbnN0cnVjdG9yKGV4ZWN1dG9yKSB7XG4gICAgaWYgKHR5cGVvZiBleGVjdXRvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZXhlY3V0b3IgbXVzdCBiZSBhIGZ1bmN0aW9uLicpO1xuICAgIH1cblxuICAgIGxldCByZXNvbHZlUHJvbWlzZTtcblxuICAgIHRoaXMucHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIHByb21pc2VFeGVjdXRvcihyZXNvbHZlKSB7XG4gICAgICByZXNvbHZlUHJvbWlzZSA9IHJlc29sdmU7XG4gICAgfSk7XG5cbiAgICBjb25zdCB0b2tlbiA9IHRoaXM7XG5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xuICAgIHRoaXMucHJvbWlzZS50aGVuKGNhbmNlbCA9PiB7XG4gICAgICBpZiAoIXRva2VuLl9saXN0ZW5lcnMpIHJldHVybjtcblxuICAgICAgbGV0IGkgPSB0b2tlbi5fbGlzdGVuZXJzLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKGktLSA+IDApIHtcbiAgICAgICAgdG9rZW4uX2xpc3RlbmVyc1tpXShjYW5jZWwpO1xuICAgICAgfVxuICAgICAgdG9rZW4uX2xpc3RlbmVycyA9IG51bGw7XG4gICAgfSk7XG5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xuICAgIHRoaXMucHJvbWlzZS50aGVuID0gb25mdWxmaWxsZWQgPT4ge1xuICAgICAgbGV0IF9yZXNvbHZlO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcbiAgICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgdG9rZW4uc3Vic2NyaWJlKHJlc29sdmUpO1xuICAgICAgICBfcmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICB9KS50aGVuKG9uZnVsZmlsbGVkKTtcblxuICAgICAgcHJvbWlzZS5jYW5jZWwgPSBmdW5jdGlvbiByZWplY3QoKSB7XG4gICAgICAgIHRva2VuLnVuc3Vic2NyaWJlKF9yZXNvbHZlKTtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH07XG5cbiAgICBleGVjdXRvcihmdW5jdGlvbiBjYW5jZWwobWVzc2FnZSwgY29uZmlnLCByZXF1ZXN0KSB7XG4gICAgICBpZiAodG9rZW4ucmVhc29uKSB7XG4gICAgICAgIC8vIENhbmNlbGxhdGlvbiBoYXMgYWxyZWFkeSBiZWVuIHJlcXVlc3RlZFxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRva2VuLnJlYXNvbiA9IG5ldyBDYW5jZWxlZEVycm9yJDEobWVzc2FnZSwgY29uZmlnLCByZXF1ZXN0KTtcbiAgICAgIHJlc29sdmVQcm9taXNlKHRva2VuLnJlYXNvbik7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogVGhyb3dzIGEgYENhbmNlbGVkRXJyb3JgIGlmIGNhbmNlbGxhdGlvbiBoYXMgYmVlbiByZXF1ZXN0ZWQuXG4gICAqL1xuICB0aHJvd0lmUmVxdWVzdGVkKCkge1xuICAgIGlmICh0aGlzLnJlYXNvbikge1xuICAgICAgdGhyb3cgdGhpcy5yZWFzb247XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFN1YnNjcmliZSB0byB0aGUgY2FuY2VsIHNpZ25hbFxuICAgKi9cblxuICBzdWJzY3JpYmUobGlzdGVuZXIpIHtcbiAgICBpZiAodGhpcy5yZWFzb24pIHtcbiAgICAgIGxpc3RlbmVyKHRoaXMucmVhc29uKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fbGlzdGVuZXJzKSB7XG4gICAgICB0aGlzLl9saXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2xpc3RlbmVycyA9IFtsaXN0ZW5lcl07XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFVuc3Vic2NyaWJlIGZyb20gdGhlIGNhbmNlbCBzaWduYWxcbiAgICovXG5cbiAgdW5zdWJzY3JpYmUobGlzdGVuZXIpIHtcbiAgICBpZiAoIXRoaXMuX2xpc3RlbmVycykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpbmRleCA9IHRoaXMuX2xpc3RlbmVycy5pbmRleE9mKGxpc3RlbmVyKTtcbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICB0aGlzLl9saXN0ZW5lcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9XG4gIH1cblxuICB0b0Fib3J0U2lnbmFsKCkge1xuICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG5cbiAgICBjb25zdCBhYm9ydCA9IChlcnIpID0+IHtcbiAgICAgIGNvbnRyb2xsZXIuYWJvcnQoZXJyKTtcbiAgICB9O1xuXG4gICAgdGhpcy5zdWJzY3JpYmUoYWJvcnQpO1xuXG4gICAgY29udHJvbGxlci5zaWduYWwudW5zdWJzY3JpYmUgPSAoKSA9PiB0aGlzLnVuc3Vic2NyaWJlKGFib3J0KTtcblxuICAgIHJldHVybiBjb250cm9sbGVyLnNpZ25hbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIGEgbmV3IGBDYW5jZWxUb2tlbmAgYW5kIGEgZnVuY3Rpb24gdGhhdCwgd2hlbiBjYWxsZWQsXG4gICAqIGNhbmNlbHMgdGhlIGBDYW5jZWxUb2tlbmAuXG4gICAqL1xuICBzdGF0aWMgc291cmNlKCkge1xuICAgIGxldCBjYW5jZWw7XG4gICAgY29uc3QgdG9rZW4gPSBuZXcgQ2FuY2VsVG9rZW4oZnVuY3Rpb24gZXhlY3V0b3IoYykge1xuICAgICAgY2FuY2VsID0gYztcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgdG9rZW4sXG4gICAgICBjYW5jZWxcbiAgICB9O1xuICB9XG59XG5cbmNvbnN0IENhbmNlbFRva2VuJDEgPSBDYW5jZWxUb2tlbjtcblxuLyoqXG4gKiBTeW50YWN0aWMgc3VnYXIgZm9yIGludm9raW5nIGEgZnVuY3Rpb24gYW5kIGV4cGFuZGluZyBhbiBhcnJheSBmb3IgYXJndW1lbnRzLlxuICpcbiAqIENvbW1vbiB1c2UgY2FzZSB3b3VsZCBiZSB0byB1c2UgYEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseWAuXG4gKlxuICogIGBgYGpzXG4gKiAgZnVuY3Rpb24gZih4LCB5LCB6KSB7fVxuICogIGNvbnN0IGFyZ3MgPSBbMSwgMiwgM107XG4gKiAgZi5hcHBseShudWxsLCBhcmdzKTtcbiAqICBgYGBcbiAqXG4gKiBXaXRoIGBzcHJlYWRgIHRoaXMgZXhhbXBsZSBjYW4gYmUgcmUtd3JpdHRlbi5cbiAqXG4gKiAgYGBganNcbiAqICBzcHJlYWQoZnVuY3Rpb24oeCwgeSwgeikge30pKFsxLCAyLCAzXSk7XG4gKiAgYGBgXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gKi9cbmZ1bmN0aW9uIHNwcmVhZChjYWxsYmFjaykge1xuICByZXR1cm4gZnVuY3Rpb24gd3JhcChhcnIpIHtcbiAgICByZXR1cm4gY2FsbGJhY2suYXBwbHkobnVsbCwgYXJyKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHBheWxvYWQgaXMgYW4gZXJyb3IgdGhyb3duIGJ5IEF4aW9zXG4gKlxuICogQHBhcmFtIHsqfSBwYXlsb2FkIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIHBheWxvYWQgaXMgYW4gZXJyb3IgdGhyb3duIGJ5IEF4aW9zLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBeGlvc0Vycm9yKHBheWxvYWQpIHtcbiAgcmV0dXJuIHV0aWxzJDEuaXNPYmplY3QocGF5bG9hZCkgJiYgKHBheWxvYWQuaXNBeGlvc0Vycm9yID09PSB0cnVlKTtcbn1cblxuY29uc3QgSHR0cFN0YXR1c0NvZGUgPSB7XG4gIENvbnRpbnVlOiAxMDAsXG4gIFN3aXRjaGluZ1Byb3RvY29sczogMTAxLFxuICBQcm9jZXNzaW5nOiAxMDIsXG4gIEVhcmx5SGludHM6IDEwMyxcbiAgT2s6IDIwMCxcbiAgQ3JlYXRlZDogMjAxLFxuICBBY2NlcHRlZDogMjAyLFxuICBOb25BdXRob3JpdGF0aXZlSW5mb3JtYXRpb246IDIwMyxcbiAgTm9Db250ZW50OiAyMDQsXG4gIFJlc2V0Q29udGVudDogMjA1LFxuICBQYXJ0aWFsQ29udGVudDogMjA2LFxuICBNdWx0aVN0YXR1czogMjA3LFxuICBBbHJlYWR5UmVwb3J0ZWQ6IDIwOCxcbiAgSW1Vc2VkOiAyMjYsXG4gIE11bHRpcGxlQ2hvaWNlczogMzAwLFxuICBNb3ZlZFBlcm1hbmVudGx5OiAzMDEsXG4gIEZvdW5kOiAzMDIsXG4gIFNlZU90aGVyOiAzMDMsXG4gIE5vdE1vZGlmaWVkOiAzMDQsXG4gIFVzZVByb3h5OiAzMDUsXG4gIFVudXNlZDogMzA2LFxuICBUZW1wb3JhcnlSZWRpcmVjdDogMzA3LFxuICBQZXJtYW5lbnRSZWRpcmVjdDogMzA4LFxuICBCYWRSZXF1ZXN0OiA0MDAsXG4gIFVuYXV0aG9yaXplZDogNDAxLFxuICBQYXltZW50UmVxdWlyZWQ6IDQwMixcbiAgRm9yYmlkZGVuOiA0MDMsXG4gIE5vdEZvdW5kOiA0MDQsXG4gIE1ldGhvZE5vdEFsbG93ZWQ6IDQwNSxcbiAgTm90QWNjZXB0YWJsZTogNDA2LFxuICBQcm94eUF1dGhlbnRpY2F0aW9uUmVxdWlyZWQ6IDQwNyxcbiAgUmVxdWVzdFRpbWVvdXQ6IDQwOCxcbiAgQ29uZmxpY3Q6IDQwOSxcbiAgR29uZTogNDEwLFxuICBMZW5ndGhSZXF1aXJlZDogNDExLFxuICBQcmVjb25kaXRpb25GYWlsZWQ6IDQxMixcbiAgUGF5bG9hZFRvb0xhcmdlOiA0MTMsXG4gIFVyaVRvb0xvbmc6IDQxNCxcbiAgVW5zdXBwb3J0ZWRNZWRpYVR5cGU6IDQxNSxcbiAgUmFuZ2VOb3RTYXRpc2ZpYWJsZTogNDE2LFxuICBFeHBlY3RhdGlvbkZhaWxlZDogNDE3LFxuICBJbUFUZWFwb3Q6IDQxOCxcbiAgTWlzZGlyZWN0ZWRSZXF1ZXN0OiA0MjEsXG4gIFVucHJvY2Vzc2FibGVFbnRpdHk6IDQyMixcbiAgTG9ja2VkOiA0MjMsXG4gIEZhaWxlZERlcGVuZGVuY3k6IDQyNCxcbiAgVG9vRWFybHk6IDQyNSxcbiAgVXBncmFkZVJlcXVpcmVkOiA0MjYsXG4gIFByZWNvbmRpdGlvblJlcXVpcmVkOiA0MjgsXG4gIFRvb01hbnlSZXF1ZXN0czogNDI5LFxuICBSZXF1ZXN0SGVhZGVyRmllbGRzVG9vTGFyZ2U6IDQzMSxcbiAgVW5hdmFpbGFibGVGb3JMZWdhbFJlYXNvbnM6IDQ1MSxcbiAgSW50ZXJuYWxTZXJ2ZXJFcnJvcjogNTAwLFxuICBOb3RJbXBsZW1lbnRlZDogNTAxLFxuICBCYWRHYXRld2F5OiA1MDIsXG4gIFNlcnZpY2VVbmF2YWlsYWJsZTogNTAzLFxuICBHYXRld2F5VGltZW91dDogNTA0LFxuICBIdHRwVmVyc2lvbk5vdFN1cHBvcnRlZDogNTA1LFxuICBWYXJpYW50QWxzb05lZ290aWF0ZXM6IDUwNixcbiAgSW5zdWZmaWNpZW50U3RvcmFnZTogNTA3LFxuICBMb29wRGV0ZWN0ZWQ6IDUwOCxcbiAgTm90RXh0ZW5kZWQ6IDUxMCxcbiAgTmV0d29ya0F1dGhlbnRpY2F0aW9uUmVxdWlyZWQ6IDUxMSxcbiAgV2ViU2VydmVySXNEb3duOiA1MjEsXG4gIENvbm5lY3Rpb25UaW1lZE91dDogNTIyLFxuICBPcmlnaW5Jc1VucmVhY2hhYmxlOiA1MjMsXG4gIFRpbWVvdXRPY2N1cnJlZDogNTI0LFxuICBTc2xIYW5kc2hha2VGYWlsZWQ6IDUyNSxcbiAgSW52YWxpZFNzbENlcnRpZmljYXRlOiA1MjYsXG59O1xuXG5PYmplY3QuZW50cmllcyhIdHRwU3RhdHVzQ29kZSkuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gIEh0dHBTdGF0dXNDb2RlW3ZhbHVlXSA9IGtleTtcbn0pO1xuXG5jb25zdCBIdHRwU3RhdHVzQ29kZSQxID0gSHR0cFN0YXR1c0NvZGU7XG5cbi8qKlxuICogQ3JlYXRlIGFuIGluc3RhbmNlIG9mIEF4aW9zXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGRlZmF1bHRDb25maWcgVGhlIGRlZmF1bHQgY29uZmlnIGZvciB0aGUgaW5zdGFuY2VcbiAqXG4gKiBAcmV0dXJucyB7QXhpb3N9IEEgbmV3IGluc3RhbmNlIG9mIEF4aW9zXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlKGRlZmF1bHRDb25maWcpIHtcbiAgY29uc3QgY29udGV4dCA9IG5ldyBBeGlvcyQxKGRlZmF1bHRDb25maWcpO1xuICBjb25zdCBpbnN0YW5jZSA9IGJpbmQoQXhpb3MkMS5wcm90b3R5cGUucmVxdWVzdCwgY29udGV4dCk7XG5cbiAgLy8gQ29weSBheGlvcy5wcm90b3R5cGUgdG8gaW5zdGFuY2VcbiAgdXRpbHMkMS5leHRlbmQoaW5zdGFuY2UsIEF4aW9zJDEucHJvdG90eXBlLCBjb250ZXh0LCB7YWxsT3duS2V5czogdHJ1ZX0pO1xuXG4gIC8vIENvcHkgY29udGV4dCB0byBpbnN0YW5jZVxuICB1dGlscyQxLmV4dGVuZChpbnN0YW5jZSwgY29udGV4dCwgbnVsbCwge2FsbE93bktleXM6IHRydWV9KTtcblxuICAvLyBGYWN0b3J5IGZvciBjcmVhdGluZyBuZXcgaW5zdGFuY2VzXG4gIGluc3RhbmNlLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShpbnN0YW5jZUNvbmZpZykge1xuICAgIHJldHVybiBjcmVhdGVJbnN0YW5jZShtZXJnZUNvbmZpZyhkZWZhdWx0Q29uZmlnLCBpbnN0YW5jZUNvbmZpZykpO1xuICB9O1xuXG4gIHJldHVybiBpbnN0YW5jZTtcbn1cblxuLy8gQ3JlYXRlIHRoZSBkZWZhdWx0IGluc3RhbmNlIHRvIGJlIGV4cG9ydGVkXG5jb25zdCBheGlvcyA9IGNyZWF0ZUluc3RhbmNlKGRlZmF1bHRzJDEpO1xuXG4vLyBFeHBvc2UgQXhpb3MgY2xhc3MgdG8gYWxsb3cgY2xhc3MgaW5oZXJpdGFuY2VcbmF4aW9zLkF4aW9zID0gQXhpb3MkMTtcblxuLy8gRXhwb3NlIENhbmNlbCAmIENhbmNlbFRva2VuXG5heGlvcy5DYW5jZWxlZEVycm9yID0gQ2FuY2VsZWRFcnJvciQxO1xuYXhpb3MuQ2FuY2VsVG9rZW4gPSBDYW5jZWxUb2tlbiQxO1xuYXhpb3MuaXNDYW5jZWwgPSBpc0NhbmNlbDtcbmF4aW9zLlZFUlNJT04gPSBWRVJTSU9OO1xuYXhpb3MudG9Gb3JtRGF0YSA9IHRvRm9ybURhdGE7XG5cbi8vIEV4cG9zZSBBeGlvc0Vycm9yIGNsYXNzXG5heGlvcy5BeGlvc0Vycm9yID0gQXhpb3NFcnJvciQxO1xuXG4vLyBhbGlhcyBmb3IgQ2FuY2VsZWRFcnJvciBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuYXhpb3MuQ2FuY2VsID0gYXhpb3MuQ2FuY2VsZWRFcnJvcjtcblxuLy8gRXhwb3NlIGFsbC9zcHJlYWRcbmF4aW9zLmFsbCA9IGZ1bmN0aW9uIGFsbChwcm9taXNlcykge1xuICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xufTtcblxuYXhpb3Muc3ByZWFkID0gc3ByZWFkO1xuXG4vLyBFeHBvc2UgaXNBeGlvc0Vycm9yXG5heGlvcy5pc0F4aW9zRXJyb3IgPSBpc0F4aW9zRXJyb3I7XG5cbi8vIEV4cG9zZSBtZXJnZUNvbmZpZ1xuYXhpb3MubWVyZ2VDb25maWcgPSBtZXJnZUNvbmZpZztcblxuYXhpb3MuQXhpb3NIZWFkZXJzID0gQXhpb3NIZWFkZXJzJDE7XG5cbmF4aW9zLmZvcm1Ub0pTT04gPSB0aGluZyA9PiBmb3JtRGF0YVRvSlNPTih1dGlscyQxLmlzSFRNTEZvcm0odGhpbmcpID8gbmV3IEZvcm1EYXRhKHRoaW5nKSA6IHRoaW5nKTtcblxuYXhpb3MuZ2V0QWRhcHRlciA9IGFkYXB0ZXJzLmdldEFkYXB0ZXI7XG5cbmF4aW9zLkh0dHBTdGF0dXNDb2RlID0gSHR0cFN0YXR1c0NvZGUkMTtcblxuYXhpb3MuZGVmYXVsdCA9IGF4aW9zO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGF4aW9zO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXhpb3MuY2pzLm1hcFxuIl0sIm5hbWVzIjpbIkZvcm1EYXRhJDEiLCJyZXF1aXJlIiwiY3J5cHRvIiwidXJsIiwicHJveHlGcm9tRW52IiwiaHR0cCIsImh0dHBzIiwiaHR0cDIiLCJ1dGlsIiwiZm9sbG93UmVkaXJlY3RzIiwiemxpYiIsInN0cmVhbSIsImV2ZW50cyIsIl9pbnRlcm9wRGVmYXVsdExlZ2FjeSIsImUiLCJGb3JtRGF0YV9fZGVmYXVsdCIsImNyeXB0b19fZGVmYXVsdCIsInVybF9fZGVmYXVsdCIsInByb3h5RnJvbUVudl9fZGVmYXVsdCIsImh0dHBfX2RlZmF1bHQiLCJodHRwc19fZGVmYXVsdCIsImh0dHAyX19kZWZhdWx0IiwidXRpbF9fZGVmYXVsdCIsImZvbGxvd1JlZGlyZWN0c19fZGVmYXVsdCIsInpsaWJfX2RlZmF1bHQiLCJzdHJlYW1fX2RlZmF1bHQiLCJiaW5kIiwiZm4iLCJ0aGlzQXJnIiwid3JhcCIsImFwcGx5IiwiYXJndW1lbnRzIiwidG9TdHJpbmciLCJPYmplY3QiLCJwcm90b3R5cGUiLCJnZXRQcm90b3R5cGVPZiIsIml0ZXJhdG9yIiwidG9TdHJpbmdUYWciLCJTeW1ib2wiLCJraW5kT2YiLCJjYWNoZSIsInRoaW5nIiwic3RyIiwiY2FsbCIsInNsaWNlIiwidG9Mb3dlckNhc2UiLCJjcmVhdGUiLCJraW5kT2ZUZXN0IiwidHlwZSIsInR5cGVPZlRlc3QiLCJpc0FycmF5IiwiQXJyYXkiLCJpc1VuZGVmaW5lZCIsImlzQnVmZmVyIiwidmFsIiwiY29uc3RydWN0b3IiLCJpc0Z1bmN0aW9uJDEiLCJpc0FycmF5QnVmZmVyIiwiaXNBcnJheUJ1ZmZlclZpZXciLCJyZXN1bHQiLCJBcnJheUJ1ZmZlciIsImlzVmlldyIsImJ1ZmZlciIsImlzU3RyaW5nIiwiaXNOdW1iZXIiLCJpc09iamVjdCIsImlzQm9vbGVhbiIsImlzUGxhaW5PYmplY3QiLCJpc0VtcHR5T2JqZWN0Iiwia2V5cyIsImxlbmd0aCIsImlzRGF0ZSIsImlzRmlsZSIsImlzQmxvYiIsImlzRmlsZUxpc3QiLCJpc1N0cmVhbSIsInBpcGUiLCJpc0Zvcm1EYXRhIiwia2luZCIsIkZvcm1EYXRhIiwiYXBwZW5kIiwiaXNVUkxTZWFyY2hQYXJhbXMiLCJpc1JlYWRhYmxlU3RyZWFtIiwiaXNSZXF1ZXN0IiwiaXNSZXNwb25zZSIsImlzSGVhZGVycyIsIm1hcCIsInRyaW0iLCJyZXBsYWNlIiwiZm9yRWFjaCIsIm9iaiIsImFsbE93bktleXMiLCJpIiwibCIsImdldE93blByb3BlcnR5TmFtZXMiLCJsZW4iLCJrZXkiLCJmaW5kS2V5IiwiX2tleSIsIl9nbG9iYWwiLCJnbG9iYWxUaGlzIiwic2VsZiIsIndpbmRvdyIsImdsb2JhbCIsImlzQ29udGV4dERlZmluZWQiLCJjb250ZXh0IiwibWVyZ2UiLCJjYXNlbGVzcyIsInNraXBVbmRlZmluZWQiLCJhc3NpZ25WYWx1ZSIsInRhcmdldEtleSIsImV4dGVuZCIsImEiLCJiIiwiZGVmaW5lUHJvcGVydHkiLCJ2YWx1ZSIsIndyaXRhYmxlIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsInN0cmlwQk9NIiwiY29udGVudCIsImNoYXJDb2RlQXQiLCJpbmhlcml0cyIsInN1cGVyQ29uc3RydWN0b3IiLCJwcm9wcyIsImRlc2NyaXB0b3JzIiwiYXNzaWduIiwidG9GbGF0T2JqZWN0Iiwic291cmNlT2JqIiwiZGVzdE9iaiIsImZpbHRlciIsInByb3BGaWx0ZXIiLCJwcm9wIiwibWVyZ2VkIiwiZW5kc1dpdGgiLCJzZWFyY2hTdHJpbmciLCJwb3NpdGlvbiIsIlN0cmluZyIsInVuZGVmaW5lZCIsImxhc3RJbmRleCIsImluZGV4T2YiLCJ0b0FycmF5IiwiYXJyIiwiaXNUeXBlZEFycmF5IiwiVHlwZWRBcnJheSIsIlVpbnQ4QXJyYXkiLCJmb3JFYWNoRW50cnkiLCJnZW5lcmF0b3IiLCJfaXRlcmF0b3IiLCJuZXh0IiwiZG9uZSIsInBhaXIiLCJtYXRjaEFsbCIsInJlZ0V4cCIsIm1hdGNoZXMiLCJleGVjIiwicHVzaCIsImlzSFRNTEZvcm0iLCJ0b0NhbWVsQ2FzZSIsInJlcGxhY2VyIiwibSIsInAxIiwicDIiLCJ0b1VwcGVyQ2FzZSIsImhhc093blByb3BlcnR5IiwiaXNSZWdFeHAiLCJyZWR1Y2VEZXNjcmlwdG9ycyIsInJlZHVjZXIiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzIiwicmVkdWNlZERlc2NyaXB0b3JzIiwiZGVzY3JpcHRvciIsIm5hbWUiLCJyZXQiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiZnJlZXplTWV0aG9kcyIsInNldCIsIkVycm9yIiwidG9PYmplY3RTZXQiLCJhcnJheU9yU3RyaW5nIiwiZGVsaW1pdGVyIiwiZGVmaW5lIiwic3BsaXQiLCJub29wIiwidG9GaW5pdGVOdW1iZXIiLCJkZWZhdWx0VmFsdWUiLCJOdW1iZXIiLCJpc0Zpbml0ZSIsImlzU3BlY0NvbXBsaWFudEZvcm0iLCJ0b0pTT05PYmplY3QiLCJzdGFjayIsInZpc2l0Iiwic291cmNlIiwidGFyZ2V0IiwicmVkdWNlZFZhbHVlIiwiaXNBc3luY0ZuIiwiaXNUaGVuYWJsZSIsInRoZW4iLCJjYXRjaCIsIl9zZXRJbW1lZGlhdGUiLCJzZXRJbW1lZGlhdGVTdXBwb3J0ZWQiLCJwb3N0TWVzc2FnZVN1cHBvcnRlZCIsInNldEltbWVkaWF0ZSIsInRva2VuIiwiY2FsbGJhY2tzIiwiYWRkRXZlbnRMaXN0ZW5lciIsImRhdGEiLCJzaGlmdCIsImNiIiwicG9zdE1lc3NhZ2UiLCJNYXRoIiwicmFuZG9tIiwic2V0VGltZW91dCIsImFzYXAiLCJxdWV1ZU1pY3JvdGFzayIsInByb2Nlc3MiLCJuZXh0VGljayIsImlzSXRlcmFibGUiLCJ1dGlscyQxIiwiaXNGdW5jdGlvbiIsImhhc093blByb3AiLCJBeGlvc0Vycm9yIiwiZnJvbSIsImVycm9yIiwiY29kZSIsImNvbmZpZyIsInJlcXVlc3QiLCJyZXNwb25zZSIsImN1c3RvbVByb3BzIiwiYXhpb3NFcnJvciIsIm1lc3NhZ2UiLCJjYXVzZSIsImlzQXhpb3NFcnJvciIsInN0YXR1cyIsInRvSlNPTiIsImRlc2NyaXB0aW9uIiwibnVtYmVyIiwiZmlsZU5hbWUiLCJsaW5lTnVtYmVyIiwiY29sdW1uTnVtYmVyIiwiRVJSX0JBRF9PUFRJT05fVkFMVUUiLCJFUlJfQkFEX09QVElPTiIsIkVDT05OQUJPUlRFRCIsIkVUSU1FRE9VVCIsIkVSUl9ORVRXT1JLIiwiRVJSX0ZSX1RPT19NQU5ZX1JFRElSRUNUUyIsIkVSUl9ERVBSRUNBVEVEIiwiRVJSX0JBRF9SRVNQT05TRSIsIkVSUl9CQURfUkVRVUVTVCIsIkVSUl9DQU5DRUxFRCIsIkVSUl9OT1RfU1VQUE9SVCIsIkVSUl9JTlZBTElEX1VSTCIsIkF4aW9zRXJyb3IkMSIsImlzVmlzaXRhYmxlIiwicmVtb3ZlQnJhY2tldHMiLCJyZW5kZXJLZXkiLCJwYXRoIiwiZG90cyIsImNvbmNhdCIsImVhY2giLCJqb2luIiwiaXNGbGF0QXJyYXkiLCJzb21lIiwicHJlZGljYXRlcyIsInRlc3QiLCJ0b0Zvcm1EYXRhIiwiZm9ybURhdGEiLCJvcHRpb25zIiwiVHlwZUVycm9yIiwibWV0YVRva2VucyIsImluZGV4ZXMiLCJkZWZpbmVkIiwib3B0aW9uIiwidmlzaXRvciIsImRlZmF1bHRWaXNpdG9yIiwiX0Jsb2IiLCJCbG9iIiwidXNlQmxvYiIsImNvbnZlcnRWYWx1ZSIsInRvSVNPU3RyaW5nIiwiQnVmZmVyIiwiSlNPTiIsInN0cmluZ2lmeSIsImVsIiwiaW5kZXgiLCJleHBvc2VkSGVscGVycyIsImJ1aWxkIiwicG9wIiwiZW5jb2RlJDEiLCJjaGFyTWFwIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwibWF0Y2giLCJBeGlvc1VSTFNlYXJjaFBhcmFtcyIsInBhcmFtcyIsIl9wYWlycyIsImVuY29kZXIiLCJfZW5jb2RlIiwiZW5jb2RlIiwiYnVpbGRVUkwiLCJfb3B0aW9ucyIsInNlcmlhbGl6ZSIsInNlcmlhbGl6ZUZuIiwic2VyaWFsaXplZFBhcmFtcyIsImhhc2htYXJrSW5kZXgiLCJJbnRlcmNlcHRvck1hbmFnZXIiLCJoYW5kbGVycyIsInVzZSIsImZ1bGZpbGxlZCIsInJlamVjdGVkIiwic3luY2hyb25vdXMiLCJydW5XaGVuIiwiZWplY3QiLCJpZCIsImNsZWFyIiwiZm9yRWFjaEhhbmRsZXIiLCJoIiwiSW50ZXJjZXB0b3JNYW5hZ2VyJDEiLCJ0cmFuc2l0aW9uYWxEZWZhdWx0cyIsInNpbGVudEpTT05QYXJzaW5nIiwiZm9yY2VkSlNPTlBhcnNpbmciLCJjbGFyaWZ5VGltZW91dEVycm9yIiwiVVJMU2VhcmNoUGFyYW1zIiwiQUxQSEEiLCJESUdJVCIsIkFMUEhBQkVUIiwiQUxQSEFfRElHSVQiLCJnZW5lcmF0ZVN0cmluZyIsInNpemUiLCJhbHBoYWJldCIsInJhbmRvbVZhbHVlcyIsIlVpbnQzMkFycmF5IiwicmFuZG9tRmlsbFN5bmMiLCJwbGF0Zm9ybSQxIiwiaXNOb2RlIiwiY2xhc3NlcyIsInByb3RvY29scyIsImhhc0Jyb3dzZXJFbnYiLCJkb2N1bWVudCIsIl9uYXZpZ2F0b3IiLCJuYXZpZ2F0b3IiLCJoYXNTdGFuZGFyZEJyb3dzZXJFbnYiLCJwcm9kdWN0IiwiaGFzU3RhbmRhcmRCcm93c2VyV2ViV29ya2VyRW52IiwiV29ya2VyR2xvYmFsU2NvcGUiLCJpbXBvcnRTY3JpcHRzIiwib3JpZ2luIiwibG9jYXRpb24iLCJocmVmIiwidXRpbHMiLCJmcmVlemUiLCJfX3Byb3RvX18iLCJwbGF0Zm9ybSIsInRvVVJMRW5jb2RlZEZvcm0iLCJoZWxwZXJzIiwicGFyc2VQcm9wUGF0aCIsImFycmF5VG9PYmplY3QiLCJmb3JtRGF0YVRvSlNPTiIsImJ1aWxkUGF0aCIsImlzTnVtZXJpY0tleSIsImlzTGFzdCIsImVudHJpZXMiLCJzdHJpbmdpZnlTYWZlbHkiLCJyYXdWYWx1ZSIsInBhcnNlciIsInBhcnNlIiwiZGVmYXVsdHMiLCJ0cmFuc2l0aW9uYWwiLCJhZGFwdGVyIiwidHJhbnNmb3JtUmVxdWVzdCIsImhlYWRlcnMiLCJjb250ZW50VHlwZSIsImdldENvbnRlbnRUeXBlIiwiaGFzSlNPTkNvbnRlbnRUeXBlIiwiaXNPYmplY3RQYXlsb2FkIiwic2V0Q29udGVudFR5cGUiLCJmb3JtU2VyaWFsaXplciIsIl9Gb3JtRGF0YSIsImVudiIsInRyYW5zZm9ybVJlc3BvbnNlIiwiSlNPTlJlcXVlc3RlZCIsInJlc3BvbnNlVHlwZSIsInN0cmljdEpTT05QYXJzaW5nIiwicGFyc2VSZXZpdmVyIiwidGltZW91dCIsInhzcmZDb29raWVOYW1lIiwieHNyZkhlYWRlck5hbWUiLCJtYXhDb250ZW50TGVuZ3RoIiwibWF4Qm9keUxlbmd0aCIsInZhbGlkYXRlU3RhdHVzIiwiY29tbW9uIiwibWV0aG9kIiwiZGVmYXVsdHMkMSIsImlnbm9yZUR1cGxpY2F0ZU9mIiwicGFyc2VIZWFkZXJzIiwicmF3SGVhZGVycyIsInBhcnNlZCIsImxpbmUiLCJzdWJzdHJpbmciLCIkaW50ZXJuYWxzIiwibm9ybWFsaXplSGVhZGVyIiwiaGVhZGVyIiwibm9ybWFsaXplVmFsdWUiLCJwYXJzZVRva2VucyIsInRva2VucyIsInRva2Vuc1JFIiwiaXNWYWxpZEhlYWRlck5hbWUiLCJtYXRjaEhlYWRlclZhbHVlIiwiaXNIZWFkZXJOYW1lRmlsdGVyIiwiZm9ybWF0SGVhZGVyIiwidyIsImNoYXIiLCJidWlsZEFjY2Vzc29ycyIsImFjY2Vzc29yTmFtZSIsIm1ldGhvZE5hbWUiLCJhcmcxIiwiYXJnMiIsImFyZzMiLCJBeGlvc0hlYWRlcnMiLCJ2YWx1ZU9yUmV3cml0ZSIsInJld3JpdGUiLCJzZXRIZWFkZXIiLCJfdmFsdWUiLCJfaGVhZGVyIiwiX3Jld3JpdGUiLCJsSGVhZGVyIiwic2V0SGVhZGVycyIsImRlc3QiLCJlbnRyeSIsImdldCIsImhhcyIsIm1hdGNoZXIiLCJkZWxldGUiLCJkZWxldGVkIiwiZGVsZXRlSGVhZGVyIiwibm9ybWFsaXplIiwiZm9ybWF0Iiwibm9ybWFsaXplZCIsInRhcmdldHMiLCJhc1N0cmluZ3MiLCJnZXRTZXRDb29raWUiLCJmaXJzdCIsImNvbXB1dGVkIiwiYWNjZXNzb3IiLCJpbnRlcm5hbHMiLCJhY2Nlc3NvcnMiLCJkZWZpbmVBY2Nlc3NvciIsIm1hcHBlZCIsImhlYWRlclZhbHVlIiwiQXhpb3NIZWFkZXJzJDEiLCJ0cmFuc2Zvcm1EYXRhIiwiZm5zIiwidHJhbnNmb3JtIiwiaXNDYW5jZWwiLCJfX0NBTkNFTF9fIiwiQ2FuY2VsZWRFcnJvciIsIkNhbmNlbGVkRXJyb3IkMSIsInNldHRsZSIsInJlc29sdmUiLCJyZWplY3QiLCJmbG9vciIsImlzQWJzb2x1dGVVUkwiLCJjb21iaW5lVVJMcyIsImJhc2VVUkwiLCJyZWxhdGl2ZVVSTCIsImJ1aWxkRnVsbFBhdGgiLCJyZXF1ZXN0ZWRVUkwiLCJhbGxvd0Fic29sdXRlVXJscyIsImlzUmVsYXRpdmVVcmwiLCJWRVJTSU9OIiwicGFyc2VQcm90b2NvbCIsIkRBVEFfVVJMX1BBVFRFUk4iLCJmcm9tRGF0YVVSSSIsInVyaSIsImFzQmxvYiIsInByb3RvY29sIiwibWltZSIsImlzQmFzZTY0IiwiYm9keSIsImRlY29kZVVSSUNvbXBvbmVudCIsImtJbnRlcm5hbHMiLCJBeGlvc1RyYW5zZm9ybVN0cmVhbSIsIlRyYW5zZm9ybSIsIm1heFJhdGUiLCJjaHVua1NpemUiLCJtaW5DaHVua1NpemUiLCJ0aW1lV2luZG93IiwidGlja3NSYXRlIiwic2FtcGxlc0NvdW50IiwicmVhZGFibGVIaWdoV2F0ZXJNYXJrIiwiYnl0ZXNTZWVuIiwiaXNDYXB0dXJlZCIsIm5vdGlmaWVkQnl0ZXNMb2FkZWQiLCJ0cyIsIkRhdGUiLCJub3ciLCJieXRlcyIsIm9uUmVhZENhbGxiYWNrIiwib24iLCJldmVudCIsIl9yZWFkIiwiX3RyYW5zZm9ybSIsImNodW5rIiwiZW5jb2RpbmciLCJjYWxsYmFjayIsImRpdmlkZXIiLCJieXRlc1RocmVzaG9sZCIsIm1heCIsInB1c2hDaHVuayIsIl9jaHVuayIsIl9jYWxsYmFjayIsImJ5dGVMZW5ndGgiLCJlbWl0IiwidHJhbnNmb3JtQ2h1bmsiLCJjaHVua1JlbWFpbmRlciIsIm1heENodW5rU2l6ZSIsImJ5dGVzTGVmdCIsInBhc3NlZCIsInN1YmFycmF5IiwidHJhbnNmb3JtTmV4dENodW5rIiwiZXJyIiwiQXhpb3NUcmFuc2Zvcm1TdHJlYW0kMSIsImFzeW5jSXRlcmF0b3IiLCJyZWFkQmxvYiIsImJsb2IiLCJhcnJheUJ1ZmZlciIsInJlYWRCbG9iJDEiLCJCT1VOREFSWV9BTFBIQUJFVCIsInRleHRFbmNvZGVyIiwiVGV4dEVuY29kZXIiLCJDUkxGIiwiQ1JMRl9CWVRFUyIsIkNSTEZfQllURVNfQ09VTlQiLCJGb3JtRGF0YVBhcnQiLCJlc2NhcGVOYW1lIiwiaXNTdHJpbmdWYWx1ZSIsImNvbnRlbnRMZW5ndGgiLCJmb3JtRGF0YVRvU3RyZWFtIiwiZm9ybSIsImhlYWRlcnNIYW5kbGVyIiwidGFnIiwiYm91bmRhcnkiLCJib3VuZGFyeUJ5dGVzIiwiZm9vdGVyQnl0ZXMiLCJwYXJ0cyIsInBhcnQiLCJjb21wdXRlZEhlYWRlcnMiLCJSZWFkYWJsZSIsImZvcm1EYXRhVG9TdHJlYW0kMSIsIlpsaWJIZWFkZXJUcmFuc2Zvcm1TdHJlYW0iLCJfX3RyYW5zZm9ybSIsImFsbG9jIiwiWmxpYkhlYWRlclRyYW5zZm9ybVN0cmVhbSQxIiwiY2FsbGJhY2tpZnkiLCJhcmdzIiwiY2FsbGJhY2tpZnkkMSIsInNwZWVkb21ldGVyIiwibWluIiwidGltZXN0YW1wcyIsImhlYWQiLCJ0YWlsIiwiZmlyc3RTYW1wbGVUUyIsImNodW5rTGVuZ3RoIiwic3RhcnRlZEF0IiwiYnl0ZXNDb3VudCIsInJvdW5kIiwidGhyb3R0bGUiLCJmcmVxIiwidGltZXN0YW1wIiwidGhyZXNob2xkIiwibGFzdEFyZ3MiLCJ0aW1lciIsImludm9rZSIsImNsZWFyVGltZW91dCIsInRocm90dGxlZCIsImZsdXNoIiwicHJvZ3Jlc3NFdmVudFJlZHVjZXIiLCJsaXN0ZW5lciIsImlzRG93bmxvYWRTdHJlYW0iLCJieXRlc05vdGlmaWVkIiwiX3NwZWVkb21ldGVyIiwibG9hZGVkIiwidG90YWwiLCJsZW5ndGhDb21wdXRhYmxlIiwicHJvZ3Jlc3NCeXRlcyIsInJhdGUiLCJpblJhbmdlIiwicHJvZ3Jlc3MiLCJlc3RpbWF0ZWQiLCJwcm9ncmVzc0V2ZW50RGVjb3JhdG9yIiwiYXN5bmNEZWNvcmF0b3IiLCJlc3RpbWF0ZURhdGFVUkxEZWNvZGVkQnl0ZXMiLCJzdGFydHNXaXRoIiwiY29tbWEiLCJtZXRhIiwiZWZmZWN0aXZlTGVuIiwiaXNIZXgiLCJwYWQiLCJpZHgiLCJ0YWlsSXNQY3QzRCIsImoiLCJncm91cHMiLCJ6bGliT3B0aW9ucyIsImNvbnN0YW50cyIsIlpfU1lOQ19GTFVTSCIsImZpbmlzaEZsdXNoIiwiYnJvdGxpT3B0aW9ucyIsIkJST1RMSV9PUEVSQVRJT05fRkxVU0giLCJpc0Jyb3RsaVN1cHBvcnRlZCIsImNyZWF0ZUJyb3RsaURlY29tcHJlc3MiLCJodHRwRm9sbG93IiwiaHR0cHNGb2xsb3ciLCJpc0h0dHBzIiwic3VwcG9ydGVkUHJvdG9jb2xzIiwiZmx1c2hPbkZpbmlzaCIsIkh0dHAyU2Vzc2lvbnMiLCJzZXNzaW9ucyIsImdldFNlc3Npb24iLCJhdXRob3JpdHkiLCJzZXNzaW9uVGltZW91dCIsImF1dGhvcml0eVNlc3Npb25zIiwic2Vzc2lvbkhhbmRsZSIsInNlc3Npb25PcHRpb25zIiwiZGVzdHJveWVkIiwiY2xvc2VkIiwiaXNEZWVwU3RyaWN0RXF1YWwiLCJzZXNzaW9uIiwiY29ubmVjdCIsInJlbW92ZWQiLCJyZW1vdmVTZXNzaW9uIiwic3BsaWNlIiwib3JpZ2luYWxSZXF1ZXN0Rm4iLCJzdHJlYW1zQ291bnQiLCJvbmNlIiwiaHR0cDJTZXNzaW9ucyIsImRpc3BhdGNoQmVmb3JlUmVkaXJlY3QiLCJyZXNwb25zZURldGFpbHMiLCJiZWZvcmVSZWRpcmVjdHMiLCJwcm94eSIsInNldFByb3h5IiwiY29uZmlnUHJveHkiLCJwcm94eVVybCIsImdldFByb3h5Rm9yVXJsIiwiVVJMIiwidXNlcm5hbWUiLCJhdXRoIiwicGFzc3dvcmQiLCJ2YWxpZFByb3h5QXV0aCIsIkJvb2xlYW4iLCJiYXNlNjQiLCJob3N0IiwiaG9zdG5hbWUiLCJwb3J0IiwicHJveHlIb3N0IiwiaW5jbHVkZXMiLCJiZWZvcmVSZWRpcmVjdCIsInJlZGlyZWN0T3B0aW9ucyIsImlzSHR0cEFkYXB0ZXJTdXBwb3J0ZWQiLCJ3cmFwQXN5bmMiLCJhc3luY0V4ZWN1dG9yIiwiUHJvbWlzZSIsIm9uRG9uZSIsImlzRG9uZSIsImlzUmVqZWN0ZWQiLCJfcmVzb2x2ZSIsIl9yZWplY3QiLCJyZWFzb24iLCJvbkRvbmVIYW5kbGVyIiwicmVzb2x2ZUZhbWlseSIsImFkZHJlc3MiLCJmYW1pbHkiLCJidWlsZEFkZHJlc3NFbnRyeSIsImh0dHAyVHJhbnNwb3J0IiwiaHR0cDJPcHRpb25zIiwiSFRUUDJfSEVBREVSX1NDSEVNRSIsIkhUVFAyX0hFQURFUl9NRVRIT0QiLCJIVFRQMl9IRUFERVJfUEFUSCIsIkhUVFAyX0hFQURFUl9TVEFUVVMiLCJodHRwMkhlYWRlcnMiLCJjaGFyQXQiLCJyZXEiLCJyZXNwb25zZUhlYWRlcnMiLCJzdGF0dXNDb2RlIiwiaHR0cEFkYXB0ZXIiLCJkaXNwYXRjaEh0dHBSZXF1ZXN0IiwibG9va3VwIiwiaHR0cFZlcnNpb24iLCJyZXNwb25zZUVuY29kaW5nIiwiaXNOYU4iLCJpc0h0dHAyIiwiX2xvb2t1cCIsIm9wdCIsImFyZzAiLCJhZGRyZXNzZXMiLCJhZGRyIiwiYWxsIiwiYWJvcnRFbWl0dGVyIiwiRXZlbnRFbWl0dGVyIiwiYWJvcnQiLCJjb25zb2xlIiwid2FybiIsIm9uRmluaXNoZWQiLCJjYW5jZWxUb2tlbiIsInVuc3Vic2NyaWJlIiwic2lnbmFsIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInJlbW92ZUFsbExpc3RlbmVycyIsInN1YnNjcmliZSIsImFib3J0ZWQiLCJEdXBsZXgiLCJvZmZMaXN0ZW5lcnMiLCJmaW5pc2hlZCIsImZ1bGxQYXRoIiwiZGF0YVVybCIsImNvbnZlcnRlZERhdGEiLCJzdGF0dXNUZXh0Iiwib25VcGxvYWRQcm9ncmVzcyIsIm9uRG93bmxvYWRQcm9ncmVzcyIsIm1heFVwbG9hZFJhdGUiLCJtYXhEb3dubG9hZFJhdGUiLCJ1c2VyQm91bmRhcnkiLCJmb3JtSGVhZGVycyIsImdldEhlYWRlcnMiLCJoYXNDb250ZW50TGVuZ3RoIiwia25vd25MZW5ndGgiLCJwcm9taXNpZnkiLCJnZXRMZW5ndGgiLCJzZXRDb250ZW50TGVuZ3RoIiwiZ2V0Q29udGVudExlbmd0aCIsIm9iamVjdE1vZGUiLCJwaXBlbGluZSIsInVybFVzZXJuYW1lIiwidXJsUGFzc3dvcmQiLCJwYXRobmFtZSIsInNlYXJjaCIsInBhcmFtc1NlcmlhbGl6ZXIiLCJjdXN0b21FcnIiLCJleGlzdHMiLCJhZ2VudHMiLCJodHRwQWdlbnQiLCJodHRwc0FnZW50Iiwic29ja2V0UGF0aCIsInRyYW5zcG9ydCIsImlzSHR0cHNSZXF1ZXN0IiwiYWdlbnQiLCJtYXhSZWRpcmVjdHMiLCJJbmZpbml0eSIsImluc2VjdXJlSFRUUFBhcnNlciIsImhhbmRsZVJlc3BvbnNlIiwicmVzIiwic3RyZWFtcyIsInJlc3BvbnNlTGVuZ3RoIiwidHJhbnNmb3JtU3RyZWFtIiwicmVzcG9uc2VTdHJlYW0iLCJsYXN0UmVxdWVzdCIsImRlY29tcHJlc3MiLCJjcmVhdGVVbnppcCIsInN0YXR1c01lc3NhZ2UiLCJyZXNwb25zZUJ1ZmZlciIsInRvdGFsUmVzcG9uc2VCeXRlcyIsImhhbmRsZVN0cmVhbURhdGEiLCJkZXN0cm95IiwiaGFuZGxlclN0cmVhbUFib3J0ZWQiLCJoYW5kbGVTdHJlYW1FcnJvciIsImhhbmRsZVN0cmVhbUVuZCIsInJlc3BvbnNlRGF0YSIsImNsb3NlIiwiaGFuZGxlUmVxdWVzdEVycm9yIiwiaGFuZGxlUmVxdWVzdFNvY2tldCIsInNvY2tldCIsInNldEtlZXBBbGl2ZSIsInBhcnNlSW50IiwiaGFuZGxlUmVxdWVzdFRpbWVvdXQiLCJ0aW1lb3V0RXJyb3JNZXNzYWdlIiwiZW5kZWQiLCJlcnJvcmVkIiwid3JpdGUiLCJlbmQiLCJpc1VSTFNhbWVPcmlnaW4iLCJpc01TSUUiLCJ1c2VyQWdlbnQiLCJjb29raWVzIiwiZXhwaXJlcyIsImRvbWFpbiIsInNlY3VyZSIsInNhbWVTaXRlIiwiY29va2llIiwidG9VVENTdHJpbmciLCJyZWFkIiwiUmVnRXhwIiwicmVtb3ZlIiwiaGVhZGVyc1RvT2JqZWN0IiwibWVyZ2VDb25maWciLCJjb25maWcxIiwiY29uZmlnMiIsImdldE1lcmdlZFZhbHVlIiwibWVyZ2VEZWVwUHJvcGVydGllcyIsInZhbHVlRnJvbUNvbmZpZzIiLCJkZWZhdWx0VG9Db25maWcyIiwibWVyZ2VEaXJlY3RLZXlzIiwibWVyZ2VNYXAiLCJ0aW1lb3V0TWVzc2FnZSIsIndpdGhDcmVkZW50aWFscyIsIndpdGhYU1JGVG9rZW4iLCJjb21wdXRlQ29uZmlnVmFsdWUiLCJjb25maWdWYWx1ZSIsInJlc29sdmVDb25maWciLCJuZXdDb25maWciLCJidG9hIiwidW5lc2NhcGUiLCJhbGxvd2VkSGVhZGVycyIsInhzcmZWYWx1ZSIsImlzWEhSQWRhcHRlclN1cHBvcnRlZCIsIlhNTEh0dHBSZXF1ZXN0IiwieGhyQWRhcHRlciIsImRpc3BhdGNoWGhyUmVxdWVzdCIsIl9jb25maWciLCJyZXF1ZXN0RGF0YSIsInJlcXVlc3RIZWFkZXJzIiwib25DYW5jZWxlZCIsInVwbG9hZFRocm90dGxlZCIsImRvd25sb2FkVGhyb3R0bGVkIiwiZmx1c2hVcGxvYWQiLCJmbHVzaERvd25sb2FkIiwib3BlbiIsIm9ubG9hZGVuZCIsImdldEFsbFJlc3BvbnNlSGVhZGVycyIsInJlc3BvbnNlVGV4dCIsIm9ucmVhZHlzdGF0ZWNoYW5nZSIsImhhbmRsZUxvYWQiLCJyZWFkeVN0YXRlIiwicmVzcG9uc2VVUkwiLCJvbmFib3J0IiwiaGFuZGxlQWJvcnQiLCJvbmVycm9yIiwiaGFuZGxlRXJyb3IiLCJtc2ciLCJvbnRpbWVvdXQiLCJoYW5kbGVUaW1lb3V0Iiwic2V0UmVxdWVzdEhlYWRlciIsInVwbG9hZCIsImNhbmNlbCIsInNlbmQiLCJjb21wb3NlU2lnbmFscyIsInNpZ25hbHMiLCJjb250cm9sbGVyIiwiQWJvcnRDb250cm9sbGVyIiwiY29tcG9zZVNpZ25hbHMkMSIsInN0cmVhbUNodW5rIiwicG9zIiwicmVhZEJ5dGVzIiwiaXRlcmFibGUiLCJyZWFkU3RyZWFtIiwicmVhZGVyIiwiZ2V0UmVhZGVyIiwidHJhY2tTdHJlYW0iLCJvblByb2dyZXNzIiwib25GaW5pc2giLCJfb25GaW5pc2giLCJSZWFkYWJsZVN0cmVhbSIsInB1bGwiLCJsb2FkZWRCeXRlcyIsImVucXVldWUiLCJyZXR1cm4iLCJoaWdoV2F0ZXJNYXJrIiwiREVGQVVMVF9DSFVOS19TSVpFIiwiZ2xvYmFsRmV0Y2hBUEkiLCJSZXF1ZXN0IiwiUmVzcG9uc2UiLCJSZWFkYWJsZVN0cmVhbSQxIiwiVGV4dEVuY29kZXIkMSIsImZhY3RvcnkiLCJmZXRjaCIsImVudkZldGNoIiwiaXNGZXRjaFN1cHBvcnRlZCIsImlzUmVxdWVzdFN1cHBvcnRlZCIsImlzUmVzcG9uc2VTdXBwb3J0ZWQiLCJpc1JlYWRhYmxlU3RyZWFtU3VwcG9ydGVkIiwiZW5jb2RlVGV4dCIsInN1cHBvcnRzUmVxdWVzdFN0cmVhbSIsImR1cGxleEFjY2Vzc2VkIiwiaGFzQ29udGVudFR5cGUiLCJkdXBsZXgiLCJzdXBwb3J0c1Jlc3BvbnNlU3RyZWFtIiwicmVzb2x2ZXJzIiwiZ2V0Qm9keUxlbmd0aCIsIl9yZXF1ZXN0IiwicmVzb2x2ZUJvZHlMZW5ndGgiLCJmZXRjaE9wdGlvbnMiLCJfZmV0Y2giLCJjb21wb3NlZFNpZ25hbCIsInRvQWJvcnRTaWduYWwiLCJyZXF1ZXN0Q29udGVudExlbmd0aCIsImNvbnRlbnRUeXBlSGVhZGVyIiwiaXNDcmVkZW50aWFsc1N1cHBvcnRlZCIsInJlc29sdmVkT3B0aW9ucyIsImNyZWRlbnRpYWxzIiwiaXNTdHJlYW1SZXNwb25zZSIsInJlc3BvbnNlQ29udGVudExlbmd0aCIsInNlZWRDYWNoZSIsIk1hcCIsImdldEZldGNoIiwic2VlZHMiLCJzZWVkIiwia25vd25BZGFwdGVycyIsInhociIsInJlbmRlclJlYXNvbiIsImlzUmVzb2x2ZWRIYW5kbGUiLCJnZXRBZGFwdGVyIiwiYWRhcHRlcnMiLCJuYW1lT3JBZGFwdGVyIiwicmVqZWN0ZWRSZWFzb25zIiwicmVhc29ucyIsInN0YXRlIiwicyIsInRocm93SWZDYW5jZWxsYXRpb25SZXF1ZXN0ZWQiLCJ0aHJvd0lmUmVxdWVzdGVkIiwiZGlzcGF0Y2hSZXF1ZXN0Iiwib25BZGFwdGVyUmVzb2x1dGlvbiIsIm9uQWRhcHRlclJlamVjdGlvbiIsInZhbGlkYXRvcnMkMSIsInZhbGlkYXRvciIsImRlcHJlY2F0ZWRXYXJuaW5ncyIsInZlcnNpb24iLCJmb3JtYXRNZXNzYWdlIiwiZGVzYyIsIm9wdHMiLCJzcGVsbGluZyIsImNvcnJlY3RTcGVsbGluZyIsImFzc2VydE9wdGlvbnMiLCJzY2hlbWEiLCJhbGxvd1Vua25vd24iLCJ2YWxpZGF0b3JzIiwiQXhpb3MiLCJpbnN0YW5jZUNvbmZpZyIsImludGVyY2VwdG9ycyIsImNvbmZpZ09yVXJsIiwiZHVtbXkiLCJjYXB0dXJlU3RhY2tUcmFjZSIsImJvb2xlYW4iLCJmdW5jdGlvbiIsImJhc2VVcmwiLCJ3aXRoWHNyZlRva2VuIiwiY29udGV4dEhlYWRlcnMiLCJyZXF1ZXN0SW50ZXJjZXB0b3JDaGFpbiIsInN5bmNocm9ub3VzUmVxdWVzdEludGVyY2VwdG9ycyIsInVuc2hpZnRSZXF1ZXN0SW50ZXJjZXB0b3JzIiwiaW50ZXJjZXB0b3IiLCJ1bnNoaWZ0IiwicmVzcG9uc2VJbnRlcmNlcHRvckNoYWluIiwicHVzaFJlc3BvbnNlSW50ZXJjZXB0b3JzIiwicHJvbWlzZSIsImNoYWluIiwib25GdWxmaWxsZWQiLCJvblJlamVjdGVkIiwiZ2V0VXJpIiwiZm9yRWFjaE1ldGhvZE5vRGF0YSIsImZvckVhY2hNZXRob2RXaXRoRGF0YSIsImdlbmVyYXRlSFRUUE1ldGhvZCIsImlzRm9ybSIsImh0dHBNZXRob2QiLCJBeGlvcyQxIiwiQ2FuY2VsVG9rZW4iLCJleGVjdXRvciIsInJlc29sdmVQcm9taXNlIiwicHJvbWlzZUV4ZWN1dG9yIiwiX2xpc3RlbmVycyIsIm9uZnVsZmlsbGVkIiwiYyIsIkNhbmNlbFRva2VuJDEiLCJzcHJlYWQiLCJwYXlsb2FkIiwiSHR0cFN0YXR1c0NvZGUiLCJDb250aW51ZSIsIlN3aXRjaGluZ1Byb3RvY29scyIsIlByb2Nlc3NpbmciLCJFYXJseUhpbnRzIiwiT2siLCJDcmVhdGVkIiwiQWNjZXB0ZWQiLCJOb25BdXRob3JpdGF0aXZlSW5mb3JtYXRpb24iLCJOb0NvbnRlbnQiLCJSZXNldENvbnRlbnQiLCJQYXJ0aWFsQ29udGVudCIsIk11bHRpU3RhdHVzIiwiQWxyZWFkeVJlcG9ydGVkIiwiSW1Vc2VkIiwiTXVsdGlwbGVDaG9pY2VzIiwiTW92ZWRQZXJtYW5lbnRseSIsIkZvdW5kIiwiU2VlT3RoZXIiLCJOb3RNb2RpZmllZCIsIlVzZVByb3h5IiwiVW51c2VkIiwiVGVtcG9yYXJ5UmVkaXJlY3QiLCJQZXJtYW5lbnRSZWRpcmVjdCIsIkJhZFJlcXVlc3QiLCJVbmF1dGhvcml6ZWQiLCJQYXltZW50UmVxdWlyZWQiLCJGb3JiaWRkZW4iLCJOb3RGb3VuZCIsIk1ldGhvZE5vdEFsbG93ZWQiLCJOb3RBY2NlcHRhYmxlIiwiUHJveHlBdXRoZW50aWNhdGlvblJlcXVpcmVkIiwiUmVxdWVzdFRpbWVvdXQiLCJDb25mbGljdCIsIkdvbmUiLCJMZW5ndGhSZXF1aXJlZCIsIlByZWNvbmRpdGlvbkZhaWxlZCIsIlBheWxvYWRUb29MYXJnZSIsIlVyaVRvb0xvbmciLCJVbnN1cHBvcnRlZE1lZGlhVHlwZSIsIlJhbmdlTm90U2F0aXNmaWFibGUiLCJFeHBlY3RhdGlvbkZhaWxlZCIsIkltQVRlYXBvdCIsIk1pc2RpcmVjdGVkUmVxdWVzdCIsIlVucHJvY2Vzc2FibGVFbnRpdHkiLCJMb2NrZWQiLCJGYWlsZWREZXBlbmRlbmN5IiwiVG9vRWFybHkiLCJVcGdyYWRlUmVxdWlyZWQiLCJQcmVjb25kaXRpb25SZXF1aXJlZCIsIlRvb01hbnlSZXF1ZXN0cyIsIlJlcXVlc3RIZWFkZXJGaWVsZHNUb29MYXJnZSIsIlVuYXZhaWxhYmxlRm9yTGVnYWxSZWFzb25zIiwiSW50ZXJuYWxTZXJ2ZXJFcnJvciIsIk5vdEltcGxlbWVudGVkIiwiQmFkR2F0ZXdheSIsIlNlcnZpY2VVbmF2YWlsYWJsZSIsIkdhdGV3YXlUaW1lb3V0IiwiSHR0cFZlcnNpb25Ob3RTdXBwb3J0ZWQiLCJWYXJpYW50QWxzb05lZ290aWF0ZXMiLCJJbnN1ZmZpY2llbnRTdG9yYWdlIiwiTG9vcERldGVjdGVkIiwiTm90RXh0ZW5kZWQiLCJOZXR3b3JrQXV0aGVudGljYXRpb25SZXF1aXJlZCIsIldlYlNlcnZlcklzRG93biIsIkNvbm5lY3Rpb25UaW1lZE91dCIsIk9yaWdpbklzVW5yZWFjaGFibGUiLCJUaW1lb3V0T2NjdXJyZWQiLCJTc2xIYW5kc2hha2VGYWlsZWQiLCJJbnZhbGlkU3NsQ2VydGlmaWNhdGUiLCJIdHRwU3RhdHVzQ29kZSQxIiwiY3JlYXRlSW5zdGFuY2UiLCJkZWZhdWx0Q29uZmlnIiwiaW5zdGFuY2UiLCJheGlvcyIsIkNhbmNlbCIsInByb21pc2VzIiwiZm9ybVRvSlNPTiIsImRlZmF1bHQiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/axios/dist/node/axios.cjs\n");

/***/ })

};
;